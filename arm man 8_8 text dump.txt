A8.8 Alphabetical list of instructions
This section lists every instruction. For details of the format used see Format of instruction descriptions on
page A8-282.
This section is formatted so that a full description of an instruction uses a double page.
A8.8.1 ADC (immediate)
Add with Carry (immediate) adds an immediate value and the Carry flag value to a register value, and writes the
result to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ThumbExpandImm(i:imm3:imm8);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
Encoding T1 ARMv6T2, ARMv7
ADC{S}<c> <Rd>, <Rn>, #<const>
TOKENADC{S}<c> <Rd>, <Rn>, #<const>
1 1 1 0 i 0 1 0 1 0 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 0 1 0 1 0 1 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-301
ID051414 Non-Confidential
Assembler syntax
ADC{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the
address calculated by the operation. This is an interworking branch, see Pseudocode details of
operations on ARM core registers on page A2-47. ARM deprecates this use of PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions. ARM deprecates this use of PC.
<const> The immediate value to be added to the value obtained from <Rn>. See Modified immediate constants
in Thumb instructions on page A6-232 or Modified immediate constants in ARM instructions on
page A5-200 for the range of values.
The pre-UAL syntax ADC<c>S is equivalent to ADCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], imm32, APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-302 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.2 ADC (register)
Add with Carry (register) adds a register value, the Carry flag value, and an optionally-shifted register value, and
writes the result to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADCS <Rdn>, <Rm> Outside IT block.
ADC<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
ADC{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
TOKENADC{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 0 1 0 1 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 0 1 0 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 0 0 0 1 0 1 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-303
ID051414 Non-Confidential
Assembler syntax
ADC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions. ARM deprecates this use of the
PC.
<Rm> The optionally shifted second operand register. The PC can be used in ARM instructions. ARM
deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and any encoding is permitted. Shifts applied to a register on page A8-291 describes
the shifts and how they are encoded.
In Thumb assembly:
• outside an IT block, if ADCS <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled using
encoding T1 as though ADCS <Rd>, <Rn> had been written.
• inside an IT block, if ADC<c> <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled
using encoding T1 as though ADC<c> <Rd>, <Rn> had been written.
To prevent either of these happening, use the .W qualifier.
The pre-UAL syntax ADC<c>S is equivalent to ADCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], shifted, APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-304 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.3 ADC (register-shifted register)
Add with Carry (register-shifted register) adds a register value, the Carry flag value, and a register-shifted register
value. It writes the result to the destination register, and can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENADC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
0 0 0 0 1 0 1 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-305
ID051414 Non-Confidential
Assembler syntax
ADC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax ADC<c>S is equivalent to ADCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], shifted, APSR.C);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-306 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.4 ADD (immediate, Thumb)
This instruction adds an immediate value to a register value, and writes the result to the destination register. It can
optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); setflags = !InITBlock(); imm32 = ZeroExtend(imm3, 32);
d = UInt(Rdn); n = UInt(Rdn); setflags = !InITBlock(); imm32 = ZeroExtend(imm8, 32);
if Rd == ‘1111’ && S == ‘1’ then SEE CMN (immediate);
if Rn == ‘1101’ then SEE ADD (SP plus immediate);
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ThumbExpandImm(i:imm3:imm8);
if d == 13 || (d == 15 && S == ‘0’) || n == 15 then UNPREDICTABLE;
if Rn == ‘1111’ then SEE ADR;
if Rn == ‘1101’ then SEE ADD (SP plus immediate);
d = UInt(Rd); n = UInt(Rn); setflags = FALSE; imm32 = ZeroExtend(i:imm3:imm8, 32);
if d IN {13,15} then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADDS <Rd>, <Rn>, #<imm3> Outside IT block.
ADD<c> <Rd>, <Rn>, #<imm3> Inside IT block.
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADDS <Rdn>, #<imm8> Outside IT block.
ADD<c> <Rdn>, #<imm8> Inside IT block.
Encoding T3 ARMv6T2, ARMv7
ADD{S}<c>.W <Rd>, <Rn>, #<const>
Encoding T4 ARMv6T2, ARMv7
ADDW<c> <Rd>, <Rn>, #<imm12>
0 0 0 1 1 1 0 imm3 Rn Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 0 1 1 0 Rdn imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 0 1 0 0 0 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 1 0 0 0 0 0 Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-307
ID051414 Non-Confidential
Assembler syntax
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register. If <Rn> is SP, see ADD (SP plus immediate) on page A8-316. If <Rn> is
PC, see ADR on page A8-322.
<const> The immediate value to be added to the value obtained from <Rn>. The range of values is 0-7 for
encoding T1, 0-255 for encoding T2 and 0-4095 for encoding T4. See Modified immediate constants
in Thumb instructions on page A6-232 for the range of values for encoding T3.
When multiple encodings of the same length are available for an instruction, encoding T3 is preferred to encoding
T4 (if encoding T4 is required, use the ADDW syntax). Encoding T1 is preferred to encoding T2 if <Rd> is specified
and encoding T2 is preferred to encoding T1 if <Rd> is omitted.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], imm32, ‘0’);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
ADD{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const> All encodings permitted
ADDW{<c>}{<q>} {<Rd>,} <Rn>, #<const> Only encoding T4 permitted
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-308 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.5 ADD (immediate, ARM)
This instruction adds an immediate value to a register value, and writes the result to the destination register. It can
optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ && S == ‘0’ then SEE ADR;
if Rn == ‘1101’ then SEE ADD (SP plus immediate);
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
TOKENADD{S}<c> <Rd>, <Rn>, #<const>
0 0 1 0 1 0 0 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-309
ID051414 Non-Confidential
Assembler syntax
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR and related
instructions (ARM) on page B9-2012.
If S is not specified and <Rd> is the PC, the instruction is a branch to the address calculated by the
operation. This is an interworking branch, see Pseudocode details of operations on ARM core
registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. If the SP is specified for <Rn>, see ADD (SP plus immediate) on
page A8-316. If the PC is specified for <Rn>, see ADR on page A8-322.
<const> The immediate value to be added to the value obtained from <Rn>. See Modified immediate constants
in ARM instructions on page A5-200 for the range of values.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], imm32, ‘0’);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
ADD{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-310 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.6 ADD (register, Thumb)
This instruction adds a register value and an optionally-shifted register value, and writes the result to the destination
register. It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
if (DN:Rdn) == ‘1101’ || Rm == ‘1101’ then SEE ADD (SP plus register);
d = UInt(DN:Rdn); n = d; m = UInt(Rm); setflags = FALSE; (shift_t, shift_n) = (SRType_LSL, 0);
if n == 15 && m == 15 then UNPREDICTABLE;
if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
if Rd == ‘1111’ && S == ‘1’ then SEE CMN (register);
if Rn == ‘1101’ then SEE ADD (SP plus register);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d == 13 || (d == 15 && S == ‘0’) || n == 15 || m IN {13,15} then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADDS <Rd>, <Rn>, <Rm> Outside IT block.
ADD<c> <Rd>, <Rn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7 if <Rdn> and <Rm> are both from R0-R7
ARMv4T, ARMv5T*, ARMv6*, ARMv7 otherwise
ADD<c> <Rdn>, <Rm> If <Rdn> is the PC, must be outside or last in IT block.
Encoding T3 ARMv6T2, ARMv7
ADD{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
0 0 0 1 1 0 0 Rm Rn Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 1 0 0 0 1 0 0
DN
Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 0 0 0 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-311
ID051414 Non-Confidential
Assembler syntax
ADD{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see CMN (register) on page A8-366. If
omitted, <Rd> is the same as <Rn> and encoding T2 is preferred to encoding T1 inside an IT block. If
<Rd> is present, encoding T1 is preferred to encoding T2.
If <Rd> is the PC and S is not specified, encoding T2 is used and the instruction is a branch to the
address calculated by the operation. This is a simple branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
<Rn> The first operand register. The PC can be used in encoding T2. If <Rn> is SP, see ADD (SP plus
register, Thumb) on page A8-318.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in
encoding T2
<shift> The shift to apply to the value read from <Rm>. If present, only encoding T3 is permitted. If omitted,
no shift is applied and any encoding is permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
Inside an IT block, if ADD<c> <Rd>, <Rn>, <Rd> cannot be assembled using encoding T1, it is assembled using
encoding T2 as though ADD<c> <Rd>, <Rn> had been written. To prevent this happening, use the .W qualifier.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], shifted, ‘0’);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-312 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.7 ADD (register, ARM)
This instruction adds a register value and an optionally-shifted register value, and writes the result to the destination
register. It can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
if Rn == ‘1101’ then SEE ADD (SP plus register);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
TOKENADD{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
cond 0 0 0 0 1 0 0 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-313
ID051414 Non-Confidential
Assembler syntax
ADD{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR and related
instructions (ARM) on page B9-2012. If omitted, <Rd> is the same as <Rn>.
If <Rd> is the PC and S is not specified, the instruction is a branch to the address calculated by the
operation. This is an interworking branch, see Pseudocode details of operations on ARM core
registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used. If <Rn> is SP, see ADD (SP plus register, Thumb) on
page A8-318.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used.
<shift> The shift to apply to the value read from <Rm>. If present, only encoding T3 or A1 is permitted. If
omitted, no shift is applied and any encoding is permitted. Shifts applied to a register on
page A8-291 describes the shifts and how they are encoded.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], shifted, ‘0’);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-314 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.8 ADD (register-shifted register)
Add (register-shifted register) adds a register value and a register-shifted register value. It writes the result to the
destination register, and can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENADD{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 0 1 0 0 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-315
ID051414 Non-Confidential
Assembler syntax
ADD{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], shifted, ‘0’);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-316 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.9 ADD (SP plus immediate)
This instruction adds an immediate value to the SP value, and writes the result to the destination register.
d = UInt(Rd); setflags = FALSE; imm32 = ZeroExtend(imm8:’00’, 32);
d = 13; setflags = FALSE; imm32 = ZeroExtend(imm7:’00’, 32);
if Rd == ‘1111’ && S == ‘1’ then SEE CMN (immediate);
d = UInt(Rd); setflags = (S == ‘1’); imm32 = ThumbExpandImm(i:imm3:imm8);
if d == 15 && S == ‘0’ then UNPREDICTABLE;
d = UInt(Rd); setflags = FALSE; imm32 = ZeroExtend(i:imm3:imm8, 32);
if d == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADD<c> <Rd>, SP, #<imm>
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADD<c> SP, SP, #<imm>
Encoding T3 ARMv6T2, ARMv7
ADD{S}<c>.W <Rd>, SP, #<const>
Encoding T4 ARMv6T2, ARMv7
ADDW<c> <Rd>, SP, #<imm12>
TOKENADD{S}<c> <Rd>, SP, #<const>
1 0 1 0 1 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 0 1 1 0 0 0 0 0 imm7
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 0 1 0 0 0 S 1 1 0 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 1 0 0 0 0 0 1 1 0 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 1 0 0 S 1 1 0 1 Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-317
ID051414 Non-Confidential
Assembler syntax
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012. If omitted, <Rd>
is SP.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<const> The immediate value to be added to the value obtained from SP. Values are multiples of 4 in the
range 0-1020 for encoding T1, multiples of 4 in the range 0-508 for encoding T2 and any value in
the range 0-4095 for encoding T4. See Modified immediate constants in Thumb instructions on
page A6-232 or Modified immediate constants in ARM instructions on page A5-200 for the range
of values for encodings T3 and A1.
When both 32-bit encodings are available for an instruction, encoding T3 is preferred to encoding
T4.
Note
If encoding T4 is required, use the ADDW syntax.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(SP, imm32, ‘0’);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
ADD{S}{<c>}{<q>} {<Rd>,} SP, #<const> All encodings permitted
ADDW{<c>}{<q>} {<Rd>,} SP, #<const> Only encoding T4 is permitted
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-318 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.10 ADD (SP plus register, Thumb)
This instruction adds an optionally-shifted register value to the SP value, and writes the result to the destination
register.
d = UInt(DM:Rdm); m = UInt(DM:Rdm); setflags = FALSE;
if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rm == ‘1101’ then SEE encoding T1;
d = 13; m = UInt(Rm); setflags = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rd == ‘1111’ && S == ‘1’ then SEE CMN (register);
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d == 13 && (shift_t != SRType_LSL || shift_n > 3) then UNPREDICTABLE;
if (d == 15 && S == ‘0’) || m IN {13,15} then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADD<c> <Rdm>, SP, <Rdm>
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADD<c> SP, <Rm>
Encoding T3 ARMv6T2, ARMv7
ADD{S}<c>.W <Rd>, SP, <Rm>{, <shift>}
0 1 0 0 0 1 0 0
DM
1 1 0 1 Rdm
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 1 0 0 0 1 0 0 1 Rm 1 0 1
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 0 0 0 S 1 1 0 1 (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-319
ID051414 Non-Confidential
Assembler syntax
ADD{S}{<c>}{<q>} {<Rd>,} SP, <Rm>{, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see CMN (register) on page A8-366.
This register can be SP. If omitted, <Rd> is SP. This register can be the PC, but if it is, encoding T3
is not permitted. ARM deprecates using the PC.
If <Rd> is the PC and S is not specified, encoding T1 is used and the instruction is a branch to the
address calculated by the operation. This is a simple branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
<Rm> The register that is optionally shifted and used as the second operand. This register can be the PC,
but if it is, encoding T3 is not permitted. ARM deprecates using the PC. This register can be the SP,
but:
• ARM deprecates using the SP
• only encoding T1 is available and so the instruction can only be ADD SP, SP, SP.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied and any encoding is
permitted. If present, only encoding T3 is permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
If <Rd> is SP or omitted, <shift> is only permitted to be omitted, LSL #1, LSL #2, or LSL #3.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(SP, shifted, ‘0’);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-320 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.11 ADD (SP plus register, ARM)
This instruction adds an optionally-shifted register value to the SP value, and writes the result to the destination
register.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
TOKENADD{S}<c> <Rd>, SP, <Rm>{, <shift>}
cond 0 0 0 0 1 0 0 S 1 1 0 1 Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-321
ID051414 Non-Confidential
Assembler syntax
ADD{S}{<c>}{<q>} {<Rd>,} SP, <Rm>{, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR and related
instructions (ARM) on page B9-2012. This register can be SP. If omitted, <Rd> is SP. This register
can be the PC, but ARM deprecates using the PC.
If S is not specified and <Rd> is the PC, the instruction is a branch to the address calculated by the
operation. This is an interworking branch, see Pseudocode details of operations on ARM core
registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rm> The register that is optionally shifted and used as the second operand. This register can be the PC,
but ARM deprecates using the PC. This register can be the SP, but ARM deprecates using the SP.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied and any encoding is
permitted. Shifts applied to a register on page A8-291 describes the shifts and how they are
encoded.
The pre-UAL syntax ADD<c>S is equivalent to ADDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(SP, shifted, ‘0’);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-322 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.12 ADR
This instruction adds an immediate value to the PC value to form a PC-relative address, and writes the result to the
destination register.
d = UInt(Rd); imm32 = ZeroExtend(imm8:’00’, 32); add = TRUE;
d = UInt(Rd); imm32 = ZeroExtend(i:imm3:imm8, 32); add = FALSE;
if d IN {13,15} then UNPREDICTABLE;
d = UInt(Rd); imm32 = ZeroExtend(i:imm3:imm8, 32); add = TRUE;
if d IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); imm32 = ARMExpandImm(imm12); add = TRUE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); imm32 = ARMExpandImm(imm12); add = FALSE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ADR<c> <Rd>, <label>
Encoding T2 ARMv6T2, ARMv7
ADR<c>.W <Rd>, <label> <label> before current instruction
SUB <Rd>, PC, #0 Special case for subtraction of zero
Encoding T3 ARMv6T2, ARMv7
ADR<c>.W <Rd>, <label> <label> after current instruction
TOKENADR<c> <Rd>, <label> <label> after current instruction
Encoding A2 ARMv4*, ARMv5T*, ARMv6*, ARMv7
ADR<c> <Rd>, <label> <label> before current instruction
SUB <Rd>, PC, #0 Special case for subtraction of zero
1 0 1 0 0 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 1 0 1 0 1 0 1 1 1 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 1 0 0 0 0 0 1 1 1 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 1 0 0 0 1 1 1 1 Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 0 1 0 0 1 1 1 1 Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-323
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. In ARM instructions, if <Rd> is the PC, the instruction is a branch to the
address calculated by the operation. This is an interworking branch, see Pseudocode details of
operations on ARM core registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<label> The label of an instruction or literal data item whose address is to be loaded into <Rd>. The assembler
calculates the required value of the offset from the Align(PC, 4) value of the ADR instruction to this
label.
If the offset is zero or positive, encodings T1, T3, and A1 are permitted, with imm32 equal to the
offset.
If the offset is negative, encodings T2 and A2 are permitted, with imm32 equal to the size of the offset.
That is, the use of encoding T2 or A2 indicates that the required offset is minus the value of imm32.
Permitted values of the size of the offset are:
Encoding T1 Multiples of 4 in the range 0 to 1020.
Encodings T2, T3 Any value in the range 0 to 4095.
Encodings A1, A2 Any of the constants described in Modified immediate constants in ARM
instructions on page A5-200.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
if d == 15 then // Can only occur for ARM encodings
ALUWritePC(result);
else
R[d] = result;
Exceptions
None.
ADR{<c>}{<q>} <Rd>, <label> Normal syntax
ADD{<c>}{<q>} <Rd>, PC, #<const> Alternative for encodings T1, T3, A1
SUB{<c>}{<q>} <Rd>, PC, #<const> Alternative for encoding T2, A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-324 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.13 AND (immediate)
This instruction performs a bitwise AND of a register value and an immediate value, and writes the result to the
destination register.
if Rd == ‘1111’ && S == ‘1’ then SEE TST (immediate);
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if d == 13 || (d == 15 && S == ‘0’) || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
Encoding T1 ARMv6T2, ARMv7
AND{S}<c> <Rd>, <Rn>, #<const>
TOKENAND{S}<c> <Rd>, <Rn>, #<const>
1 1 1 0 i 0 0 0 0 0 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 0 0 0 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-325
ID051414 Non-Confidential
Assembler syntax
AND{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions. ARM deprecates this use of the
PC.
<const> The immediate value to be ANDed with the value obtained from <Rn>. See Modified immediate
constants in Thumb instructions on page A6-232 or Modified immediate constants in ARM
instructions on page A5-200 for the range of values.
The pre-UAL syntax AND<c>S is equivalent to ANDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[n] AND imm32;
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-326 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.14 AND (register)
This instruction performs a bitwise AND of a register value and an optionally-shifted register value, and writes the
result to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
if Rd == ‘1111’ && S == ‘1’ then SEE TST (register);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d == 13 || (d == 15 && S == ‘0’) || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ANDS <Rdn>, <Rm> Outside IT block.
AND<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
AND{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
TOKENAND{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 0 0 0 0 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 0 0 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 0 0 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-327
ID051414 Non-Confidential
Assembler syntax
AND{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions. ARM deprecates this use of the
PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions. ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
In Thumb assembly:
• outside an IT block, if ANDS <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled using
encoding T1 as though ANDS <Rd>, <Rn> had been written
• inside an IT block, if AND<c> <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled
using encoding T1 as though AND<c> <Rd>, <Rn> had been written.
To prevent either of these happening, use the .W qualifier.
The pre-UAL syntax AND<c>S is equivalent to ANDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] AND shifted;
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-328 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.15 AND (register-shifted register)
This instruction performs a bitwise AND of a register value and a register-shifted register value. It writes the result
to the destination register, and can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENAND{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 0 0 0 0 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-329
ID051414 Non-Confidential
Assembler syntax
AND{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax AND<c>S is equivalent to ANDS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] AND shifted;
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-330 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.16 ASR (immediate)
Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies
of its sign bit, and writes the result to the destination register. It can optionally update the condition flags based on
the result.
d = UInt(Rd); m = UInt(Rm); setflags = !InITBlock();
(-, shift_n) = DecodeImmShift(‘10’, imm5);
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘10’, imm3:imm2);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘10’, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ASRS <Rd>, <Rm>, #<imm> Outside IT block.
ASR<c> <Rd>, <Rm>, #<imm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
ASR{S}<c>.W <Rd>, <Rm>, #<imm>
TOKENASR{S}<c> <Rd>, <Rm>, #<imm>
0 0 0 1 0 imm5 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 1 0 S 1 1 1 1 (0) imm3 Rd imm2 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd imm5 1 0 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-331
ID051414 Non-Confidential
Assembler syntax
ASR{S}{<c>}{<q>} {<Rd>,} <Rm>, #<imm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rm> The first operand register. The PC can be used in ARM instructions. ARM deprecates this use of the
PC.
<imm> The shift amount, in the range 1 to 32. See Shifts applied to a register on page A8-291.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry) = Shift_C(R[m], SRType_ASR, shift_n, APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-332 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.17 ASR (register)
Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its
sign bit, and writes the result to the destination register. The variable number of bits is read from the bottom byte of
a register. It can optionally update the condition flags based on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ASRS <Rdn>, <Rm> Outside IT block.
ASR<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
ASR{S}<c>.W <Rd>, <Rn>, <Rm>
TOKENASR{S}<c> <Rd>, <Rn>, <Rm>
0 1 0 0 0 0 0 1 0 0 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 1 0 S Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd Rm 0 1 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-333
ID051414 Non-Confidential
Assembler syntax
ASR{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register whose bottom byte contains the amount to shift by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[m]<7:0>);
(result, carry) = Shift_C(R[n], SRType_ASR, shift_n, APSR.C);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-334 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.18 B
Branch causes a branch to a target address.
if cond == ‘1110’ then SEE UDF;
if cond == ‘1111’ then SEE SVC;
imm32 = SignExtend(imm8:’0’, 32);
if InITBlock() then UNPREDICTABLE;
imm32 = SignExtend(imm11:’0’, 32);
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
if cond<3:1> == ‘111’ then SEE “Related encodings”;
imm32 = SignExtend(S:J2:J1:imm6:imm11:’0’, 32);
if InITBlock() then UNPREDICTABLE;
I1 = NOT(J1 EOR S); I2 = NOT(J2 EOR S); imm32 = SignExtend(S:I1:I2:imm10:imm11:’0’, 32);
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
imm32 = SignExtend(imm24:’00’, 32);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
B<c> <label> Not permitted in IT block.
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
B<c> <label> Outside or last in IT block
Encoding T3 ARMv6T2, ARMv7
B<c>.W <label> Not permitted in IT block.
Encoding T4 ARMv6T2, ARMv7
B<c>.W <label> Outside or last in IT block
TOKENB<c> <label>
Related encodings See Branches and miscellaneous control on page A6-235.
1 1 0 1 cond imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 imm11
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 S cond imm6 1 0 J1 0 J2 imm11
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 S imm10 1 0 J1 1 J2 imm11
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 0 1 0 imm24
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-335
ID051414 Non-Confidential
Assembler syntax
B{<c>}{<q>} <label>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
Note
Encodings T1 and T3 are conditional in their own right, and do not require an IT instruction to make
them conditional.
For encodings T1 and T3, <c> must not be AL or omitted. The 4-bit encoding of the condition is
placed in the instruction and not in a preceding IT instruction, and the instruction must not be in an
IT block. As a result, encodings T1 and T2 are never both available to the assembler, nor are
encodings T3 and T4.
<label> The label of the instruction that is to be branched to. The assembler calculates the required value of
the offset from the PC value of the B instruction to this label, then selects an encoding that sets imm32
to that offset.
Permitted offsets are:
Encoding T1 Even numbers in the range –256 to 254
Encoding T2 Even numbers in the range –2048 to 2046
Encoding T3 Even numbers in the range –1048576 to 1048574
Encoding T4 Even numbers in the range –16777216 to 16777214
TOKENOperation
if ConditionPassed() then
EncodingSpecificOperations();
BranchWritePC(PC + imm32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-336 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.19 BFC
Bit Field Clear clears any number of adjacent bits at any position in a register, without affecting the other bits in the
register.
d = UInt(Rd); msbit = UInt(msb); lsbit = UInt(imm3:imm2);
if d IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); msbit = UInt(msb); lsbit = UInt(lsb);
if d == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
BFC<c> <Rd>, #<lsb>, #<width>
TOKENBFC<c> <Rd>, #<lsb>, #<width>
1 1 1 0 (0) 1 1 0 1 1 0 1 1 1 1 0 imm3 Rd imm2 (0) msb
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 1 1 0 msb Rd lsb 0 0 1 1 1 1 1
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-337
ID051414 Non-Confidential
Assembler syntax
BFC{<c>}{<q>} <Rd>, #<lsb>, #<width>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<lsb> The least significant bit that is to be cleared, in the range 0 to 31. This determines the required value
of lsbit.
<width> The number of bits to be cleared, in the range 1 to 32-<lsb>. The required value of msbit is
<lsb>+<width>-1.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if msbit >= lsbit then
R[d]<msbit:lsbit> = Replicate(‘0’, msbit-lsbit+1);
// Other bits of R[d] are unchanged
else
UNPREDICTABLE;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-338 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.20 BFI
Bit Field Insert copies any number of low order bits from a register into the same number of adjacent bits at any
position in the destination register.
if Rn == ‘1111’ then SEE BFC;
d = UInt(Rd); n = UInt(Rn); msbit = UInt(msb); lsbit = UInt(imm3:imm2);
if d IN {13,15} || n == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE BFC;
d = UInt(Rd); n = UInt(Rn); msbit = UInt(msb); lsbit = UInt(lsb);
if d == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
BFI<c> <Rd>, <Rn>, #<lsb>, #<width>
TOKENBFI<c> <Rd>, <Rn>, #<lsb>, #<width>
1 1 1 0 (0) 1 1 0 1 1 0 Rn 0 imm3 Rd imm2 (0) msb
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 1 1 0 msb Rd lsb 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-339
ID051414 Non-Confidential
Assembler syntax
BFI{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The source register.
<lsb> The least significant destination bit, in the range 0 to 31. This determines the required value of lsbit.
<width> The number of bits to be copied, in the range 1 to 32-<lsb>. The required value of msbit is
<lsb>+<width>-1.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if msbit >= lsbit then
R[d]<msbit:lsbit> = R[n]<(msbit-lsbit):0>;
// Other bits of R[d] are unchanged
else
UNPREDICTABLE;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-340 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.21 BIC (immediate)
Bitwise Bit Clear (immediate) performs a bitwise AND of a register value and the complement of an immediate
value, and writes the result to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
Encoding T1 ARMv6T2, ARMv7
BIC{S}<c> <Rd>, <Rn>, #<const>
TOKENBIC{S}<c> <Rd>, <Rn>, #<const>
1 1 1 0 i 0 0 0 0 1 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 1 1 0 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-341
ID051414 Non-Confidential
Assembler syntax
BIC{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The register that contains the operand. The PC can be used in ARM instructions. ARM deprecates
this use of the PC.
<const> The immediate value to be bitwise inverted and ANDed with the value obtained from <Rn>. See
Modified immediate constants in Thumb instructions on page A6-232 or Modified immediate
constants in ARM instructions on page A5-200 for the range of values.
The pre-UAL syntax BIC<c>S is equivalent to BICS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[n] AND NOT(imm32);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-342 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.22 BIC (register)
Bitwise Bit Clear (register) performs a bitwise AND of a register value and the complement of an optionally-shifted
register value, and writes the result to the destination register. It can optionally update the condition flags based on
the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
BICS <Rdn>, <Rm> Outside IT block.
BIC<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
BIC{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
TOKENBIC{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 1 1 1 0 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 0 1 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 1 0 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-343
ID051414 Non-Confidential
Assembler syntax
BIC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions. ARM deprecates this use of the
PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions. ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
The pre-UAL syntax BIC<c>S is equivalent to BICS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] AND NOT(shifted);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-344 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.23 BIC (register-shifted register)
Bitwise Bit Clear (register-shifted register) performs a bitwise AND of a register value and the complement of a
register-shifted register value. It writes the result to the destination register, and can optionally update the condition
flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENBIC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 1 1 1 0 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-345
ID051414 Non-Confidential
Assembler syntax
BIC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax BIC<c>S is equivalent to BICS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] AND NOT(shifted);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-346 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.24 BKPT
Breakpoint causes a software breakpoint to occur.
Breakpoint is always unconditional, even when inside an IT block.
imm32 = ZeroExtend(imm8, 32);
// imm32 is for assembly/disassembly only and is ignored by hardware.
imm32 = ZeroExtend(imm12:imm4, 32);
// imm32 is for assembly/disassembly only and is ignored by hardware.
if cond != ‘1110’ then UNPREDICTABLE; // BKPT must be encoded with AL condition
Encoding T1 ARMv5T*, ARMv6*, ARMv7
BKPT #<imm8>
TOKENBKPT #<imm16>
1 0 1 1 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 imm12 0 1 1 1 imm4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-347
ID051414 Non-Confidential
Assembler syntax
BKPT{<q>} {#}<imm>
where:
<q> See Standard assembler syntax fields on page A8-287. A BKPT instruction must be unconditional.
<imm> Specifies a value that is stored in the instruction, in the range 0-255 for a Thumb instruction or
0-65535 for an ARM instruction. This value is ignored by the processor, but can be used by a
debugger to store more information about the breakpoint.
Operation
EncodingSpecificOperations();
BKPTInstrDebugEvent();
Exceptions
Prefetch Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-348 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.25 BL, BLX (immediate)
Branch with Link calls a subroutine at a PC-relative address.
Branch with Link and Exchange Instruction Sets (immediate) calls a subroutine at a PC-relative address, and
changes instruction set from ARM to Thumb, or from Thumb to ARM.
I1 = NOT(J1 EOR S); I2 = NOT(J2 EOR S); imm32 = SignExtend(S:I1:I2:imm10:imm11:’0’, 32);
targetInstrSet = CurrentInstrSet();
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
if CurrentInstrSet() == InstrSet_ThumbEE || H == ‘1’ then UNDEFINED;
I1 = NOT(J1 EOR S); I2 = NOT(J2 EOR S); imm32 = SignExtend(S:I1:I2:imm10H:imm10L:’00’, 32);
targetInstrSet = InstrSet_ARM;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
For the case when cond is 0b1111, see the A2 encoding.
imm32 = SignExtend(imm24:’00’, 32); targetInstrSet = InstrSet_ARM;
imm32 = SignExtend(imm24:H:’0’, 32); targetInstrSet = InstrSet_Thumb;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7 if J1 == J2 == 1
ARMv6T2, ARMv7 otherwise
BL<c> <label> Outside or last in IT block
Encoding T2 ARMv5T*, ARMv6*, ARMv7 if J1 == J2 == 1
ARMv6T2, ARMv7 otherwise
BLX<c> <label> Outside or last in IT block
TOKENBL<c> <label>
Encoding A2 ARMv5T*, ARMv6*, ARMv7
BLX <label>
1 1 1 0 S imm10 1 1 J1 1 J2 imm11
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 S imm10H 1 1 J1 0 J2 imm10L H
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 0 1 1 imm24
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 H imm24
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-349
ID051414 Non-Confidential
Assembler syntax
BL{X}{<c>}{<q>} <label>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM BLX (immediate) instruction must
be unconditional.
X If present, specifies a change of instruction set (from ARM to Thumb or from Thumb to ARM). If
X is omitted, the processor remains in the same state. For ThumbEE instructions, specifying X is
not permitted.
<label> The label of the instruction that is to be branched to.
BL uses encoding T1 or A1. The assembler calculates the required value of the offset from the PC
value of the BL instruction to this label, then selects an encoding with imm32 set to that offset.
BLX uses encoding T2 or A2. The assembler calculates the required value of the offset from the
Align(PC, 4) value of the BLX instruction to this label, then selects an encoding with imm32 set to that
offset.
Permitted offsets are:
Encoding T1 Even numbers in the range –16777216 to 16777214.
Encoding T2 Multiples of 4 in the range –16777216 to 16777212.
TOKENEncoding A2 Even numbers in the range –33554432 to 33554430.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if CurrentInstrSet() == InstrSet_ARM then
LR = PC - 4;
else
LR = PC<31:1> : ‘1’;
if targetInstrSet == InstrSet_ARM then
targetAddress = Align(PC,4) + imm32;
else
targetAddress = PC + imm32;
SelectInstrSet(targetInstrSet);
BranchWritePC(targetAddress);
Exceptions
None.
Branch range before ARMv6T2
Before ARMv6T2, J1 and J2 in encodings T1 and T2 were both 1, resulting in a smaller branch range. The
instructions could be executed as two separate 16-bit instructions, as described in BL and BLX (immediate)
instructions, before ARMv6T2 on page D12-2504.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-350 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.26 BLX (register)
Branch with Link and Exchange (register) calls a subroutine at an address and instruction set specified by a register.
m = UInt(Rm);
if m == 15 then UNPREDICTABLE;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
m = UInt(Rm);
if m == 15 then UNPREDICTABLE;
Encoding T1 ARMv5T*, ARMv6*, ARMv7
BLX<c> <Rm> Outside or last in IT block
TOKENBLX<c> <Rm>
0 1 0 0 0 1 1 1 1 Rm (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-351
ID051414 Non-Confidential
Assembler syntax
BLX{<c>}{<q>} <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rm> The register that contains the branch target address and instruction set selection bit. This register can
be the SP in both ARM and Thumb instructions, but ARM deprecates this use of the SP.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
target = R[m];
if CurrentInstrSet() == InstrSet_ARM then
next_instr_addr = PC - 4;
LR = next_instr_addr;
else
next_instr_addr = PC - 2;
LR = next_instr_addr<31:1> : ‘1’;
BXWritePC(target);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-352 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.27 BX
Branch and Exchange causes a branch to an address and instruction set specified by a register.
m = UInt(Rm);
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
m = UInt(Rm);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
BX<c> <Rm> Outside or last in IT block
TOKENBX<c> <Rm>
0 1 0 0 0 1 1 1 0 Rm (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) 0 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-353
ID051414 Non-Confidential
Assembler syntax
BX{<c>}{<q>} <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rm> The register that contains the branch target address and instruction set selection bit. The PC can be
used. This register can be the SP in both ARM and Thumb instructions, but ARM deprecates this
use of the SP.
Note
If <Rm> is the PC in a Thumb instruction at a non word-aligned address, it results in UNPREDICTABLE
behavior because the address passed to the BXWritePC() pseudocode function has bits<1:0> = '10'.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
BXWritePC(R[m]);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-354 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.28 BXJ
Branch and Exchange Jazelle attempts to change to Jazelle state. If the attempt fails, it branches to an address and
instruction set specified by a register as though it were a BX instruction.
In an implementation that includes the Virtualization Extensions, if HSTR.TJDBX is set to 1, execution of a BXJ
instruction in a Non-secure mode other than Hyp mode generates a Hyp Trap exception. For more information see
Trapping accesses to Jazelle functionality on page B1-1256.
m = UInt(Rm);
if m IN {13,15} then UNPREDICTABLE;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
m = UInt(Rm);
if m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
BXJ<c> <Rm> Outside or last in IT block
TOKENBXJ<c> <Rm>
1 1 1 0 0 1 1 1 1 0 0 Rm 1 0 (0) 0 (1) (1) (1) (1) (0) (0) (0) (0) (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) 0 0 1 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-355
ID051414 Non-Confidential
Assembler syntax
BXJ{<c>}{<q>} <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rm> The register that specifies the branch target address and instruction set selection bit to be used if the
attempt to switch to Jazelle state fails.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if HaveVirtExt() && !IsSecure() && !CurrentModeIsHyp() && HSTR.TJDBX == ‘1’ then
HSRString = Zeros(25);
HSRString<3:0> = m;
WriteHSR(‘001010’, HSRString);
TakeHypTrapException();
elsif JMCR.JE == ‘0’ || CurrentInstrSet() == InstrSet_ThumbEE then
BXWritePC(R[m]);
else
if JazelleAcceptsExecution() then
SwitchToJazelleExecution();
else
SUBARCHITECTURE_DEFINED handler call;
Exceptions
Hyp Trap.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-356 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.29 CBNZ, CBZ
Compare and Branch on Nonzero and Compare and Branch on Zero compare the value in a register with zero, and
conditionally branch forward a constant value. They do not affect the condition flags.
n = UInt(Rn); imm32 = ZeroExtend(i:imm5:’0’, 32); nonzero = (op == ‘1’);
if InITBlock() then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
CB{N}Z <Rn>, <label> Not permitted in IT block.
1 0 1 1 op 0 i 1 imm5 Rn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-357
ID051414 Non-Confidential
Assembler syntax
CB{N}Z{<q>} <Rn>, <label>
where:
N If specified, causes the branch to occur when the contents of <Rn> are nonzero (encoded as op = 1).
If omitted, causes the branch to occur when the contents of <Rn> are zero (encoded as op = 0).
<q> See Standard assembler syntax fields on page A8-287. A CBZ or CBNZ instruction must be
unconditional.
<Rn> The operand register.
<label> The label of the instruction that is to be branched to. The assembler calculates the required value of
the offset from the PC value of the CBZ or CBNZ instruction to this label, then selects an encoding that
sets imm32 to that offset. Permitted offsets are even numbers in the range 0 to 126.
Operation
EncodingSpecificOperations();
if nonzero != IsZero(R[n]) then
BranchWritePC(PC + imm32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-358 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.30 CDP, CDP2
Coprocessor Data Processing tells a coprocessor to perform an operation that is independent of ARM core registers
and memory. If no coprocessor can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the opc1, opc2, CRd, CRn, and CRm fields.
However, coprocessors CP8-CP15 are reserved for use by ARM, and this manual defines the valid CDP and CDP2
instructions when coproc is in the range p8-p15. For more information see Coprocessor support on page A2-94 and
General behavior of system control registers on page B5-1776.
For the case when cond is 0b1111, see the T2 and A2 encoding.
if coproc IN “101x” then SEE “Floating-point instructions”;
cp = UInt(coproc);
if coproc IN “101x” then UNDEFINED;
cp = UInt(coproc);
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv4*, ARMv5T*, ARMv6*, ARMv7 for encoding A1
CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2>
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv5T*, ARMv6*, ARMv7 for encoding A2
CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2>
Floating-point instructions See Floating-point data-processing instructions on page A7-272.
1 1 0 1 1 1 0 opc1 CRn CRd coproc opc2 0 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 1 0 opc1 CRn CRd coproc opc2 0 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 1 0 opc1 CRn CRd coproc opc2 0 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 1 0 opc1 CRn CRd coproc opc2 0 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-359
ID051414 Non-Confidential
Assembler syntax
CDP{2}{<c>}{<q>} <coproc>, {#}<opc1>, <CRd>, <CRn>, <CRm> {, {#}<opc2>}
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM CDP2 instruction must be
unconditional.
<coproc> The name of the coprocessor, and causes the corresponding coprocessor number to be placed in the
cp_num field of the instruction. The generic coprocessor names are p0-p15.
<opc1> Is a coprocessor-specific opcode, in the range 0 to 15.
<CRd> The destination coprocessor register for the instruction.
<CRn> The coprocessor register that contains the first operand.
<CRm> The coprocessor register that contains the second operand.
<opc2> Is a coprocessor-specific opcode in the range 0 to 7. If it is omitted, <opc2> is 0.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
Coproc_InternalOperation(cp, ThisInstr());
Exceptions
Undefined Instruction.
Uses of these instructions by specific coprocessors might generate other exceptions.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-360 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.31 CHKA
CHKA is a ThumbEE instruction, see CHKA on page A9-1124.
A8.8.32 CLREX
Clear-Exclusive clears the local record of the executing processor that an address has had a request for an exclusive
access.
// No additional decoding required
// No additional decoding required
Encoding T1 ARMv7
CLREX<c>
TOKENCLREX
1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 0 1 0 (1) (1) (1) (1)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 1 (1) (1) (1) (1)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-361
ID051414 Non-Confidential
Assembler syntax
CLREX{<c>}{<q>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM CLREX instruction must be
unconditional.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
ClearExclusiveLocal(ProcessorID());
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-362 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.33 CLZ
Count Leading Zeros returns the number of binary zero bits before the first binary one bit in a value.
if !Consistent(Rm) then UNPREDICTABLE;
d = UInt(Rd); m = UInt(Rm);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
CLZ<c> <Rd>, <Rm>
TOKENCLZ<c> <Rd>, <Rm>
1 1 1 1 0 1 0 1 0 1 1 Rm 1 1 1 1 Rd 1 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 1 1 0 (1) (1) (1) (1) Rd (1) (1) (1) (1) 0 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-363
ID051414 Non-Confidential
Assembler syntax
CLZ{<c>}{<q>} <Rd>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand. Its number must be encoded twice in encoding T1.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = CountLeadingZeroBits(R[m]);
R[d] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-364 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.34 CMN (immediate)
Compare Negative (immediate) adds a register value and an immediate value. It updates the condition flags based
on the result, and discards the result.
n = UInt(Rn); imm32 = ThumbExpandImm(i:imm3:imm8);
if n == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); imm32 = ARMExpandImm(imm12);
Encoding T1 ARMv6T2, ARMv7
CMN<c> <Rn>, #<const>
TOKENCMN<c> <Rn>, #<const>
1 1 1 0 i 0 1 0 0 0 1 Rn 0 imm3 1 1 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 1 1 1 Rn (0) (0) (0) (0) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-365
ID051414 Non-Confidential
Assembler syntax
CMN{<c>}{<q>} <Rn>, #<const>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The register that contains the operand. SP can be used in Thumb and ARM instructions. The PC can
be used in ARM instructions, but ARM deprecates this use of the PC.
<const> The immediate value to be added to the value obtained from <Rn>. See Modified immediate constants
in Thumb instructions on page A6-232 or Modified immediate constants in ARM instructions on
page A5-200 for the range of values.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], imm32, ‘0’);
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-366 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.35 CMN (register)
Compare Negative (register) adds a register value and an optionally-shifted register value. It updates the condition
flags based on the result, and discards the result.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if n == 15 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
CMN<c> <Rn>, <Rm>
Encoding T2 ARMv6T2, ARMv7
CMN<c>.W <Rn>, <Rm>{, <shift>}
TOKENCMN<c> <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 1 0 1 1 Rm Rn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 0 0 0 1 Rn (0) imm3 1 1 1 1 imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 1 1 1 Rn (0) (0) (0) (0) imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-367
ID051414 Non-Confidential
Assembler syntax
CMN{<c>}{<q>} <Rn>, <Rm> {, <shift>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register. SP can be used in Thumb instructions (encoding T2) and in ARM
instructions. The PC can be used in ARM instructions, but ARM deprecates this use of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], shifted, ‘0’);
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-368 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.36 CMN (register-shifted register)
Compare Negative (register-shifted register) adds a register value and a register-shifted register value. It updates the
condition flags based on the result, and discards the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
shift_t = DecodeRegShift(type);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENCMN<c> <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 1 0 1 1 1 Rn (0) (0) (0) (0) Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-369
ID051414 Non-Confidential
Assembler syntax
CMN{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], shifted, ‘0’);
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-370 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.37 CMP (immediate)
Compare (immediate) subtracts an immediate value from a register value. It updates the condition flags based on
the result, and discards the result.
n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
n = UInt(Rn); imm32 = ThumbExpandImm(i:imm3:imm8);
if n == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); imm32 = ARMExpandImm(imm12);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
CMP<c> <Rn>, #<imm8>
Encoding T2 ARMv6T2, ARMv7
CMP<c>.W <Rn>, #<const>
TOKENCMP<c> <Rn>, #<const>
0 0 1 0 1 Rn imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 0 1 1 0 1 1 Rn 0 imm3 1 1 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 1 0 1 Rn (0) (0) (0) (0) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-371
ID051414 Non-Confidential
Assembler syntax
CMP{<c>}{<q>} <Rn>, #<const>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register. SP can be used in Thumb instructions (encoding T2) and in ARM
instructions. The PC can be used in ARM instructions, but ARM deprecates this use of the PC.
<const> The immediate value to be compared with the value obtained from <Rn>. The range of values is
0-255 for encoding T1. See Modified immediate constants in Thumb instructions on page A6-232
or Modified immediate constants in ARM instructions on page A5-200 for the range of values for
encoding T2 and A1.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], NOT(imm32), ‘1’);
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-372 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.38 CMP (register)
Compare (register) subtracts an optionally-shifted register value from a register value. It updates the condition flags
based on the result, and discards the result.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);
n = UInt(N:Rn); m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);
if n < 8 && m < 8 then UNPREDICTABLE;
if n == 15 || m == 15 then UNPREDICTABLE;
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if n == 15 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
CMP<c> <Rn>, <Rm> <Rn> and <Rm> both from R0-R7
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
CMP<c> <Rn>, <Rm> <Rn> and <Rm> not both from R0-R7
Encoding T3 ARMv6T2, ARMv7
CMP<c>.W <Rn>, <Rm> {, <shift>}
TOKENCMP<c> <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 1 0 1 0 Rm Rn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 1 0 0 0 1 0 1 N Rm Rn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 1 0 1 1 Rn (0) imm3 1 1 1 1 imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 1 0 1 Rn (0) (0) (0) (0) imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-373
ID051414 Non-Confidential
Assembler syntax
CMP{<c>}{<q>} <Rn>, <Rm> {, <shift>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register. The SP can be used. The PC can be used in ARM instructions, but ARM
deprecates this use of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC. The SP can be used in both ARM and Thumb
instructions, but:
• ARM deprecates the use of SP
• when assembling for the Thumb instruction set, only encoding T2 is available.
<shift> The shift to apply to the value read from <Rm>. If present, encodings T1 and T2 are not permitted. If
absent, no shift is applied and all encodings are permitted. Shifts applied to a register on
page A8-291 describes the shifts and how they are encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], NOT(shifted), ‘1’);
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-374 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.39 CMP (register-shifted register)
Compare (register-shifted register) subtracts a register-shifted register value from a register value. It updates the
condition flags based on the result, and discards the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
shift_t = DecodeRegShift(type);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENCMP<c> <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 1 0 1 0 1 Rn (0) (0) (0) (0) Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-375
ID051414 Non-Confidential
Assembler syntax
CMP{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], NOT(shifted), ‘1’);
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-376 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.40 CPS
Change Processor State is a system instruction, see CPS (Thumb) on page B9-1978 and CPS (ARM) on
page B9-1980.
A8.8.41 CPY
Copy is a pre-UAL synonym for MOV (register).
Assembler syntax
CPY <Rd>, <Rn>
This is equivalent to:
MOV <Rd>, <Rn>
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-377
ID051414 Non-Confidential
A8.8.42 DBG
Debug Hint provides a hint to debug and related systems. See their documentation for what use (if any) they make
of this instruction.
// Any decoding of ‘option’ is specified by the debug system
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
// Any decoding of ‘option’ is specified by the debug system
Assembler syntax
DBG{<c>}{<q>} #<option>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<option> Provides extra information about the hint, and is in the range 0 to 15.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
Hint_Debug(option);
Exceptions
None.
Encoding T1 ARMv7 (executes as NOP in ARMv6T2)
DBG<c> #<option>
TOKENDBG<c> #<option>
1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 1 1 1 1 option
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 1 1 1 1 option
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-378 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.43 DMB
Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data
Memory Barrier (DMB) on page A3-152.
// No additional decoding required
// No additional decoding required
Assembler syntax
DMB{<c>}{<q>} {<option>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM DMB instruction must be
unconditional.
<option> Specifies an optional limitation on the DMB operation. Values are:
SY Full system is the required shareability domain, reads and writes are the required access
types. Can be omitted.
This option is referred to as the full system DMB. Encoded as option = 0b1111.
ST Full system is the required shareability domain, writes are the required access type. SYST
is a synonym for ST. Encoded as option = 0b1110.
ISH Inner Shareable is the required shareability domain, reads and writes are the required
access types. Encoded as option = 0b1011.
ISHST Inner Shareable is the required shareability domain, writes are the required access type.
Encoded as option = 0b1010.
NSH Non-shareable is the required shareability domain, reads and writes are the required
access types. Encoded as option = 0b0111.
NSHST Non-shareable is the required shareability domain, writes are the required access type.
Encoded as option = 0b0110.
OSH Outer Shareable is the required shareability domain, reads and writes are the required
access types. Encoded as option = 0b0011.
OSHST Outer Shareable is the required shareability domain, writes are the required access type.
Encoded as option = 0b0010.
All other encodings of option are reserved. It is IMPLEMENTATION DEFINED whether options other
than SY are implemented. All unsupported and reserved options must execute as a full system DMB
operation, but software must not rely on this behavior.
Encoding T1 ARMv7
DMB<c> <option>
TOKENDMB <option>
1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 1 0 1 option
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 1 0 1 option
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-379
ID051414 Non-Confidential
Note
The instruction supports the following alternative <option> values, but ARM recommends that
software does not use these alternative values:
• SH as an alias for ISH
• SHST as an alias for ISHST
• UN as an alias for NSH
• UNST is an alias for NSHST.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
case option of
when ‘0010’ domain = MBReqDomain_OuterShareable; types = MBReqTypes_Writes;
when ‘0011’ domain = MBReqDomain_OuterShareable; types = MBReqTypes_All;
when ‘0110’ domain = MBReqDomain_Nonshareable; types = MBReqTypes_Writes;
when ‘0111’ domain = MBReqDomain_Nonshareable; types = MBReqTypes_All;
when ‘1010’ domain = MBReqDomain_InnerShareable; types = MBReqTypes_Writes;
when ‘1011’ domain = MBReqDomain_InnerShareable; types = MBReqTypes_All;
when ‘1110’ domain = MBReqDomain_FullSystem; types = MBReqTypes_Writes;
otherwise domain = MBReqDomain_FullSystem; types = MBReqTypes_All;
if HaveVirtExt() && !IsSecure() && !CurrentModeIsHyp() then
if HCR.BSU == ‘11’ then
domain = MBReqDomain_FullSystem;
if HCR.BSU == ‘10’ && domain != MBReqDomain_FullSystem then
domain = MBReqDomain_OuterShareable;
if HCR.BSU == ‘01’ && domain == MBReqDomain_Nonshareable then
domain = MBReqDomain_InnerShareable;
DataMemoryBarrier(domain, types);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-380 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.44 DSB
Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data
Synchronization Barrier (DSB) on page A3-153.
// No additional decoding required
// No additional decoding required
Assembler syntax
DSB{<c>}{<q>} {<option>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM DSB instruction must be
unconditional.
<option> Specifies an optional limitation on the DSB operation. Values are:
SY Full system is the required shareability domain, reads and writes are the required access
types. Can be omitted.
This option is referred to as the full system DSB. Encoded as option = 0b1111.
ST Full system is the required shareability domain, writes are the required access type. SYST
is a synonym for ST. Encoded as option = 0b1110.
ISH Inner Shareable is the required shareability domain, reads and writes are the required
access types. Encoded as option = 0b1011.
ISHST Inner Shareable is the required shareability domain, writes are the required access type.
Encoded as option = 0b1010.
NSH Non-shareable is the required shareability domain, reads and writes are the required
access types. Encoded as option = 0b0111.
NSHST Non-shareable is the required shareability domain, writes are the required access type.
Encoded as option = 0b0110.
OSH Outer Shareable is the required shareability domain, reads and writes are the required
access types. Encoded as option = 0b0011.
OSHST Outer Shareable is the required shareability domain, writes are the required access type.
Encoded as option = 0b0010.
All other encodings of option are reserved. It is IMPLEMENTATION DEFINED whether options other
than SY are implemented. All unsupported and reserved options must execute as a full system DSB
operation, but software must not rely on this behavior.
Encoding T1 ARMv7
DSB<c> <option>
TOKENDSB <option>
1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 1 0 0 option
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 1 0 0 option
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-381
ID051414 Non-Confidential
Note
The instruction supports the following alternative <option> values, but ARM recommends that
software does not use these alternative values:
• SH as an alias for ISH
• SHST as an alias for ISHST
• UN as an alias for NSH
• UNST is an alias for NSHST.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
case option of
when ‘0010’ domain = MBReqDomain_OuterShareable; types = MBReqTypes_Writes;
when ‘0011’ domain = MBReqDomain_OuterShareable; types = MBReqTypes_All;
when ‘0110’ domain = MBReqDomain_Nonshareable; types = MBReqTypes_Writes;
when ‘0111’ domain = MBReqDomain_Nonshareable; types = MBReqTypes_All;
when ‘1010’ domain = MBReqDomain_InnerShareable; types = MBReqTypes_Writes;
when ‘1011’ domain = MBReqDomain_InnerShareable; types = MBReqTypes_All;
when ‘1110’ domain = MBReqDomain_FullSystem; types = MBReqTypes_Writes;
otherwise domain = MBReqDomain_FullSystem; types = MBReqTypes_All;
if HaveVirtExt() && !IsSecure() && !CurrentModeIsHyp() then
if HCR.BSU == ‘11’ then
domain = MBReqDomain_FullSystem;
if HCR.BSU == ‘10’ && domain != MBReqDomain_FullSystem then
domain = MBReqDomain_OuterShareable;
if HCR.BSU == ‘01’ && domain == MBReqDomain_Nonshareable then
domain = MBReqDomain_InnerShareable;
DataSynchronizationBarrier(domain, types);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-382 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.45 ENTERX
ENTERX causes a change from Thumb state to ThumbEE state, or has no effect in ThumbEE state. For details see
ENTERX, LEAVEX on page A9-1116.
A8.8.46 EOR (immediate)
Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value,
and writes the result to the destination register. It can optionally update the condition flags based on the result.
if Rd == ‘1111’ && S == ‘1’ then SEE TEQ (immediate);
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if d == 13 || (d == 15 && S == ‘0’) || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
Encoding T1 ARMv6T2, ARMv7
EOR{S}<c> <Rd>, <Rn>, #<const>
TOKENEOR{S}<c> <Rd>, <Rn>, #<const>
1 1 1 0 i 0 0 1 0 0 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 0 0 1 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-383
ID051414 Non-Confidential
Assembler syntax
EOR{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The register that contains the operand. The PC can be used in ARM instructions, but ARM
deprecates this use of the PC.
<const> The immediate value to be exclusive ORed with the value obtained from <Rn>. See Modified
immediate constants in Thumb instructions on page A6-232 or Modified immediate constants in
ARM instructions on page A5-200 for the range of values.
The pre-UAL syntax EOR<c>S is equivalent to EORS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[n] EOR imm32;
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-384 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.47 EOR (register)
Bitwise Exclusive OR (register) performs a bitwise Exclusive OR of a register value and an optionally-shifted
register value, and writes the result to the destination register. It can optionally update the condition flags based on
the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
if Rd == ‘1111’ && S == ‘1’ then SEE TEQ (register);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d == 13 || (d == 15 && S == ‘0’) || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
EORS <Rdn>, <Rm> Outside IT block.
EOR<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
EOR{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
TOKENEOR{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 0 0 0 1 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 1 0 0 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 0 1 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-385
ID051414 Non-Confidential
Assembler syntax
EOR{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted.Shifts applied to a register on page A8-291 describes
the shifts and how they are encoded.
In Thumb assembly:
• outside an IT block, if EORS <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled using
encoding T1 as though EORS <Rd>, <Rn> had been written
• inside an IT block, if EOR<c> <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled
using encoding T1 as though EOR<c> <Rd>, <Rn> had been written.
To prevent either of these happening, use the .W qualifier.
The pre-UAL syntax EOR<c>S is equivalent to EORS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] EOR shifted;
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-386 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.48 EOR (register-shifted register)
Bitwise Exclusive OR (register-shifted register) performs a bitwise Exclusive OR of a register value and a
register-shifted register value. It writes the result to the destination register, and can optionally update the condition
flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENEOR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 0 0 0 1 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-387
ID051414 Non-Confidential
Assembler syntax
EOR{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax EOR<c>S is equivalent to EORS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] EOR shifted;
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-388 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.49 ERET
Exception Return is a system instruction, see ERET on page B9-1982.
A8.8.50 F*, former Floating-point instruction mnemonics
Before the introduction of UAL, the Floating-point (VFP) instructions had mnemonics starting with F. In UAL, most
of these mnemonics are renamed to start with V. Other UAL mnemonic changes on page D8-2471 lists all of the
Floating-point instruction mnemonic changes. UAL does not define new mnemonics for the FLDMX and FSTMX
instructions, see FLDMX, FSTMX.
FLDMX, FSTMX
Encodings T1/A1 of the VLDM, VPOP, VPUSH, and VSTM instructions contain an imm8 field that is set to twice the number
of doubleword registers to be transferred. ARM deprecates use of these encodings with an odd value in imm8, and
there is no UAL syntax for them.
The pre-UAL mnemonics FLDMX and FSTMX result in the same instructions as FLDMD (VLDM.64 or VPOP.64) and FSTMD
(VSTM.64 or VPUSH.64) respectively, except that imm8 is equal to twice the number of doubleword registers plus one:
• from ARMv6, ARM deprecates use of FLDMX and FSTMX, except for disassembly purposes, and for reassembly
of disassembled code
• if an FLDMX or FSTMX instruction accesses any register in the range D16-D32, the instruction is UNPREDICTABLE.
A8.8.51 HB, HBL, HBLP, HBP
These are ThumbEE instructions, see HB, HBL on page A9-1125, HBLP on page A9-1126, and HBP on
page A9-1127.
A8.8.52 HVC
Hypervisor Call is a system instruction, see HVC on page B9-1984.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-389
ID051414 Non-Confidential
A8.8.53 ISB
Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB
are fetched from cache or memory, after the instruction has been completed. It ensures that the effects of context
changing operations executed before the ISB instruction are visible to the instructions fetched after the ISB. Context
changing operations include changing the Address Space Identifier (ASID), TLB maintenance operations, branch
predictor maintenance operations, and all changes to the CP15 registers. In addition, any branches that appear in
program order after the ISB instruction are written into the branch prediction logic with the context that is visible
after the ISB instruction. This is needed to ensure correct execution of the instruction stream.
// No additional decoding required
// No additional decoding required
Assembler syntax
ISB{<c>}{<q>} {<option>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM ISB instruction must be
unconditional.
<option> Specifies an optional limitation on the ISB operation. Values are:
SY Full system ISB operation, encoded as option = 0b1111. Can be omitted.
All other encodings of option are reserved. The corresponding instructions execute as full system
ISB operations, but must not be relied upon by software.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
InstructionSynchronizationBarrier();
Exceptions
None.
Encoding T1 ARMv7
ISB<c> <option>
TOKENISB <option>
1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 1 1 0 option
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 1 1 0 option
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-390 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.54 IT
If-Then makes up to four following instructions (the IT block) conditional. The conditions for the instructions in the
IT block are the same as, or the inverse of, the condition the IT instruction specifies for the first instruction in the
block.
The IT instruction itself does not affect the condition flags, but the execution of the instructions in the IT block can
change the condition flags.
16-bit instructions in the IT block, other than CMP, CMN and TST, do not set the condition flags. An IT instruction with
the AL condition can be used to get this changed behavior without conditional execution.
The architecture permits exception return to an instruction in the IT block only if the restoration of the CPSR
restores ITSTATE to a state consistent with the conditions specified by the IT instruction. Any other exception return
to an instruction in an IT block is UNPREDICTABLE. Any branch to a target instruction in an IT block is not permitted,
and if such a branch is made it is UNPREDICTABLE what condition is used when executing that target instruction and
any subsequent instruction in the IT block.
See also Conditional instructions on page A4-162 and Conditional execution on page A8-288.
if mask == ‘0000’ then SEE “Related encodings”;
if firstcond == ‘1111’ || (firstcond == ‘1110’ && BitCount(mask) != 1) then UNPREDICTABLE;
if InITBlock() then UNPREDICTABLE;
Assembler syntax
IT{<x>{<y>{<z>}}}{<q>} <firstcond>
where:
<x> The condition for the second instruction in the IT block.
<y> The condition for the third instruction in the IT block.
<z> The condition for the fourth instruction in the IT block.
<q> See Standard assembler syntax fields on page A8-287. An IT instruction must be unconditional.
<firstcond> The condition for the first instruction in the IT block. See Table A8-1 on page A8-288 for the range
of conditions available, and the encodings.
Each of <x>, <y>, and <z> can be either:
T Then. The condition for the instruction is <firstcond>.
E Else. The condition for the instruction is the inverse of <firstcond>. The condition code is the same
as <firstcond>, except that the least significant bit is inverted. E must not be specified if <firstcond>
is AL.
Table A8-2 on page A8-391 shows how the values of <x>, <y>, and <z> determine the value of the mask field.
Encoding T1 ARMv6T2, ARMv7
IT{<x>{<y>{<z>}}} <firstcond> Not permitted in IT block
Related encodings See If-Then, and hints on page A6-229.
1 0 1 1 1 1 1 1 firstcond mask
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-391
ID051414 Non-Confidential
The conditions specified in an IT instruction must match those specified in the syntax of the instructions in its IT
block. When assembling to ARM code, assemblers check IT instruction syntax for validity but do not generate
assembled instructions for them. See Conditional instructions on page A4-162.
Operation
EncodingSpecificOperations();
ITSTATE.IT<7:0> = firstcond:mask;
Exceptions
None.
Table A8-2 Determination of mask field
<x> <y> <z> mask[3] mask[2] mask[1] mask[0]
Omitted Omitted Omitted 1 0 0 0
T Omitted Omitted firstcond[0] 1 0 0
E Omitted Omitted NOT firstcond[0] 1 0 0
T T Omitted firstcond[0] firstcond[0] 1 0
E T Omitted NOT firstcond[0] firstcond[0] 1 0
T E Omitted firstcond[0] NOT firstcond[0] 1 0
E E Omitted NOT firstcond[0] NOT firstcond[0] 1 0
T T T firstcond[0] firstcond[0] firstcond[0] 1
E T T NOT firstcond[0] firstcond[0] firstcond[0] 1
T E T firstcond[0] NOT firstcond[0] firstcond[0] 1
E E T NOT firstcond[0] NOT firstcond[0] firstcond[0] 1
T T E firstcond[0] firstcond[0] NOT firstcond[0] 1
E T E NOT firstcond[0] firstcond[0] NOT firstcond[0] 1
T E E firstcond[0] NOT firstcond[0] NOT firstcond[0] 1
E E E NOT firstcond[0] NOT firstcond[0] NOT firstcond[0] 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-392 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.55 LDC, LDC2 (immediate)
Load Coprocessor loads memory data from a sequence of consecutive memory addresses to a coprocessor. If no
coprocessor can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the D bit, the CRd field, and in the Unindexed
addressing mode only, the imm8 field. However, coprocessors CP8-CP15 are reserved for use by ARM, and this
manual defines the valid LDC and LDC2 instructions when coproc is in the range p8-p15. For more information see
Coprocessor support on page A2-94.
In an implementation that includes the Virtualization Extensions, the permitted LDC access to a system control
register can be trapped to Hyp mode, meaning that an attempt to execute an LDC instruction in a Non-secure mode
other than Hyp mode, that would be permitted in the absence of the Hyp trap controls, generates a Hyp Trap
exception. For more information, see Trapping general CP14 accesses to debug registers on page B1-1261.
For more information about these instructions, see General behavior of system control registers on page B3-1446
or General behavior of system control registers on page B5-1776.
Note
For simplicity, the LDC pseudocode does not show this possible trap to Hyp mode.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE LDC (literal);
if P == ‘0’ && U == ‘0’ && D == ‘0’ && W == ‘0’ then UNDEFINED;
if P == ‘0’ && U == ‘0’ && D == ‘1’ && W == ‘0’ then SEE MRRC, MRRC2;
if coproc IN “101x” then SEE “Advanced SIMD and Floating-point”;
n = UInt(Rn); cp = UInt(coproc);
imm32 = ZeroExtend(imm8:’00’, 32); index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if Rn == ‘1111’ then SEE LDC (literal);
if P == ‘0’ && U == ‘0’ && D == ‘0’ && W == ‘0’ then UNDEFINED;
if P == ‘0’ && U == ‘0’ && D == ‘1’ && W == ‘0’ then SEE MRRC, MRRC2;
if coproc IN “101x” then UNDEFINED;
n = UInt(Rn); cp = UInt(coproc);
imm32 = ZeroExtend(imm8:’00’, 32); index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv4*, ARMv5T*, ARMv6*, ARMv7 for encoding A1
LDC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}
LDC{L}<c> <coproc>, <CRd>, [<Rn>], #+/-<imm>
LDC{L}<c> <coproc>, <CRd>, [<Rn>], <option>
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv5T*, ARMv6*, ARMv7 for encoding A2
LDC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}
LDC2{L}<c> <coproc>, <CRd>, [<Rn>], #+/-<imm>
LDC2{L}<c> <coproc>, <CRd>, [<Rn>], <option>
1 1 0 1 1 0 P U D W 1 Rn CRd coproc imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 P U D W 1 Rn CRd coproc imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 P U D W 1 Rn CRd coproc imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 P U D W 1 Rn CRd coproc imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-393
ID051414 Non-Confidential
Assembler syntax
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
L If specified, selects the D == 1 form of the encoding. If omitted, selects the D == 0 form.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM LDC2 instruction must be
unconditional.
<coproc> The name of the coprocessor. The generic coprocessor names are p0-p15.
<CRd> The coprocessor destination register.
<Rn> The base register. The SP can be used. For PC use see LDC, LDC2 (literal) on page A8-394.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE, encoded
as U ==1), or – if it is to be subtracted (add == FALSE, encoded as U==0). #0 and #-0 generate
different instructions.
<imm> The immediate offset used for forming the address. Values are multiples of 4 in the range 0-1020.
For the offset addressing syntax, <imm> can be omitted, meaning an offset of +0.
<option> A coprocessor option. An integer in the range 0-255 enclosed in { }. Encoded in imm8.
The pre-UAL syntax LDC<c>L is equivalent to LDCL<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
repeat
Coproc_SendLoadedWord(MemA[address,4], cp, ThisInstr());
address = address + 4;
until Coproc_DoneLoading(cp, ThisInstr());
if wback then R[n] = offset_addr;
Exceptions
Undefined Instruction, Data Abort, Hyp Trap.
Uses of these instructions by specific coprocessors might generate other exceptions.
Advanced SIMD and Floating-point See Extension register load/store instructions on page A7-274
LDC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #+/-<imm>}] Offset. P = 1, W = 0.
LDC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #+/-<imm>]! Pre-indexed. P = 1, W = 1.
LDC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #+/-<imm> Post-indexed. P = 0, W = 1.
LDC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option> Unindexed. P = 0, W = 0, U = 1.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-394 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.56 LDC, LDC2 (literal)
Load Coprocessor loads memory data from a sequence of consecutive memory addresses to a coprocessor. If no
coprocessor can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the D bit, the CRd field, and in the Unindexed
addressing mode only, the imm8 field. However, coprocessors CP8-CP15 are reserved for use by ARM, and this
manual defines the valid LDC and LDC2 instructions when coproc is in the range p8-p15. For more information see
Coprocessor support on page A2-94 and General behavior of system control registers on page B5-1776.
In an implementation that includes the Virtualization Extensions, the permitted LDC access to a system control
register can be trapped to Hyp mode, meaning that an attempt to execute an LDC instruction in a Non-secure mode
other than Hyp mode, that would be permitted in the absence of the Hyp trap controls, generates a Hyp Trap
exception. For more information, see Trapping general CP14 accesses to debug registers on page B1-1261.
Note
For simplicity, the LDC pseudocode does not show this possible trap to Hyp mode.
For the case when cond is 0b1111, see the T2/A2 encoding.
if P == ‘0’ && U == ‘0’ && D == ‘0’ && W == ‘0’ then UNDEFINED;
if P == ‘0’ && U == ‘0’ && D == ‘1’ && W == ‘0’ then SEE MRRC, MRRC2;
if coproc IN “101x” then SEE “Advanced SIMD and Floating-point”;
index = (P == ‘1’); add = (U == ‘1’); cp = UInt(coproc); imm32 = ZeroExtend(imm8:’00’, 32);
if W == ‘1’ || (P == ‘0’ && CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if P == ‘0’ && U == ‘0’ && D == ‘0’ && W == ‘0’ then UNDEFINED;
if P == ‘0’ && U == ‘0’ && D == ‘1’ && W == ‘0’ then SEE MRRC, MRRC2;
if coproc IN “101x” then UNDEFINED;
index = (P == ‘1’); add = (U == ‘1’); cp = UInt(coproc); imm32 = ZeroExtend(imm8:’00’, 32);
if W == ‘1’ || (P == ‘0’ && CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv4*, ARMv5T*, ARMv6*, ARMv7 for encoding A1
LDC{L}<c> <coproc>, <CRd>, <label>
LDC{L}<c> <coproc>, <CRd>, [PC, #-0] Special case
LDC{L}<c> <coproc>, <CRd>, [PC], <option>
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv5T*, ARMv6*, ARMv7 for encoding A2
LDC2{L}<c> <coproc>, <CRd>, <label>
LDC2{L}<c> <coproc>, <CRd>, [PC, #-0] Special case
LDC2{L}<c> <coproc>, <CRd>, [PC], <option>
Advanced SIMD and Floating-point See Extension register load/store instructions on page A7-274
1 1 0 1 1 0 P U D W 1 1 1 1 1 CRd coproc imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 P U D W 1 1 1 1 1 CRd coproc imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 P U D W 1 1 1 1 1 CRd coproc imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 P U D W 1 1 1 1 1 CRd coproc imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-395
ID051414 Non-Confidential
Assembler syntax
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
L If specified, selects the D == 1 form of the encoding. If omitted, selects the D == 0 form.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM LDC2 instruction must be
unconditional.
<coproc> The name of the coprocessor. The generic coprocessor names are p0-p15.
<CRd> The coprocessor destination register.
<label> The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required
value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of
the offset are multiples of 4 in the range -1020 to 1020.
If the offset is zero or positive, imm32 is equal to the offset and add == TRUE (encoded as U == 1).
If the offset is negative, imm32 is equal to minus the offset and add == FALSE (encoded as U == 0).
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
The unindexed form is permitted for the ARM instruction set only. In it, <option> is a coprocessor option, written
as an integer 0-255 enclosed in { } and encoded in imm8.
The pre-UAL syntax LDC<c>L is equivalent to LDCL<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
NullCheckIfThumbEE(15);
offset_addr = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
address = if index then offset_addr else Align(PC,4);
repeat
Coproc_SendLoadedWord(MemA[address,4], cp, ThisInstr());
address = address + 4;
until Coproc_DoneLoading(cp, ThisInstr());
Exceptions
Undefined Instruction, Data Abort, Hyp Trap.
Uses of these instructions by specific coprocessors might generate other exceptions.
LDC{2}{L}{<c>}{<q>} <coproc>, <CRd>, <label> Normal form with P = 1, W = 0
LDC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [PC, #+/-<imm>] Alternative form with P = 1, W = 0
LDC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [PC], <option> Unindexed form with P = 0, U = 1, W = 0,
TOKENA8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-396 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.57 LDM/LDMIA/LDMFD (Thumb)
Load Multiple Increment After (Load Multiple Full Descending) loads multiple registers from consecutive memory
locations using an address from a base register. The consecutive memory locations start at this address, and the
address just above the highest of those locations can optionally be written back to the base register. The registers
loaded can include the PC, causing a branch to a loaded address. Related system instructions are LDM (User
registers) on page B9-1988 and LDM (exception return) on page B9-1986.
if CurrentInstrSet() == InstrSet_ThumbEE then SEE “ThumbEE instructions”;
n = UInt(Rn); registers = ‘00000000’:register_list; wback = (registers<n> == ‘0’);
if BitCount(registers) < 1 then UNPREDICTABLE;
if W == ‘1’ && Rn == ‘1101’ then SEE POP (Thumb);
n = UInt(Rn); registers = P:M:’0’:register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 2 || (P == ‘1’ && M == ‘1’) then UNPREDICTABLE;
if registers<15> == ‘1’ && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
if wback && registers<n> == ‘1’ then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7 (not in ThumbEE)
LDM<c> <Rn>!, <registers> <Rn> not included in <registers>
LDM<c> <Rn>, <registers> <Rn> included in <registers>
Encoding T2 ARMv6T2, ARMv7
LDM<c>.W <Rn>{!}, <registers>
ThumbEE instructions See 16-bit ThumbEE instructions on page A9-1115.
1 1 0 0 1 Rn register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 0 0 1 0 W 1 Rn P M (0) register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-397
ID051414 Non-Confidential
Assembler syntax
LDM{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. SP can be used. If it is the SP and ! is specified, the instruction is treated as
described in POP (Thumb) on page A8-534.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1. If ! is omitted, the
instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The
lowest-numbered register is loaded from the lowest memory address, through to the
highest-numbered register from the highest memory address. See also Encoding of lists of ARM core
registers on page A8-295.
Encoding T2 does not support a list containing only one register. If an LDMIA instruction with just
one register <Rt> in the list is assembled to Thumb and encoding T1 is not available, it is assembled
to the equivalent LDR{<c>}{<q>} <Rt>, [<Rn>]{, #4} instruction.
The SP cannot be in the list.
The PC can be in the list. If it is, the instruction branches to the address loaded to the PC. In
ARMv5T and above, this is an interworking branch, see Pseudocode details of operations on ARM
core registers on page A2-47. If the PC is in the list:
• the LR must not be in the list
• the instruction must be either outside any IT block, or the last instruction in an IT block.
If ! is specified, <registers> cannot include the base register.
LDMIA and LDMFD are pseudo-instructions for LDM. LDMFD refers to its use for popping data from Full Descending stacks.
The pre-UAL syntaxes LDM<c>IA and LDM<c>FD are equivalent to LDM<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
for i = 0 to 14
if registers<i> == ‘1’ then
R[i] = MemA[address,4]; address = address + 4;
if registers<15> == ‘1’ then
LoadWritePC(MemA[address,4]);
if wback && registers<n> == ‘0’ then R[n] = R[n] + 4*BitCount(registers);
if wback && registers<n> == ‘1’ then R[n] = bits(32) UNKNOWN;
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-398 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.58 LDM/LDMIA/LDMFD (ARM)
Load Multiple Increment After (Load Multiple Full Descending) loads multiple registers from consecutive memory
locations using an address from a base register. The consecutive memory locations start at this address, and the
address just above the highest of those locations can optionally be written back to the base register. The registers
loaded can include the PC, causing a branch to a loaded address. Related system instructions are LDM (User
registers) on page B9-1988 and LDM (exception return) on page B9-1986.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if W == ‘1’ && Rn == ‘1101’ && BitCount(register_list) > 1 then SEE POP (ARM);
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers<n> == ‘1’ && ArchVersion() >= 7 then UNPREDICTABLE;
TOKENLDM<c> <Rn>{!}, <registers>
1 0 0 0 1 0 W 1 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-399
ID051414 Non-Confidential
Assembler syntax
LDM{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. SP can be used. If the SP is used, ! is specified, and there is more than one register
in the <registers> list, the instruction is treated as described in POP (ARM) on page A8-536.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1. If ! is omitted, the
instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The
lowest-numbered register is loaded from the lowest memory address, through to the
highest-numbered register from the highest memory address. See also Encoding of lists of ARM core
registers on page A8-295.
The SP can be in the list. However, ARM deprecates using these instructions with SP in the list.
The PC can be in the list. If it is, the instruction branches to the address loaded to the PC. In
ARMv5T and above, this is an interworking branch, see Pseudocode details of operations on ARM
core registers on page A2-47.
ARM deprecates using these instructions with both the LR and the PC in the list.
Instructions with the base register in the list and ! specified are only available before ARMv7, and
ARM deprecates the use of such instructions. The value of the base register after such an instruction
is UNKNOWN.
LDMIA and LDMFD are pseudo-instructions for LDM. LDMFD refers to its use for popping data from Full Descending stacks.
The pre-UAL syntaxes LDM<c>IA and LDM<c>FD are equivalent to LDM<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
for i = 0 to 14
if registers<i> == ‘1’ then
R[i] = MemA[address,4]; address = address + 4;
if registers<15> == ‘1’ then
LoadWritePC(MemA[address,4]);
if wback && registers<n> == ‘0’ then R[n] = R[n] + 4*BitCount(registers);
if wback && registers<n> == ‘1’ then R[n] = bits(32) UNKNOWN;
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-400 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.59 LDMDA/LDMFA
Load Multiple Decrement After (Load Multiple Full Ascending) loads multiple registers from consecutive memory
locations using an address from a base register. The consecutive memory locations end at this address, and the
address just below the lowest of those locations can optionally be written back to the base register. The registers
loaded can include the PC, causing a branch to a loaded address.
Related system instructions are LDM (User registers) on page B9-1988 and LDM (exception return) on
page B9-1986.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers<n> == ‘1’ && ArchVersion() >= 7 then UNPREDICTABLE;
TOKENLDMDA<c> <Rn>{!}, <registers>
cond 1 0 0 0 0 0 W 1 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-401
ID051414 Non-Confidential
Assembler syntax
LDMDA{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. SP can be used.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The
lowest-numbered register is loaded from the lowest memory address, through to the
highest-numbered register from the highest memory address. See also Encoding of lists of ARM core
registers on page A8-295.
The SP can be in the list. However, instructions that include the SP in the list are deprecated.
The PC can be in the list. If it is, the instruction branches to the address (data) loaded to the PC. In
ARMv5T and above, this branch is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
ARM deprecates including both LR and PC in the list.
Instructions with the base register in the list and ! specified are only available before ARMv7, and
ARM deprecates the use of such instructions. The value of the base register after such an instruction
is UNKNOWN.
LDMFA is a pseudo-instruction for LDMDA, referring to its use for popping data from Full Ascending stacks.
The pre-UAL syntaxes LDM<c>DA and LDM<c>FA are equivalent to LDMDA<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
address = R[n] - 4*BitCount(registers) + 4;
for i = 0 to 14
if registers<i> == ‘1’ then
R[i] = MemA[address,4]; address = address + 4;
if registers<15> == ‘1’ then
LoadWritePC(MemA[address,4]);
if wback && registers<n> == ‘0’ then R[n] = R[n] - 4*BitCount(registers);
if wback && registers<n> == ‘1’ then R[n] = bits(32) UNKNOWN;
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-402 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.60 LDMDB/LDMEA
Load Multiple Decrement Before (Load Multiple Empty Ascending) loads multiple registers from consecutive
memory locations using an address from a base register. The consecutive memory locations end just below this
address, and the address of the lowest of those locations can optionally be written back to the base register. The
registers loaded can include the PC, causing a branch to a loaded address.
Related system instructions are LDM (User registers) on page B9-1988 and LDM (exception return) on
page B9-1986.
n = UInt(Rn); registers = P:M:’0’:register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 2 || (P == ‘1’ && M == ‘1’) then UNPREDICTABLE;
if registers<15> == ‘1’ && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
if wback && registers<n> == ‘1’ then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers<n> == ‘1’ && ArchVersion() >= 7 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDMDB<c> <Rn>{!}, <registers>
TOKENLDMDB<c> <Rn>{!}, <registers>
1 1 0 1 0 0 1 0 0 W 1 Rn P M (0) register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 0 0 1 0 0 W 1 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-403
ID051414 Non-Confidential
Assembler syntax
LDMDB{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. The SP can be used.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The
lowest-numbered register is loaded from the lowest memory address, through to the
highest-numbered register from the highest memory address. See also Encoding of lists of ARM core
registers on page A8-295.
Encoding T1 does not support a list containing only one register. If an LDMDB instruction with just
one register <Rt> in the list is assembled to Thumb, it is assembled to the equivalent LDR{<c>}{<q>}
<Rt>, [<Rn>, #-4]{!} instruction.
The SP can be in the list in ARM instructions, but not in Thumb instructions. However, ARM
instructions that include the SP in the list are deprecated.
The PC can be in the list. If it is, the instruction branches to the address loaded to the PC. In
ARMv5T and above, this is an interworking branch, see Pseudocode details of operations on ARM
core registers on page A2-47. In Thumb instructions, if the PC is in the list:
• the LR must not be in the list
• the instruction must be either outside any IT block, or the last instruction in an IT block.
For the ARM instruction set, ARM deprecates including both LR and PC in the list.
Instructions with the base register in the list and ! specified are only available in the ARM
instruction set before ARMv7, and ARM deprecates the use of such instructions. The value of the
base register after such an instruction is UNKNOWN.
LDMEA is a pseudo-instruction for LDMDB, referring to its use for popping data from Empty Ascending stacks.
The pre-UAL syntaxes LDM<c>DB and LDM<c>EA are equivalent to LDMDB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n] - 4*BitCount(registers);
for i = 0 to 14
if registers<i> == ‘1’ then
R[i] = MemA[address,4]; address = address + 4;
if registers<15> == ‘1’ then
LoadWritePC(MemA[address,4]);
if wback && registers<n> == ‘0’ then R[n] = R[n] - 4*BitCount(registers);
if wback && registers<n> == ‘1’ then R[n] = bits(32) UNKNOWN;
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-404 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.61 LDMIB/LDMED
Load Multiple Increment Before (Load Multiple Empty Descending) loads multiple registers from consecutive
memory locations using an address from a base register. The consecutive memory locations start just above this
address, and the address of the last of those locations can optionally be written back to the base register. The registers
loaded can include the PC, causing a branch to a loaded address.
Related system instructions are LDM (User registers) on page B9-1988 and LDM (exception return) on
page B9-1986.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers<n> == ‘1’ && ArchVersion() >= 7 then UNPREDICTABLE;
TOKENLDMIB<c> <Rn>{!}, <registers>
cond 1 0 0 1 1 0 W 1 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-405
ID051414 Non-Confidential
Assembler syntax
LDMIB{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. The SP can be used.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The
lowest-numbered register is loaded from the lowest memory address, through to the
highest-numbered register from the highest memory address. See also Encoding of lists of ARM core
registers on page A8-295.
The SP can be in the list. However, instructions that include the SP in the list are deprecated.
The PC can be in the list. If it is, the instruction branches to the address (data) loaded to the PC. In
ARMv5T and above, this branch is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
ARM deprecates including both LR and PC in the list.
Instructions with the base register in the list and ! specified are only available before ARMv7, and
ARM deprecates the use of such instructions. The value of the base register after such an instruction
is UNKNOWN.
LDMED is a pseudo-instruction for LDMIB, referring to its use for popping data from Empty Descending stacks.
The pre-UAL syntaxes LDM<c>IB and LDM<c>ED are equivalent to LDMIB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
address = R[n] + 4;
for i = 0 to 14
if registers<i> == ‘1’ then
R[i] = MemA[address,4]; address = address + 4;
if registers<15> == ‘1’ then
LoadWritePC(MemA[address,4]);
if wback && registers<n> == ‘0’ then R[n] = R[n] + 4*BitCount(registers);
if wback && registers<n> == ‘1’ then R[n] = bits(32) UNKNOWN;
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-406 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.62 LDR (immediate, Thumb)
Load Register (immediate) calculates an address from a base register value and an immediate offset, loads a word
from memory, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. For information
about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm5:’00’, 32);
index = TRUE; add = TRUE; wback = FALSE;
t = UInt(Rt); n = 13; imm32 = ZeroExtend(imm8:’00’, 32);
index = TRUE; add = TRUE; wback = FALSE;
if Rn == ‘1111’ then SEE LDR (literal);
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32); index = TRUE; add = TRUE;
wback = FALSE; if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
if Rn == ‘1111’ then SEE LDR (literal);
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE LDRT;
if Rn == ‘1101’ && P == ‘0’ && U == ‘1’ && W == ‘1’ && imm8 == ‘00000100’ then SEE POP;
if P == ‘0’ && W == ‘0’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn);
imm32 = ZeroExtend(imm8, 32); index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if (wback && n == t) || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDR<c> <Rt>, [<Rn>{, #<imm>}]
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDR<c> <Rt>, [SP{, #<imm>}]
Encoding T3 ARMv6T2, ARMv7
LDR<c>.W <Rt>, [<Rn>{, #<imm12>}]
Encoding T4 ARMv6T2, ARMv7
LDR<c> <Rt>, [<Rn>, #-<imm8>]
LDR<c> <Rt>, [<Rn>], #+/-<imm8>
LDR<c> <Rt>, [<Rn>, #+/-<imm8>]!
0 1 1 0 1 imm5 Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 0 0 1 1 Rt imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 1 1 0 1 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 1 0 1 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-407
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register. The SP can be used. The PC can be used, provided the instruction is either
outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches
to the address (data) loaded to the PC. In ARMv5T and above, this branch is an interworking branch,
see Pseudocode details of operations on ARM core registers on page A2-47.
<Rn> The base register. The SP can be used. For PC use see LDR (literal) on page A8-410.
+/- + or omitted The immediate offset is to be added to the base register value (add == TRUE,
encoded as U == 1 in encoding T4).
– The immediate offset is to be subtracted from the base register value.
Encoding T4 must be used, with add == FALSE, encoded as U == 0.
#0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Values are:
Encoding T1 Multiples of 4 in the range 0-124.
Encoding T2 Multiples of 4 in the range 0-1020.
Encoding T3 Any value in the range 0-4095.
Encoding T4 Any value in the range 0-255.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
data = MemU[address,4];
if wback then R[n] = offset_addr;
if t == 15 then
if address<1:0> == ‘00’ then LoadWritePC(data); else UNPREDICTABLE;
elsif UnalignedSupport() || address<1:0> == ‘00’ then
R[t] = data;
else R[t] = bits(32) UNKNOWN; // Can only apply before ARMv7
Exceptions
Data Abort.
ThumbEE instruction
ThumbEE has additional LDR (immediate) encodings, see LDR (immediate) on page A9-1128.
LDR{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDR{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDR{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-408 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.63 LDR (immediate, ARM)
Load Register (immediate) calculates an address from a base register value and an immediate offset, loads a word
from memory, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. For information
about memory accesses see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE LDR (literal);
if P == ‘0’ && W == ‘1’ then SEE LDRT;
if Rn == ‘1101’ && P == ‘0’ && U == ‘1’ && W == ‘0’ && imm12 == ‘000000000100’ then SEE POP;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if wback && n == t then UNPREDICTABLE;
TOKENLDR<c> <Rt>, [<Rn>{, #+/-<imm12>}]
LDR<c> <Rt>, [<Rn>], #+/-<imm12>
LDR<c> <Rt>, [<Rn>, #+/-<imm12>]!
0 1 0 P U 0 W 1 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-409
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register. The SP or the PC can be used. If the PC is used, the instruction branches
to the address (data) loaded to the PC. In ARMv5T and above, this branch is an interworking branch,
see Pseudocode details of operations on ARM core registers on page A2-47.
<Rn> The base register. The SP can be used. For PC use see LDR (literal) on page A8-410.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE, encoded
as U ==1), or – if it is to be subtracted (add == FALSE, encoded as U ==0). #0 and #-0 generate
different instructions.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Any value in the range 0-4095 is permitted.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
data = MemU[address,4];
if wback then R[n] = offset_addr;
if t == 15 then
if address<1:0> == ‘00’ then LoadWritePC(data); else UNPREDICTABLE;
elsif UnalignedSupport() || address<1:0> == ‘00’ then
R[t] = data;
else // Can only apply before ARMv7
R[t] = ROR(data, 8*UInt(address<1:0>));
Exceptions
Data Abort.
LDR{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDR{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDR{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-410 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.64 LDR (literal)
Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory,
and writes it to a register. For information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); imm32 = ZeroExtend(imm8:’00’, 32); add = TRUE;
t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRT;
if P == W then UNPREDICTABLE;
t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDR<c> <Rt>, <label>
Encoding T2 ARMv6T2, ARMv7
LDR<c>.W <Rt>, <label>
LDR<c>.W <Rt>, [PC, #-0] Special case
TOKENLDR<c> <Rt>, <label>
LDR<c> <Rt>, [PC, #-0] Special case
0 1 0 0 1 Rt imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 U 1 0 1 1 1 1 1 Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 P U 0 W 1 1 1 1 1 Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-411
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register. The SP can be used. The PC can be used, provided the instruction is either
outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches
to the address (data) loaded to the PC. In ARMv5T and above, this branch is an interworking branch,
see Pseudocode details of operations on ARM core registers on page A2-47.
<label> The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required
value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of
the offset are:
Encoding T1 Multiples of four in the range 0 to 1020.
Encoding T2 or A1 Any value in the range -4095 to 4095.
If the offset is zero or positive, imm32 is equal to the offset and add == TRUE, encoded as U == 1 in
encoding T2.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE, encoded as U == 0.
Negative offset is not available in encoding T1.
Note
In examples in this manual, the syntax =<value> is used for the label of a memory word whose
contents are constant and equal to <value>. The actual syntax for such a label is
assembler-dependent.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(15);
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
data = MemU[address,4];
if t == 15 then
if address<1:0> == ‘00’ then LoadWritePC(data); else UNPREDICTABLE;
elsif UnalignedSupport() || address<1:0> == ‘00’ then
R[t] = data;
else // Can only apply before ARMv7
if CurrentInstrSet() == InstrSet_ARM then
R[t] = ROR(data, 8*UInt(address<1:0>));
else
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDR{<c>}{<q>} <Rt>, <label> Normal form
LDR{<c>}{<q>} <Rt>, [PC, #+/-<imm>] Alternative form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-412 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.65 LDR (register, Thumb)
Load Register (register) calculates an address from a base register value and an offset register value, loads a word
from memory, and writes it to a register. The offset register value can optionally be shifted. For information about
memory accesses, see Memory accesses on page A8-294.
The Thumb form of LDR (register) does not support register writeback.
if CurrentInstrSet() == InstrSet_ThumbEE then SEE “Modified operation in ThumbEE”;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);
if Rn == ‘1111’ then SEE LDR (literal);
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m IN {13,15} then UNPREDICTABLE;
if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDR<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
LDR<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
Modified operation in ThumbEE See LDR (register) on page A9-1118
0 1 0 1 1 0 0 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 1 0 1 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-413
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register. The SP can be used. The PC can be used, provided the instruction is either
outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches
to the address (data) loaded to the PC. In ARMv5T and above, this branch is an interworking branch,
see Pseudocode details of operations on ARM core registers on page A2-47.
<Rn> The base register. The SP can be used. In the Thumb instruction set, the PC cannot be used with this
form of the LDR instruction.
+ In Thumb instructions, the optionally shifted value of <Rm> is added to the base register value.
Thumb instructions cannot subtract <Rm> from the base register value.
<Rm> The offset that is optionally shifted and applied to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. For encoding T2, <shift> can only be omitted,
encoded as imm2 = 0b00, or LSL #<imm> with <imm> = 1, 2, or 3, and <imm> encoded in imm2.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = (R[n] + offset);
address = offset_addr;
data = MemU[address,4];
if t == 15 then
if address<1:0> == ‘00’ then
LoadWritePC(data);
else
UNPREDICTABLE;
elsif UnalignedSupport() || address<1:0> == ‘00’ then
R[t] = data;
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, <shift>}] Offset addressing
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-414 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.66 LDR (register, ARM)
Load Register (register) calculates an address from a base register value and an offset register value, loads a word
from memory, and writes it to a register. The offset register value can optionally be shifted. For information about
memory accesses, see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
if m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
TOKENLDR<c> <Rt>, [<Rn>,+/-<Rm>{, <shift>}]{!}
LDR<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
cond 0 1 1 P U 0 W 1 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-415
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register. The SP can be used. The PC can be used. If the PC is used, the instruction
branches to the address (data) loaded to the PC. In ARMv5T and above, this branch is an
interworking branch, see Pseudocode details of operations on ARM core registers on page A2-47.
<Rn> The base register. The SP can be used. The PC can be used for offset addressing only.
+/- If + or omitted, the optionally shifted value of <Rm> is added to the base register value (add == TRUE
encoded as U == 1).
If –, the optionally shifted value of <Rm> is subtracted from the base register value (add == FALSE
encoded as U == 0).
<Rm> The offset that is optionally shifted and applied to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts
applied to a register on page A8-291.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
data = MemU[address,4];
if wback then R[n] = offset_addr;
if t == 15 then
if address<1:0> == ‘00’ then
LoadWritePC(data);
else
UNPREDICTABLE;
elsif UnalignedSupport() || address<1:0> == ‘00’ then
R[t] = data;
else // Can only apply before ARMv7
R[t] = ROR(data, 8*UInt(address<1:0>));
Exceptions
Data Abort.
LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}] Offset: index==TRUE, wback==FALSE
LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]! Pre-indexed: index==TRUE, wback==TRUE
LDR{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>} Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-416 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.67 LDRB (immediate, Thumb)
Load Register Byte (immediate) calculates an address from a base register value and an immediate offset, loads a
byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed,
or pre-indexed addressing. For information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm5, 32);
index = TRUE; add = TRUE; wback = FALSE;
if Rt == ‘1111’ then SEE PLD;
if Rn == ‘1111’ then SEE LDRB (literal);
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = TRUE; add = TRUE; wback = FALSE;
if t == 13 then UNPREDICTABLE;
if Rt == ‘1111’ && P == ‘1’ && U == ‘0’ && W == ‘0’ then SEE PLD, PLDW (immediate);
if Rn == ‘1111’ then SEE LDRB (literal);
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE LDRBT;
if P == ‘0’ && W == ‘0’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if t == 13 || (t == 15 && W == ‘1’) || (wback && n == t) then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDRB<c> <Rt>, [<Rn>{, #<imm5>}]
Encoding T2 ARMv6T2, ARMv7
LDRB<c>.W <Rt>, [<Rn>{, #<imm12>}]
Encoding T3 ARMv6T2, ARMv7
LDRB<c> <Rt>, [<Rn>, #-<imm8>]
LDRB<c> <Rt>, [<Rn>], #+/-<imm8>
LDRB<c> <Rt>, [<Rn>, #+/-<imm8>]!
0 1 1 1 1 imm5 Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 1 0 0 1 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 0 1 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-417
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. For PC use see LDRB (literal) on page A8-420.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE, encoded
as U == 1), or – if it is to be subtracted (add == FALSE, encoded as U == 0). #0 and #-0 generate
different instructions.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Values are:
Encoding T1 any value in the range 0-31
Encoding T2 any value in the range 0-4095
Encoding T3 any value in the range 0-255.
The pre-UAL syntax LDR<c>B is equivalent to LDRB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
R[t] = ZeroExtend(MemU[address,1], 32);
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
LDRB{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDRB{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRB{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-418 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.68 LDRB (immediate, ARM)
Load Register Byte (immediate) calculates an address from a base register value and an immediate offset, loads a
byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed,
or pre-indexed addressing. For information about memory accesses see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE LDRB (literal);
if P == ‘0’ && W == ‘1’ then SEE LDRBT;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if t == 15 || (wback && n == t) then UNPREDICTABLE;
TOKENLDRB<c> <Rt>, [<Rn>{, #+/-<imm12>}]
LDRB<c> <Rt>, [<Rn>], #+/-<imm12>
LDRB<c> <Rt>, [<Rn>, #+/-<imm12>]!
0 1 0 P U 1 W 1 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-419
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. For PC use see LDRB (literal) on page A8-420.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE, encoded
as U == 1), or – if it is to be subtracted (add == FALSE, encoded as U == 0). #0 and #-0 generate
different instructions.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Any value in the range 0-4095 is permitted.
The pre-UAL syntax LDR<c>B is equivalent to LDRB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
R[t] = ZeroExtend(MemU[address,1], 32);
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
LDRB{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDRB{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRB{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-420 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.69 LDRB (literal)
Load Register Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte from
memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses
see Memory accesses on page A8-294.
if Rt == ‘1111’ then SEE PLD;
t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
if t == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRBT;
if P == W then UNPREDICTABLE;
t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
if t == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRB<c> <Rt>, <label>
LDRB<c> <Rt>, [PC, #-0] Special case
TOKENLDRB<c> <Rt>, <label>
LDRB<c> <Rt>, [PC, #-0] Special case
1 1 1 1 0 0 0 U 0 0 1 1 1 1 1 Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 P U 1 W 1 1 1 1 1 Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-421
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<label> The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required
value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of
the offset are -4095 to 4095.
If the offset is zero or positive, imm32 is equal to the offset and add == TRUE, encoded as U == 1.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE, encoded as U == 0.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
The pre-UAL syntax LDR<c>B is equivalent to LDRB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(15);
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
R[t] = ZeroExtend(MemU[address,1], 32);
Exceptions
Data Abort.
LDRB{<c>}{<q>} <Rt>, <label> Normal form
LDRB{<c>}{<q>} <Rt>, [PC, #+/-<imm>] Alternative form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-422 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.70 LDRB (register)
Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a
byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value can
optionally be shifted. For information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rt == ‘1111’ then SEE PLD;
if Rn == ‘1111’ then SEE LDRB (literal);
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRBT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDRB<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
LDRB<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENLDRB<c> <Rt>, [<Rn>,+/-<Rm>{, <shift>}]{!}
LDRB<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
0 1 0 1 1 1 0 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 0 1 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 P U 1 W 1 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-423
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. In the ARM instruction set the PC can be used, for the offset
addressing form of the instruction only. In the Thumb instruction set, the PC cannot be used with
any of these forms of the LDRB instruction.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE, encoded as U == 1 in encoding A1), or – if it is to be subtracted (permitted in ARM
instructions only, add == FALSE, encoded as U == 0).
<Rm> Contains the offset that is optionally shifted and applied to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. For encoding T2, <shift> can only be omitted,
encoded as imm2 = 0b00, or LSL #<imm> with <imm> = 1, 2, or 3, and <imm> encoded in imm2. For
TOKENThe pre-UAL syntax LDR<c>B is equivalent to LDRB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
R[t] = ZeroExtend(MemU[address,1],32);
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
LDRB{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>{, <shift>}] Offset: index==TRUE, wback==FALSE
LDRB{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>{, <shift>}]! Pre-indexed: index==TRUE, wback==TRUE
LDRB{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm>{, <shift>} Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-424 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.71 LDRBT
Load Register Byte Unprivileged loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to
a register. For information about memory accesses see Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
LDRBT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or an optionally-shifted register value.
if Rn == ‘1111’ then SEE LDRB (literal);
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm12, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;
if ArchVersion() < 6 && m == n then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRBT<c> <Rt>, [<Rn>, #<imm8>]
TOKENLDRBT<c> <Rt>, [<Rn>], #+/-<imm12>
Encoding A2 ARMv4*, ARMv5T*, ARMv6*, ARMv7
LDRBT<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
1 1 1 1 0 0 0 0 0 0 1 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 0 U 1 1 1 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 U 1 1 1 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-425
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE, encoded as U == 1 in encodings A1 and A2), or – if it is to be subtracted (permitted
in ARM instructions only, add == FALSE, encoded as U == 0).
<imm> The immediate offset applied to the value of <Rn>. Values are 0-255 for encoding T1, and 0-4095 for
TOKEN<Rm> Contains the offset that is optionally shifted and applied to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
The pre-UAL syntax LDR<c>BT is equivalent to LDRBT<c>.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then Shift(R[m], shift_t, shift_n, APSR.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
R[t] = ZeroExtend(MemU_unpriv[address,1],32);
if postindex then R[n] = offset_addr;
Exceptions
Data Abort.
LDRBT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
LDRBT{<c>}{<q>} <Rt>, [<Rn>] {, #+/-<imm>} Post-indexed: ARM only
LDRBT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> {, <shift>} Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-426 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.72 LDRD (immediate)
Load Register Dual (immediate) calculates an address from a base register value and an immediate offset, loads two
words from memory, and writes them to two registers. It can use offset, post-indexed, or pre-indexed addressing.
For information about memory accesses see Memory accesses on page A8-294.
if P == ‘0’ && W == ‘0’ then SEE “Related encodings”;
if Rn == ‘1111’ then SEE LDRD (literal);
t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn); imm32 = ZeroExtend(imm8:’00’, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if wback && (n == t || n == t2) then UNPREDICTABLE;
if t IN {13,15} || t2 IN {13,15} || t == t2 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE LDRD (literal);
if Rt<0> == ‘1’ then UNPREDICTABLE;
t = UInt(Rt); t2 = t+1; n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if P == ‘0’ && W == ‘1’ then UNPREDICTABLE;
if wback && (n == t || n == t2) then UNPREDICTABLE;
if t2 == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRD<c> <Rt>, <Rt2>, [<Rn>{, #+/-<imm>}]
LDRD<c> <Rt>, <Rt2>, [<Rn>], #+/-<imm>
LDRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]!
TOKENLDRD<c> <Rt>, <Rt2>, [<Rn>{, #+/-<imm8>}]
LDRD<c> <Rt>, <Rt2>, [<Rn>], #+/-<imm8>
LDRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm8>]!
Related encodings See Load/store dual, load/store exclusive, table branch on page A6-238.
1 1 0 1 0 0 P U 1 W 1 Rn Rt Rt2 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 1 W 0 Rn Rt imm4H 1 1 0 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-427
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The first destination register. For an ARM instruction, <Rt> must be even-numbered and not R14.
<Rt2> The second destination register. For an ARM instruction, <Rt2> must be <R(t+1)>.
<Rn> The base register. The SP can be used. For PC use see LDRD (literal) on page A8-428.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE, encoded
as U == 1), or – if it is to be subtracted (add == FALSE, encoded as U == 0). #0 and #-0 generate
different instructions.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Values are:
Encoding T1 Multiples of 4 in the range 0-1020.
TOKENThe pre-UAL syntax LDR<c>D is equivalent to LDRD<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
if HaveLPAE() && address<2:0> == ‘000’ then
data = MemA[address,8];
if BigEndian() then
R[t] = data<63:32>;
R[t2] = data<31:0>;
else
R[t] = data<31:0>;
R[t2] = data<63:32>;
else
R[t] = MemA[address,4];
R[t2] = MemA[address+4,4];
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-428 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.73 LDRD (literal)
Load Register Dual (literal) calculates an address from the PC value and an immediate offset, loads two words from
memory, and writes them to two registers. For information about memory accesses see Memory accesses on
page A8-294.
if P == ‘0’ && W == ‘0’ then SEE “Related encodings”;
t = UInt(Rt); t2 = UInt(Rt2);
imm32 = ZeroExtend(imm8:’00’, 32); add = (U == ‘1’);
if t IN {13,15} || t2 IN {13,15} || t == t2 then UNPREDICTABLE;
if W == ‘1’ then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rt<0> == ‘1’ then UNPREDICTABLE;
t = UInt(Rt); t2 = t+1; imm32 = ZeroExtend(imm4H:imm4L, 32); add = (U == ‘1’);
if t2 == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRD<c> <Rt>, <Rt2>, <label>
LDRD<c> <Rt>, <Rt2>, [PC, #-0] Special case
TOKENLDRD<c> <Rt>, <Rt2>, <label>
LDRD<c> <Rt>, <Rt2>, [PC, #-0] Special case
Related encodings See Load/store dual, load/store exclusive, table branch on page A6-238.
1 1 0 1 0 0 P U 1 W 1 1 1 1 1 Rt Rt2 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 (1) U 1 (0) 0 1 1 1 1 Rt imm4H 1 1 0 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-429
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The first destination register. For an ARM instruction, <Rt> must be even-numbered and not R14.
<Rt2> The second destination register. For an ARM instruction, <Rt2> must be <R(t+1)>.
<label> The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required
value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of
the offset are:
Encoding T1 Multiples of 4 in the range -1020 to 1020.
TOKENIf the offset is zero or positive, imm32 is equal to the offset and add == TRUE, encoded as U == 1.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE, encoded as U == 0.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
The pre-UAL syntax LDR<c>D is equivalent to LDRD<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(15);
address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
if HaveLPAE() && address<2:0> == ‘000’ then
data = MemA[address,8];
if BigEndian() then
R[t] = data<63:32>;
R[t2] = data<31:0>;
else
R[t] = data<31:0>;
R[t2] = data<63:32>;
else
R[t] = MemA[address,4];
R[t2] = MemA[address+4,4];
Exceptions
Data Abort.
LDRD{<c>}{<q>} <Rt>, <Rt2>, <label> Normal form
LDRD{<c>}{<q>} <Rt>, <Rt2>, [PC, #+/-<imm>] Alternative form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-430 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.74 LDRD (register)
Load Register Dual (register) calculates an address from a base register value and a register offset, loads two words
from memory, and writes them to two registers. It can use offset, post-indexed, or pre-indexed addressing. For
information about memory accesses see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rt<0> == ‘1’ then UNPREDICTABLE;
t = UInt(Rt); t2 = t+1; n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if P == ‘0’ && W == ‘1’ then UNPREDICTABLE;
if t2 == 15 || m == 15 || m == t || m == t2 then UNPREDICTABLE;
if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
TOKENLDRD<c> <Rt>, <Rt2>, [<Rn>,+/-<Rm>]{!}
LDRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm>
cond 0 0 0 P U 0 W 0 Rn Rt (0) (0) (0) (0) 1 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-431
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The first destination register. This register must be even-numbered and not R14.
<Rt2> The second destination register. This register must be <R(t+1)>.
<Rn> The base register. The SP can be used. The PC can be used, for offset addressing only.
+/- Is + or omitted if the value of <Rm> is to be added to the base register value (add == TRUE, encoded as
U == 1), or – if it is to be subtracted (add == FALSE, encoded as U == 0).
<Rm> Contains the offset that is applied to the value of <Rn> to form the address.
The pre-UAL syntax LDR<c>D is equivalent to LDRD<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
address = if index then offset_addr else R[n];
if HaveLPAE() && address<2:0> == ‘000’ then
data = MemA[address,8];
if BigEndian() then
R[t] = data<63:32>;
R[t2] = data<31:0>;
else
R[t] = data<31:0>;
R[t2] = data<63:32>;
else
R[t] = MemA[address,4];
R[t2] = MemA[address+4,4];
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, +/-<Rm>] Offset: index==TRUE, wback==FALSE
LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, +/-<Rm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], +/-<Rm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-432 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.75 LDREX
Load Register Exclusive calculates an address from a base register value and an immediate offset, loads a word from
memory, writes it to a register and:
• if the address has the Shared Memory attribute, marks the physical address as exclusive access for the
executing processor in a global monitor
• causes the executing processor to indicate an active exclusive access in the local monitor.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8:’00’, 32);
if t IN {13,15} || n == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); imm32 = Zeros(32); // Zero offset
if t == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDREX<c> <Rt>, [<Rn>{, #<imm>}]
TOKENLDREX<c> <Rt>, [<Rn>]
1 1 0 1 0 0 0 0 1 0 1 Rn Rt (1) (1) (1) (1) imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 0 1 Rn Rt (1) (1) (1) (1) 1 0 0 1 (1) (1) (1) (1)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-433
ID051414 Non-Confidential
Assembler syntax
LDREX{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
<imm> The immediate offset added to the value of <Rn> to form the address. <imm> can be omitted, meaning
an offset of 0. Values are:
Encoding T1 multiples of 4 in the range 0-1020
TOKENOperation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n] + imm32;
SetExclusiveMonitors(address,4);
R[t] = MemA[address,4];
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-434 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.76 LDREXB
Load Register Exclusive Byte derives an address from a base register value, loads a byte from memory, zero-extends
it to form a 32-bit word, writes it to a register and:
• if the address has the Shared Memory attribute, marks the physical address as exclusive access for the
executing processor in a global monitor
• causes the executing processor to indicate an active exclusive access in the local monitor.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn);
if t IN {13,15} || n == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv7
LDREXB<c> <Rt>, [<Rn>]
TOKENLDREXB<c> <Rt>, [<Rn>]
1 1 0 1 0 0 0 1 1 0 1 Rn Rt (1) (1) (1) (1) 0 1 0 0 (1) (1) (1) (1)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 1 0 1 Rn Rt (1) (1) (1) (1) 1 0 0 1 (1) (1) (1) (1)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-435
ID051414 Non-Confidential
Assembler syntax
LDREXB{<c>}{<q>} <Rt>, [<Rn>]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
SetExclusiveMonitors(address,1);
R[t] = ZeroExtend(MemA[address,1], 32);
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-436 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.77 LDREXD
Load Register Exclusive Doubleword derives an address from a base register value, loads a 64-bit doubleword from
memory, writes it to two registers and:
• if the address has the Shared Memory attribute, marks the physical address as exclusive access for the
executing processor in a global monitor
• causes the executing processor to indicate an active exclusive access in the local monitor.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn);
if t IN {13,15} || t2 IN {13,15} || t == t2 || n == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); t2 = t+1; n = UInt(Rn);
if Rt<0> == ‘1’ || Rt == ‘1110’ || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv7
LDREXD<c> <Rt>, <Rt2>, [<Rn>]
TOKENLDREXD<c> <Rt>, <Rt2>, [<Rn>]
1 1 0 1 0 0 0 1 1 0 1 Rn Rt Rt2 0 1 1 1 (1) (1) (1) (1)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 1 Rn Rt (1) (1) (1) (1) 1 0 0 1 (1) (1) (1) (1)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-437
ID051414 Non-Confidential
Assembler syntax
LDREXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The first destination register. For an ARM instruction, <Rt> must be even-numbered and not R14.
<Rt2> The second destination register. For an ARM instruction, <Rt2> must be <R(t+1)>.
<Rn> The base register. The SP can be used.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
// LDREXD requires doubleword-aligned address
if address<2:0> != ‘000’ then AlignmentFault(address, FALSE)
SetExclusiveMonitors(address,8);
// See the description of Single-copy atomicity for details of whether
// the two loads are 64-bit single-copy atomic.
R[t] = MemA[address,4];
R[t2] = MemA[address+4,4];
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-438 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.78 LDREXH
Load Register Exclusive Halfword derives an address from a base register value, loads a halfword from memory,
zero-extends it to form a 32-bit word, writes it to a register and:
• if the address has the Shared Memory attribute, marks the physical address as exclusive access for the
executing processor in a global monitor
• causes the executing processor to indicate an active exclusive access in the local monitor.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn);
if t IN {13,15} || n == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv7
LDREXH<c> <Rt>, [<Rn>]
TOKENLDREXH<c> <Rt>, [<Rn>]
1 1 0 1 0 0 0 1 1 0 1 Rn Rt (1) (1) (1) (1) 0 1 0 1 (1) (1) (1) (1)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 1 1 1 Rn Rt (1) (1) (1) (1) 1 0 0 1 (1) (1) (1) (1)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-439
ID051414 Non-Confidential
Assembler syntax
LDREXH{<c>}{<q>} <Rt>, [<Rn>]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
SetExclusiveMonitors(address,2);
R[t] = ZeroExtend(MemA[address,2], 32);
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-440 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.79 LDRH (immediate, Thumb)
Load Register Halfword (immediate) calculates an address from a base register value and an immediate offset, loads
a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset,
post-indexed, or pre-indexed addressing. For information about memory accesses see Memory accesses on
page A8-294.
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm5:’0’, 32);
index = TRUE; add = TRUE; wback = FALSE;
if Rt == ‘1111’ then SEE PLD (immediate);
if Rn == ‘1111’ then SEE LDRH (literal);
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = TRUE; add = TRUE; wback = FALSE;
if t == 13 then UNPREDICTABLE;
if Rn == ‘1111’ then SEE LDRH (literal);
if Rt == ‘1111’ && P == ‘1’ && U == ‘0’ && W == ‘0’ then SEE PLD, PLDW (immediate);
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE LDRHT;
if P == ‘0’ && W == ‘0’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if t == 13 || (t == 15 && W == ‘1’) || (wback && n == t) then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDRH<c> <Rt>, [<Rn>{, #<imm>}]
Encoding T2 ARMv6T2, ARMv7
LDRH<c>.W <Rt>, [<Rn>{, #<imm12>}]
Encoding T3 ARMv6T2, ARMv7
LDRH<c> <Rt>, [<Rn>, #-<imm8>]
LDRH<c> <Rt>, [<Rn>], #+/-<imm8>
LDRH<c> <Rt>, [<Rn>, #+/-<imm8>]!
1 0 0 0 1 imm5 Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 1 0 1 1 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 1 1 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-441
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. For PC use see LDRH (literal) on page A8-444.
+/- Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE),
or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated
for #0 and #-0.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Values are:
Encoding T1 multiples of 2 in the range 0-62
Encoding T2 any value in the range 0-4095
Encoding T3 any value in the range 0-255.
The pre-UAL syntax LDR<c>H is equivalent to LDRH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = ZeroExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRH{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDRH{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRH{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-442 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.80 LDRH (immediate, ARM)
Load Register Halfword (immediate) calculates an address from a base register value and an immediate offset, loads
a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset,
post-indexed, or pre-indexed addressing. For information about memory accesses see Memory accesses on
page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE LDRH (literal);
if P == ‘0’ && W == ‘1’ then SEE LDRHT;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if t == 15 || (wback && n == t) then UNPREDICTABLE;
TOKENLDRH<c> <Rt>, [<Rn>{, #+/-<imm8>}]
LDRH<c> <Rt>, [<Rn>], #+/-<imm8>
LDRH<c> <Rt>, [<Rn>, #+/-<imm8>]!
0 0 0 P U 1 W 1 Rn Rt imm4H 1 0 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-443
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. For PC use see LDRH (literal) on page A8-444.
+/- Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE),
or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated
for #0 and #-0.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Any value in the range 0-255 is permitted.
The pre-UAL syntax LDR<c>H is equivalent to LDRH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = ZeroExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRH{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDRH{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRH{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-444 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.81 LDRH (literal)
Load Register Halfword (literal) calculates an address from the PC value and an immediate offset, loads a halfword
from memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory
accesses see Memory accesses on page A8-294.
if Rt == ‘1111’ then SEE PLD (literal);
t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
if t == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDHRT;
if P == W then UNPREDICTABLE;
t = UInt(Rt); imm32 = ZeroExtend(imm4H:imm4L, 32); add = (U == ‘1’);
if t == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRH<c> <Rt>, <label>
LDRH<c> <Rt>, [PC, #-0] Special case
TOKENLDRH<c> <Rt>, <label>
LDRH<c> <Rt>, [PC, #-0] Special case
1 1 1 1 0 0 0 U 0 1 1 1 1 1 1 Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 U 1 1 1 1 1 1 Rt imm4H 1 0 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
P W
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-445
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<label> The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required
value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of
the offset are:
Encoding T1 any value in the range -4095 to 4095
TOKENIf the offset is zero or positive, imm32 is equal to the offset and add == TRUE.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
The pre-UAL syntax LDR<c>H is equivalent to LDRH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(15);
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
data = MemU[address,2];
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = ZeroExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRH{<c>}{<q>} <Rt>, <label> Normal form
LDRH{<c>}{<q>} <Rt>, [PC, #+/-<imm>] Alternative form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-446 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.82 LDRH (register)
Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads
a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value
can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see Memory accesses on
page A8-294.
if CurrentInstrSet() == InstrSet_ThumbEE then SEE “Modified operation in ThumbEE”;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rn == ‘1111’ then SEE LDRH (literal);
if Rt == ‘1111’ then SEE PLDW (register);
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRHT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDRH<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
LDRH<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENLDRH<c> <Rt>, [<Rn>,+/-<Rm>]{!}
LDRH<c> <Rt>, [<Rn>],+/-<Rm>
Modified operation in ThumbEE See LDRH (register) on page A9-1119
0 1 0 1 1 0 1 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 1 1 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 0 W 1 Rn Rt (0) (0) (0) (0) 1 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-447
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. In the ARM instruction set the PC can be used, for offset
addressing forms of the instruction only. In the Thumb instruction set, the PC cannot be used for any
of these forms of the LDRH instruction.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally left shifted and added to the value of <Rn> to form the address.
<imm> If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. Only encoding
T2 is permitted, and <imm> is encoded in imm2.
If absent, no shift is specified and all encodings are permitted. In encoding T2, imm2 is encoded as
0b00.
The pre-UAL syntax LDR<c>H is equivalent to LDRH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = ZeroExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRH{<c>}{<q>} <Rt>, [<Rn>, <Rm>{, LSL #<imm>}] Offset: index==TRUE, wback==FALSE
LDRH{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>] Offset: index==TRUE, wback==FALSE
LDRH{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRH{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-448 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.83 LDRHT
Load Register Halfword Unprivileged loads a halfword from memory, zero-extends it to form a 32-bit word, and
writes it to a register. For information about memory accesses see Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
LDRHT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or a register value.
if Rn == ‘1111’ then SEE LDRH (literal);
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRHT<c> <Rt>, [<Rn>, #<imm8>]
TOKENLDRHT<c> <Rt>, [<Rn>] {, #+/-<imm8>}
Encoding A2 ARMv6T2, ARMv7
LDRHT<c> <Rt>, [<Rn>], +/-<Rm>
1 1 1 1 0 0 0 0 0 1 1 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 1 1 1 Rn Rt imm4H 1 0 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 0 1 1 Rn Rt (0) (0) (0) (0) 1 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-449
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register
value.Encoded as add = TRUE.
Is – if <imm> or the optionally shifted value of <Rm> is to be subtracted from the base register value.
This is permitted in ARM instructions only, and is encoded as add = FALSE.
<imm> The immediate offset applied to the value of <Rn>. Any value in the range 0-255 is permitted. <imm>
can be omitted, meaning an offset of 0.
<Rm> Contains the offset that is applied to the value of <Rn> to form the address.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
data = MemU_unpriv[address,2];
if postindex then R[n] = offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = ZeroExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRHT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
LDRHT{<c>}{<q>} <Rt>, [<Rn>] {, #+/-<imm>} Post-indexed: ARM only
LDRHT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-450 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.84 LDRSB (immediate)
Load Register Signed Byte (immediate) calculates an address from a base register value and an immediate offset,
loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use offset,
post-indexed, or pre-indexed addressing. For information about memory accesses see Memory accesses on
page A8-294.
if Rt == ‘1111’ then SEE PLI;
if Rn == ‘1111’ then SEE LDRSB (literal);
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = TRUE; add = TRUE; wback = FALSE;
if t == 13 then UNPREDICTABLE;
if Rt == ‘1111’ && P == ‘1’ && U == ‘0’ && W == ‘0’ then SEE PLI;
if Rn == ‘1111’ then SEE LDRSB (literal);
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE LDRSBT;
if P == ‘0’ && W == ‘0’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if t == 13 || (t == 15 && W == ‘1’) || (wback && n == t) then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE LDRSB (literal);
if P == ‘0’ && W == ‘1’ then SEE LDRSBT;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if t == 15 || (wback && n == t) then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRSB<c> <Rt>, [<Rn>, #<imm12>]
Encoding T2 ARMv6T2, ARMv7
LDRSB<c> <Rt>, [<Rn>, #-<imm8>]
LDRSB<c> <Rt>, [<Rn>], #+/-<imm8>
LDRSB<c> <Rt>, [<Rn>, #+/-<imm8>]!
TOKENLDRSB<c> <Rt>, [<Rn>{, #+/-<imm8>}]
LDRSB<c> <Rt>, [<Rn>], #+/-<imm8>
LDRSB<c> <Rt>, [<Rn>, #+/-<imm8>]!
1 1 1 1 0 0 1 1 0 0 1 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 0 0 1 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 0 0 P U 1 W 1 Rn Rt imm4H 1 1 0 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-451
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. For PC use see LDRSB (literal) on page A8-452.
+/- Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE),
or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated
for #0 and #-0.
<imm> The immediate offset used for forming the address. For the offset addressing syntax, <imm> can be
omitted, meaning an offset of 0. Values are:
Encoding T1 any value in the range 0-4095
Encoding T2 or A1 any value in the range0-255.
The pre-UAL syntax LDR<c>SB is equivalent to LDRSB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
R[t] = SignExtend(MemU[address,1], 32);
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDRSB{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRSB{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-452 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.85 LDRSB (literal)
Load Register Signed Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte
from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about memory
accesses see Memory accesses on page A8-294.
if Rt == ‘1111’ then SEE PLI;
t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
if t == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRSBT;
if P == W then UNPREDICTABLE;
t = UInt(Rt); imm32 = ZeroExtend(imm4H:imm4L, 32); add = (U == ‘1’);
if t == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRSB<c> <Rt>, <label>
LDRSB<c> <Rt>, [PC, #-0] Special case
TOKENLDRSB<c> <Rt>, <label>
LDRSB<c> <Rt>, [PC, #-0] Special case
1 1 1 1 0 0 1 U 0 0 1 1 1 1 1 Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 1 W 1 1 1 1 1 Rt imm4H 1 1 0 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-453
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<label> The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required
value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of
the offset are:
Encoding T1 any value in the range -4095 to 4095
TOKENIf the offset is zero or positive, imm32 is equal to the offset and add == TRUE.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
The pre-UAL syntax LDR<c>SB is equivalent to LDRSB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(15);
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
R[t] = SignExtend(MemU[address,1], 32);
Exceptions
Data Abort.
LDRSB{<c>}{<q>} <Rt>, <label> Normal form
LDRSB{<c>}{<q>} <Rt>, [PC, #+/-<imm>] Alternative form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-454 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.86 LDRSB (register)
Load Register Signed Byte (register) calculates an address from a base register value and an offset register value,
loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset register value
can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see Memory accesses on
page A8-294.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rt == ‘1111’ then SEE PLI;
if Rn == ‘1111’ then SEE LDRSB (literal);
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRSBT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDRSB<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
LDRSB<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENLDRSB<c> <Rt>, [<Rn>,+/-<Rm>]{!}
LDRSB<c> <Rt>, [<Rn>],+/-<Rm>
0 1 0 1 0 1 1 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 0 0 1 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 0 W 1 Rn Rt (0) (0) (0) (0) 1 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-455
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. In the ARM instruction set the PC can be used, for the offset
addressing forms of the instruction only. In the Thumb instruction set, the PC cannot be used for any
of these forms of the LDRSB instruction.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally left shifted and added to the value of <Rn> to form the address.
<imm> If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. Only encoding
T2 is permitted, and <imm> is encoded in imm2.
If absent, no shift is specified and all encodings are permitted. In encoding T2, imm2 is encoded as
0b00.
The pre-UAL syntax LDR<c>SB is equivalent to LDRSB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
R[t] = SignExtend(MemU[address,1], 32);
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
LDRSB{<c>}{<q>} <Rt>, [<Rn>, <Rm>{, LSL #<imm>}] Offset: index==TRUE, wback==FALSE
LDRSB{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>] Offset: index==TRUE, wback==FALSE
LDRSB{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRSB{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-456 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.87 LDRSBT
Load Register Signed Byte Unprivileged loads a byte from memory, sign-extends it to form a 32-bit word, and
writes it to a register. For information about memory accesses see Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
LDRSBT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or a register value.
if Rn == ‘1111’ then SEE LDRSB (literal);
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRSBT<c> <Rt>, [<Rn>, #<imm8>]
TOKENLDRSBT<c> <Rt>, [<Rn>] {, #+/-<imm8>}
Encoding A2 ARMv6T2, ARMv7
LDRSBT<c> <Rt>, [<Rn>], +/-<Rm>
1 1 1 1 0 0 1 0 0 0 1 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 1 1 1 Rn Rt imm4H 1 1 0 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 0 1 1 Rn Rt (0) (0) (0) (0) 1 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-457
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<imm> The immediate offset applied to the value of <Rn>. Any value in the range 0-255 is permitted. <imm>
can be omitted, meaning an offset of 0.
<Rm> Contains the offset that is applied to the value of <Rn> to form the address.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
R[t] = SignExtend(MemU_unpriv[address,1], 32);
if postindex then R[n] = offset_addr;
Exceptions
Data Abort.
LDRSBT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
LDRSBT{<c>}{<q>} <Rt>, [<Rn>] {, #+/-<imm>} Post-indexed: ARM only
LDRSBT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-458 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.88 LDRSH (immediate)
Load Register Signed Halfword (immediate) calculates an address from a base register value and an immediate
offset, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use
offset, post-indexed, or pre-indexed addressing. For information about memory accesses see Memory accesses on
page A8-294.
if Rn == ‘1111’ then SEE LDRSH (literal);
if Rt == ‘1111’ then SEE “Related instructions”;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = TRUE; add = TRUE; wback = FALSE;
if t == 13 then UNPREDICTABLE;
if Rn == ‘1111’ then SEE LDRSH (literal);
if Rt == ‘1111’ && P == ‘1’ && U == ‘0’ && W == ‘0’ then SEE “Related instructions”;
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE LDRSHT;
if P == ‘0’ && W == ‘0’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if t == 13 || (t == 15 && W == ‘1’) || (wback && n == t) then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE LDRSH (literal);
if P == ‘0’ && W == ‘1’ then SEE LDRSHT;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if t == 15 || (wback && n == t) then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRSH<c> <Rt>, [<Rn>, #<imm12>]
Encoding T2 ARMv6T2, ARMv7
LDRSH<c> <Rt>, [<Rn>, #-<imm8>]
LDRSH<c> <Rt>, [<Rn>], #+/-<imm8>
LDRSH<c> <Rt>, [<Rn>, #+/-<imm8>]!
TOKENLDRSH<c> <Rt>, [<Rn>{, #+/-<imm8>}]
LDRSH<c> <Rt>, [<Rn>], #+/-<imm8>
LDRSH<c> <Rt>, [<Rn>, #+/-<imm8>]!
Related instructions See Load halfword, memory hints on page A6-240
1 1 1 1 0 0 1 1 0 1 1 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 0 1 1 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 0 0 P U 1 W 1 Rn Rt imm4H 1 1 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-459
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. For PC use see LDRSH (literal) on page A8-460.
+/- Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE),
or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated
for #0 and #-0.
<imm> The immediate offset used for forming the address, Values are 0-4095 for encoding T1, and 0-255
for encoding T2 or A1. For the offset syntax, <imm> can be omitted, meaning an offset of 0.
The pre-UAL syntax LDR<c>SH is equivalent to LDRSH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = SignExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
LDRSH{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRSH{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-460 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.89 LDRSH (literal)
Load Register Signed Halfword (literal) calculates an address from the PC value and an immediate offset, loads a
halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about
memory accesses see Memory accesses on page A8-294.
if Rt == ‘1111’ then SEE “Related instructions”;
t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
if t == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRSHT;
if P == W then UNPREDICTABLE;
t = UInt(Rt); imm32 = ZeroExtend(imm4H:imm4L, 32); add = (U == ‘1’);
if t == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRSH<c> <Rt>, <label>
LDRSH<c> <Rt>, [PC, #-0] Special case
TOKENLDRSH<c> <Rt>, <label>
LDRSH<c> <Rt>, [PC, #-0] Special case
Related instructions See Load halfword, memory hints on page A6-240
1 1 1 1 0 0 1 U 0 1 1 1 1 1 1 Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 1 W 1 1 1 1 1 Rt imm4H 1 1 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-461
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<label> The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required
value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of
the offset are:
Encoding T1 any value in the range -4095 to 4095
TOKENIf the offset is zero or positive, imm32 is equal to the offset and add == TRUE.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
The pre-UAL syntax LDR<c>SH is equivalent to LDRSH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(15);
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
data = MemU[address,2];
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = SignExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRSH{<c>}{<q>} <Rt>, <label> Normal form
LDRSH{<c>}{<q>} <Rt>, [PC, #+/-<imm>] Alternative form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-462 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.90 LDRSH (register)
Load Register Signed Halfword (register) calculates an address from a base register value and an offset register
value, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset
register value can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see Memory accesses
on page A8-294.
if CurrentInstrSet() == InstrSet_ThumbEE then SEE “Modified operation in ThumbEE”;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rn == ‘1111’ then SEE LDRSH (literal);
if Rt == ‘1111’ then SEE “Related instructions”;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE LDRSHT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LDRSH<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
LDRSH<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENLDRSH<c> <Rt>, [<Rn>,+/-<Rm>]{!}
LDRSH<c> <Rt>, [<Rn>],+/-<Rm>
Related instructions See Load halfword, memory hints on page A6-240
Modified operation in ThumbEE See LDRSH (register) on page A9-1120
0 1 0 1 1 1 1 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 0 1 1 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 0 W 1 Rn Rt (0) (0) (0) (0) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-463
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used. In the ARM instruction set the PC can be used, for the offset
addressing forms of the instruction only. In the Thumb instruction set, the PC cannot be used for any
of these forms of the LDRSH instruction.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally left shifted and added to the value of <Rn> to form the address.
<imm> If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. Only encoding
T2 is permitted, and <imm> is encoded in imm2.
If absent, no shift is specified and all encodings are permitted. In encoding T2, imm2 is encoded as
0b00.
The pre-UAL syntax LDR<c>SH is equivalent to LDRSH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = SignExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRSH{<c>}{<q>} <Rt>, [<Rn>, <Rm>{, LSL #<imm>}] Offset: index==TRUE, wback==FALSE
LDRSH{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>] Offset: index==TRUE, wback==FALSE
LDRSH{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>]! Pre-indexed: index==TRUE, wback==TRUE
LDRSH{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-464 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.91 LDRSHT
Load Register Signed Halfword Unprivileged loads a halfword from memory, sign-extends it to form a 32-bit word,
and writes it to a register. For information about memory accesses see Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
LDRSHT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or a register value.
if Rn == ‘1111’ then SEE LDRSH (literal);
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRSHT<c> <Rt>, [<Rn>, #<imm8>]
TOKENLDRSHT<c> <Rt>, [<Rn>] {, #+/-<imm8>}
Encoding A2 ARMv6T2, ARMv7
LDRSHT<c> <Rt>, [<Rn>], +/-<Rm>
1 1 1 1 0 0 1 0 0 1 1 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 1 1 1 Rn Rt imm4H 1 1 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 0 1 1 Rn Rt (0) (0) (0) (0) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-465
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<imm> The immediate offset applied to the value of <Rn>. Any value in the range 0-255 is permitted. <imm>
can be omitted, meaning an offset of 0.
<Rm> Contains the offset that is applied to the value of <Rn> to form the address.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
data = MemU_unpriv[address,2];
if postindex then R[n] = offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
R[t] = SignExtend(data, 32);
else // Can only apply before ARMv7
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRSHT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
LDRSHT{<c>}{<q>} <Rt>, [<Rn>] {, #+/-<imm>} Post-indexed: ARM only
LDRSHT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-466 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.92 LDRT
Load Register Unprivileged loads a word from memory, and writes it to a register. For information about memory
accesses see Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
LDRT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or an optionally-shifted register value.
if Rn == ‘1111’ then SEE LDR (literal);
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm12, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;
if ArchVersion() < 6 && m == n then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
LDRT<c> <Rt>, [<Rn>, #<imm8>]
TOKENLDRT<c> <Rt>, [<Rn>] {, #+/-<imm12>}
Encoding A2 ARMv4*, ARMv5T*, ARMv6*, ARMv7
LDRT<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
1 1 1 1 0 0 0 0 1 0 1 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 0 U 0 1 1 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 U 0 1 1 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-467
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<imm> The immediate offset applied to the value of <Rn>. Values are 0-255 for encoding T1, and 0-4095 for
TOKEN<Rm> Contains the offset that is optionally shifted and applied to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
The pre-UAL syntax LDR<c>T is equivalent to LDRT<c>.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then Shift(R[m], shift_t, shift_n, APSR.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
data = MemU_unpriv[address,4];
if postindex then R[n] = offset_addr;
if UnalignedSupport() || address<1:0> == ‘00’ then
R[t] = data;
else // Can only apply before ARMv7
if CurrentInstrSet() == InstrSet_ARM then
R[t] = ROR(data, 8*UInt(address<1:0>));
else
R[t] = bits(32) UNKNOWN;
Exceptions
Data Abort.
LDRT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
LDRT{<c>}{<q>} <Rt>, [<Rn>] {, #+/-<imm>} Post-indexed: ARM only
LDRT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> {, <shift>} Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-468 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.93 LEAVEX
LEAVEX causes a change from ThumbEE to Thumb state, or has no effect in Thumb state. For details see ENTERX,
LEAVEX on page A9-1116.
A8.8.94 LSL (immediate)
Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and
writes the result to the destination register. It can optionally update the condition flags based on the result.
if imm5 == ‘00000’ then SEE MOV (register);
d = UInt(Rd); m = UInt(Rm); setflags = !InITBlock();
(-, shift_n) = DecodeImmShift(‘00’, imm5);
if (imm3:imm2) == ‘00000’ then SEE MOV (register);
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘00’, imm3:imm2);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
if imm5 == ‘00000’ then SEE MOV (register);
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘00’, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LSLS <Rd>, <Rm>, #<imm5> Outside IT block.
LSL<c> <Rd>, <Rm>, #<imm5> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
LSL{S}<c>.W <Rd>, <Rm>, #<imm5>
TOKENLSL{S}<c> <Rd>, <Rm>, #<imm5>
0 0 0 0 0 imm5 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 1 0 S 1 1 1 1 (0) imm3 Rd imm2 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd imm5 0 0 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-469
ID051414 Non-Confidential
Assembler syntax
LSL{S}{<c>}{<q>} {<Rd>,} <Rm>, #<imm5>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rm> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<imm5> The shift amount, in the range 1 to 31. See Shifts applied to a register on page A8-291.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry) = Shift_C(R[m], SRType_LSL, shift_n, APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-470 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.95 LSL (register)
Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the
result to the destination register. The variable number of bits is read from the bottom byte of a register. It can
optionally update the condition flags based on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LSLS <Rdn>, <Rm> Outside IT block.
LSL<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
LSL{S}<c>.W <Rd>, <Rn>, <Rm>
TOKENLSL{S}<c> <Rd>, <Rn>, <Rm>
0 1 0 0 0 0 0 0 1 0 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 0 0 S Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd Rm 0 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-471
ID051414 Non-Confidential
Assembler syntax
LSL{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register whose bottom byte contains the amount to shift by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[m]<7:0>);
(result, carry) = Shift_C(R[n], SRType_LSL, shift_n, APSR.C);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-472 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.96 LSR (immediate)
Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and
writes the result to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rd); m = UInt(Rm); setflags = !InITBlock();
(-, shift_n) = DecodeImmShift(‘01’, imm5);
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘01’, imm3:imm2);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘01’, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LSRS <Rd>, <Rm>, #<imm> Outside IT block.
LSR<c> <Rd>, <Rm>, #<imm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
LSR{S}<c>.W <Rd>, <Rm>, #<imm>
TOKENLSR{S}<c> <Rd>, <Rm>, #<imm>
0 0 0 0 1 imm5 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 1 0 S 1 1 1 1 (0) imm3 Rd imm2 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd imm5 0 1 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-473
ID051414 Non-Confidential
Assembler syntax
LSR{S}{<c>}{<q>} {<Rd>,} <Rm>, #<imm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rm> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<imm> The shift amount, in the range 1 to 32. See Shifts applied to a register on page A8-291.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry) = Shift_C(R[m], SRType_LSR, shift_n, APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-474 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.97 LSR (register)
Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes
the result to the destination register. The variable number of bits is read from the bottom byte of a register. It can
optionally update the condition flags based on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
LSRS <Rdn>, <Rm> Outside IT block.
LSR<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
LSR{S}<c>.W <Rd>, <Rn>, <Rm>
TOKENLSR{S}<c> <Rd>, <Rn>, <Rm>
0 1 0 0 0 0 0 0 1 1 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 0 1 S Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd Rm 0 0 1 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-475
ID051414 Non-Confidential
Assembler syntax
LSR{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register whose bottom byte contains the amount to shift by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[m]<7:0>);
(result, carry) = Shift_C(R[n], SRType_LSR, shift_n, APSR.C);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-476 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.98 MCR, MCR2
Move to Coprocessor from ARM core register passes the value of an ARM core register to a coprocessor. If no
coprocessor can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the opc1, opc2, CRn, and CRm fields. However,
coprocessors CP8-CP15 are reserved for use by ARM, and this manual defines the valid MCR and MCR2 instructions
when coproc is in the range p8-p15. For more information see Coprocessor support on page A2-94 and General
behavior of system control registers on page B5-1776.
In an implementation that includes the Virtualization Extensions, MCR accesses to system control registers can be
trapped to Hyp mode, meaning that an attempt to execute an MCR instruction in a Non-secure mode other than Hyp
mode, that would be permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more
information, see Traps to the hypervisor on page B1-1248.
Note
Because of the range of possible traps to Hyp mode, the MCR pseudocode does not show these possible traps.
For the case when cond is 0b1111, see T2/A2 encoding.
if coproc IN “101x” then SEE “Advanced SIMD and Floating-point”;
t = UInt(Rt); cp = UInt(coproc);
if t == 15 || (t == 13 && (CurrentInstrSet() != InstrSet_ARM)) then UNPREDICTABLE;
if coproc IN “101x” then UNDEFINED;
t = UInt(Rt); cp = UInt(coproc);
if t == 15 || (t == 13 && (CurrentInstrSet() != InstrSet_ARM)) then UNPREDICTABLE;
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv4*, ARMv5T*, ARMv6*, ARMv7 for encoding A1
MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{, <opc2>}
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv5T*, ARMv6*, ARMv7 for encoding A2
MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{, <opc2>}
Advanced SIMD and
Floating-point
See 8, 16, and 32-bit transfer between ARM core and extension registers on
page A7-278
1 1 0 1 1 1 0 opc1 0 CRn Rt coproc opc2 1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 1 0 opc1 0 CRn Rt coproc opc2 1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 1 0 opc1 0 CRn Rt coproc opc2 1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 1 1 0 opc1 0 CRn Rt coproc opc2 1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-477
ID051414 Non-Confidential
Assembler syntax
MCR{2}{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM MCR2 instruction must be
unconditional.
<coproc> The name of the coprocessor. The generic coprocessor names are p0-p15.
<opc1> Is a coprocessor-specific opcode in the range 0 to 7.
<Rt> Is the ARM core register whose value is transferred to the coprocessor.
<CRn> Is the destination coprocessor register.
<CRm> Is an additional destination coprocessor register.
<opc2> Is a coprocessor-specific opcode in the range 0-7. If omitted, <opc2> is assumed to be 0.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
Coproc_SendOneWord(R[t], cp, ThisInstr());
Exceptions
Undefined Instruction, Hyp Trap.
Uses of these instructions by specific coprocessors might generate other exceptions.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-478 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.99 MCRR, MCRR2
Move to Coprocessor from two ARM core registers passes the values of two ARM core registers to a coprocessor.
If no coprocessor can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the opc1 and CRm fields. However, coprocessors
CP8-CP15 are reserved for use by ARM, and this manual defines the valid MCRR and MCRR2 instructions when coproc
is in the range p8-p15. For more information see Coprocessor support on page A2-94 and General behavior of
system control registers on page B5-1776.
In an implementation that includes the Virtualization Extensions, MCRR accesses to system control registers can be
trapped to Hyp mode, meaning that an attempt to execute an MCRR instruction in a Non-secure mode other than Hyp
mode, that would be permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more
information, see Traps to the hypervisor on page B1-1248.
Note
Because of the range of possible traps to Hyp mode, the MCRR pseudocode does not show these possible traps.
For the case when cond is 0b1111, see T2/A2 encoding.
if coproc IN “101x” then SEE “Advanced SIMD and Floating-point”;
t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);
if t == 15 || t2 == 15 then UNPREDICTABLE;
if (t == 13 || t2 == 13) && (CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if coproc IN “101x” then UNDEFINED;
t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);
if t == 15 || t2 == 15 then UNPREDICTABLE;
if (t == 13 || t2 == 13) && (CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv5TE*, ARMv6*, ARMv7 for encoding A1
MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm>
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv6*, ARMv7 for encoding A2
MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm>
Advanced SIMD and
Floating-point
See 64-bit transfers between ARM core and extension registers on page A7-279
1 1 0 1 1 0 0 0 1 0 0 Rt2 Rt coproc opc1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 0 0 1 0 0 Rt2 Rt coproc opc1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 0 0 1 0 0 Rt2 Rt coproc opc1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 1 0 0 0 1 0 0 Rt2 Rt coproc opc1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-479
ID051414 Non-Confidential
Assembler syntax
MCRR{2}{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM MCRR2 instruction must be
unconditional.
<coproc> The name of the coprocessor.
The generic coprocessor names are p0-p15.
<opc1> Is a coprocessor-specific opcode in the range 0 to 15.
<Rt> Is the first ARM core register whose value is transferred to the coprocessor.
<Rt2> Is the second ARM core register whose value is transferred to the coprocessor.
<CRm> Is the destination coprocessor register.
Note
For the architected uses of the MCRR instructions, as described in this manual, Rt2 transfers bits[63:32] of the
selected coprocessor register, and Rt transfers bits[31:0]. For IMPLEMENTATION DEFINED uses of the instructions the
relative significance of Rt2 and Rt is IMPLEMENTATION DEFINED.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
Coproc_SendTwoWords(R[t2], R[t], cp, ThisInstr());
Exceptions
Undefined Instruction, Hyp Trap.
Uses of these instructions by specific coprocessors might generate other exceptions.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-480 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.100 MLA
Multiply Accumulate multiplies two register values, and adds a third register value. The least significant 32 bits of
the result are written to the destination register. These 32 bits do not depend on whether the source register values
are considered to be signed values or unsigned values.
In an ARM instruction, the condition flags can optionally be updated based on the result. Use of this option
adversely affects performance on many processor implementations.
if Ra == ‘1111’ then SEE MUL;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); setflags = FALSE;
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); setflags = (S == ‘1’);
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
if ArchVersion() < 6 && d == n then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
MLA<c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENMLA{S}<c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 0 0 0 Rn Ra Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 0 1 S Rd Ra Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-481
ID051414 Non-Confidential
Assembler syntax
MLA{S}{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
S can be specified only for the ARM instruction set.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<Ra> The register containing the accumulate value.
The pre-UAL syntax MLA<c>S is equivalent to MLAS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand1 = SInt(R[n]); // operand1 = UInt(R[n]) produces the same final results
operand2 = SInt(R[m]); // operand2 = UInt(R[m]) produces the same final results
addend = SInt(R[a]); // addend = UInt(R[a]) produces the same final results
result = operand1 * operand2 + addend;
R[d] = result<31:0>;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result<31:0>);
if ArchVersion() == 4 then
APSR.C = bit UNKNOWN;
// else APSR.C unchanged
// APSR.V always unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-482 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.101 MLS
Multiply and Subtract multiplies two register values, and subtracts the product from a third register value. The least
significant 32 bits of the result are written to the destination register. These 32 bits do not depend on whether the
source register values are considered to be signed values or unsigned values.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
MLS<c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENMLS<c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 0 0 0 Rn Ra Rd 0 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 1 1 0 Rd Ra Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-483
ID051414 Non-Confidential
Assembler syntax
MLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<Ra> The register containing the accumulate value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand1 = SInt(R[n]); // operand1 = UInt(R[n]) produces the same final results
operand2 = SInt(R[m]); // operand2 = UInt(R[m]) produces the same final results
addend = SInt(R[a]); // addend = UInt(R[a]) produces the same final results
result = addend - operand1 * operand2;
R[d] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-484 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.102 MOV (immediate)
Move (immediate) writes an immediate value to the destination register. It can optionally update the condition flags
based on the value.
d = UInt(Rd); setflags = !InITBlock(); imm32 = ZeroExtend(imm8, 32); carry = APSR.C;
d = UInt(Rd); setflags = (S == ‘1’); (imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if d IN {13,15} then UNPREDICTABLE;
d = UInt(Rd); setflags = FALSE; imm32 = ZeroExtend(imm4:i:imm3:imm8, 32);
if d IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); setflags = (S == ‘1’); (imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); setflags = FALSE; imm32 = ZeroExtend(imm4:imm12, 32);
if d == 15 then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
MOVS <Rd>, #<imm8> Outside IT block.
MOV<c> <Rd>, #<imm8> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
MOV{S}<c>.W <Rd>, #<const>
Encoding T3 ARMv6T2, ARMv7
MOVW<c> <Rd>, #<imm16>
TOKENMOV{S}<c> <Rd>, #<const>
Encoding A2 ARMv6T2, ARMv7
MOVW<c> <Rd>, #<imm16>
0 0 1 0 0 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 0 0 0 1 0 S 1 1 1 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 1 0 0 1 0 0 imm4 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 1 0 1 S (0) (0) (0) (0) Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 0 0 imm4 Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-485
ID051414 Non-Confidential
Assembler syntax
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, encoding A2 is not permitted, and for
TOKENinterworking branch, see Pseudocode details of operations on ARM core registers on page A2-47.
ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<const> The immediate value to be placed in <Rd>. The range of values is 0-255 for encoding T1 and 0-65535
for encoding T3 or A2. See Modified immediate constants in Thumb instructions on page A6-232
or Modified immediate constants in ARM instructions on page A5-200 for the range of values for
encoding T2 or A1.
When both 32-bit encodings are available for an instruction, encoding T2 or A1 is preferred to
encoding T3 or A2 (if encoding T3 or A2 is required, use the MOVW syntax).
The pre-UAL syntax MOV<c>S is equivalent to MOVS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = imm32;
if d == 15 then // Can only occur for encoding A1
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
MOV{S}{<c>}{<q>} <Rd>, #<const> All encodings permitted
MOVW{<c>}{<q>} <Rd>, #<const> Only encoding T3 or A2 permitted
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-486 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.103 MOV (register, Thumb)
Move (register) copies a value from a register to the destination register. It can optionally update the condition flags
based on the value.
d = UInt(D:Rd); m = UInt(Rm); setflags = FALSE;
if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
d = UInt(Rd); m = UInt(Rm); setflags = TRUE;
if InITBlock() then UNPREDICTABLE;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
if setflags && (d IN {13,15} || m IN {13,15}) then UNPREDICTABLE;
if !setflags && (d == 15 || m == 15 || (d == 13 && m == 13)) then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7 if <Rd> and <Rm> both from R0-R7
ARMv4T, ARMv5T*, ARMv6*, ARMv7 otherwise
MOV<c> <Rd>, <Rm> If <Rd> is the PC, must be outside or last in IT block.
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
MOVS <Rd>, <Rm> Not permitted in IT block
Encoding T3 ARMv6T2, ARMv7
MOV{S}<c>.W <Rd>, <Rm>
0 1 0 0 0 1 1 0 D Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 0 0 0 0 0 0 0 0 0 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 1 0 S 1 1 1 1 (0) 0 0 0 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-487
ID051414 Non-Confidential
Assembler syntax
MOV{S}{<c>}{<q>} <Rd>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. This register can be the SP or PC. S must not be specified if <Rd> is the SP.
If <Rd> is the PC and S is not specified:
• The instruction causes a branch to the address moved to the PC. This is a simple branch, see
Pseudocode details of operations on ARM core registers on page A2-47.
• The instruction must either be outside an IT block or the last instruction of an IT block.
<Rm> The source register. This register can be the SP or PC. S must not be specified if <Rm> is the SP or PC.
Encoding T3 is not permitted if:
• <Rd> or <Rm> is the PC
• both <Rd> and <Rm> are the SP.
Note
• ARM deprecates the use of the following MOV (register) instructions:
— ones in which <Rd> is the SP or PC and <Rm> is also the SP or PC
— ones in which S is specified and <Rm> is the SP, or <Rm> is the PC.
• See also Changing between Thumb state and ARM state on page A4-160 about the use of the MOV PC, LR
instruction.
The pre-UAL syntax MOV<c>S is equivalent to MOVS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[m];
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
// APSR.C unchanged
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-488 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.104 MOV (register, ARM)
Move (register) copies a value from a register to the destination register. It can optionally update the condition flags
based on the value.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
TOKENMOV{S}<c> <Rd>, <Rm>
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd 0 0 0 0 0 0 0 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-489
ID051414 Non-Confidential
Assembler syntax
MOV{S}{<c>}{<q>} <Rd>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR and related
instructions (ARM) on page B9-2012. This register can be the SP or PC.
If <Rd> is the PC and S is not specified, the instruction causes a branch to the address moved to the
PC. This is an interworking branch, see Pseudocode details of operations on ARM core registers on
page A2-47.
Note
Before ARMv7, this was a simple branch.
<Rm> The source register. This register can be the SP or PC.
Note
• ARM deprecates the use of the following MOV (register) instructions:
— ones in which <Rd> is the SP or PC and <Rm> is also the SP or PC
— ones in which S is specified and <Rd> is the SP, <Rm> is the SP, or <Rm> is the PC.
• See also Changing between Thumb state and ARM state on page A4-160 about the use of the MOV PC, LR
instruction.
The pre-UAL syntax MOV<c>S is equivalent to MOVS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[m];
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
// APSR.C unchanged
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-490 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.105 MOV (shifted register)
For the special case of MOVS where <Rd> is the PC, see SUBS PC, LR (Thumb) on page B9-2010 and SUBS PC, LR
and related instructions (ARM) on page B9-2012. Otherwise, MOV (shifted register) is a pseudo-instruction for ASR,
LSL, LSR, ROR, and RRX. For more information see the following sections:
• ASR (immediate) on page A8-330
• ASR (register) on page A8-332
• LSL (immediate) on page A8-468
• LSL (register) on page A8-470
• LSR (immediate) on page A8-472
• LSR (register) on page A8-474
• ROR (immediate) on page A8-568
• ROR (register) on page A8-570
• RRX on page A8-572.
Assembler syntax
Table A8-3 shows the equivalences between MOV (shifted register) and other instructions.
Disassembly produces the canonical form of the instruction.
Exceptions
None.
Table A8-3 MOV (shifted register) equivalences
MOV instruction Canonical form
MOV{S} <Rd>, <Rm>, ASR #<n> ASR{S} <Rd>, <Rm>, #<n>
MOV{S} <Rd>, <Rm>, LSL #<n> LSL{S} <Rd>, <Rm>, #<n>
MOV{S} <Rd>, <Rm>, LSR #<n> LSR{S} <Rd>, <Rm>, #<n>
MOV{S} <Rd>, <Rm>, ROR #<n> ROR{S} <Rd>, <Rm>, #<n>
MOV{S} <Rd>, <Rm>, ASR <Rs> ASR{S} <Rd>, <Rm>, <Rs>
MOV{S} <Rd>, <Rm>, LSL <Rs> LSL{S} <Rd>, <Rm>, <Rs>
MOV{S} <Rd>, <Rm>, LSR <Rs> LSR{S} <Rd>, <Rm>, <Rs>
MOV{S} <Rd>, <Rm>, ROR <Rs> ROR{S} <Rd>, <Rm>, <Rs>
MOV{S} <Rd>, <Rm>, RRX RRX{S} <Rd>, <Rm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-491
ID051414 Non-Confidential
A8.8.106 MOVT
Move Top writes an immediate value to the top halfword of the destination register. It does not affect the contents
of the bottom halfword.
d = UInt(Rd); imm16 = imm4:i:imm3:imm8;
if d IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); imm16 = imm4:imm12;
if d == 15 then UNPREDICTABLE;
Assembler syntax
MOVT{<c>}{<q>} <Rd>, #<imm16>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<imm16> The immediate value to be written to <Rd>. It must be in the range 0-65535.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
R[d]<31:16> = imm16;
// R[d]<15:0> unchanged
Exceptions
None.
Encoding T1 ARMv6T2, ARMv7
MOVT<c> <Rd>, #<imm16>
TOKENMOVT<c> <Rd>, #<imm16>
1 1 1 0 i 1 0 1 1 0 0 imm4 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 1 0 0 imm4 Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-492 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.107 MRC, MRC2
Move to ARM core register from Coprocessor causes a coprocessor to transfer a value to an ARM core register or
to the condition flags. If no coprocessor can execute the instruction, an Undefined Instruction exception is
generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the opc1, opc2, CRn, and CRm fields. However,
coprocessors CP8-CP15 are reserved for use by ARM, and this manual defines the valid MRC and MRC2 instructions
when coproc is in the range p8-p15. For more information see Coprocessor support on page A2-94 and General
behavior of system control registers on page B5-1776.
In an implementation that includes the Virtualization Extensions, MRC accesses to system control registers can be
trapped to Hyp mode, meaning that an attempt to execute an MRC instruction in a Non-secure mode other than Hyp
mode, that would be permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more
information, see Traps to the hypervisor on page B1-1248.
Note
Because of the range of possible traps to Hyp mode, the MRC pseudocode does not show these possible traps.
For the case when cond is 0b1111, see the T2/A2 encoding.
if coproc IN “101x” then SEE “Advanced SIMD and Floating-point”;
t = UInt(Rt); cp = UInt(coproc);
if t == 13 && (CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if coproc IN “101x” then UNDEFINED;
t = UInt(Rt); cp = UInt(coproc);
if t == 13 && (CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv4*, ARMv5T*, ARMv6*, ARMv7 for encoding A1
MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{, <opc2>}
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv5T*, ARMv6*, ARMv7 for encoding A2
MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{, <opc2>}
Advanced SIMD and
Floating-point
See 8, 16, and 32-bit transfer between ARM core and extension registers on
page A7-278
1 1 0 1 1 1 0 opc1 1 CRn Rt coproc opc2 1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 1 0 opc1 1 CRn Rt coproc opc2 1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 1 0 opc1 1 CRn Rt coproc opc2 1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 1 0 opc1 1 CRn Rt coproc opc2 1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-493
ID051414 Non-Confidential
Assembler syntax
MRC{2}{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM MRC2 instruction must be
unconditional.
<coproc> The name of the coprocessor. The generic coprocessor names are p0-p15.
<opc1> Is a coprocessor-specific opcode in the range 0 to 7.
<Rt> Is the destination ARM core register. This register can be R0-R14 or, in some cases, APSR_nzcv.
The APSR_nzcv form writes bits[31:28] of the transferred value to the N, Z, C, and V condition
flags and is specified by setting the Rt field of the encoding to 0b1111. Some coprocessors do not
support that form of the instruction. For permitted uses with CP14 and CP15, see:
• Additional rules for MCR and MRC accesses to CP14 and CP15 registers on page B3-1448
for a VMSA implementation.
• Additional rules for MCR and MRC accesses to CP14 and CP15 registers on page B5-1777
for a PMSA implementation.
In pre-UAL assembler syntax, PC was written instead of APSR_nzcv to select this form.
<CRn> Is the coprocessor register that contains the first operand.
<CRm> Is an additional source or destination coprocessor register.
<opc2> Is a coprocessor-specific opcode in the range 0 to 7. If omitted, <opc2> is assumed to be 0.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
value = Coproc_GetOneWord(cp, ThisInstr());
if t != 15 then
R[t] = value;
else
// Note: not all coprocessors support assignment to the APSR
APSR.N = value<31>;
APSR.Z = value<30>;
APSR.C = value<29>;
APSR.V = value<28>;
// value<27:0> are not used.
Exceptions
Undefined Instruction, Hyp Trap.
Uses of these instructions by specific coprocessors might generate other exceptions.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-494 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.108 MRRC, MRRC2
Move to two ARM core registers from Coprocessor causes a coprocessor to transfer values to two ARM core
registers. If no coprocessor can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the opc1 and CRm fields. However, coprocessors
CP8-CP15 are reserved for use by ARM, and this manual defines the valid MRRC and MRRC2 instructions when coproc
is in the range p8-p15. For more information see Coprocessor support on page A2-94 and General behavior of
system control registers on page B5-1776.
In an implementation that includes the Virtualization Extensions, MRRC accesses to system control registers can be
trapped to Hyp mode, meaning that an attempt to execute an MRRC instruction in a Non-secure mode other than Hyp
mode, that would be permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more
information, see Traps to the hypervisor on page B1-1248.
Note
Because of the range of possible traps to Hyp mode, the MRRC pseudocode does not show these possible traps.
For the case when cond is 0b1111.see the T2/A2 encoding.
if coproc IN “101x” then SEE “Advanced SIMD and Floating-point”;
t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);
if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE;
if (t == 13 || t2 == 13) && (CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if coproc IN “101x” then UNDEFINED;
t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);
if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE;
if (t == 13 || t2 == 13) && (CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv5TE*, ARMv6*, ARMv7 for encoding A1
MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm>
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv6*, ARMv7 for encoding A2
MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm>
Advanced SIMD and
Floating-point
See 64-bit transfers between ARM core and extension registers on page A7-279
1 1 0 1 1 0 0 0 1 0 1 Rt2 Rt coproc opc1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 0 0 1 0 1 Rt2 Rt coproc opc1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 0 0 1 0 1 Rt2 Rt coproc opc1 CRm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 0 0 1 0 1 Rt2 Rt coproc opc1 CRm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-495
ID051414 Non-Confidential
Assembler syntax
MRRC{2}{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM MRRC2 instruction must be
unconditional.
<coproc> The name of the coprocessor. The generic coprocessor names are p0-p15.
<opc1> Is a coprocessor-specific opcode in the range 0 to 15.
<Rt> Is the first destination ARM core register.
<Rt2> Is the second destination ARM core register.
<CRm> Is the coprocessor register that supplies the data to be transferred.
Note
For the architected uses of the MRRC instructions, as described in this manual, Rt2 transfers bits[63:32] of the
selected coprocessor register, and Rt transfers bits[31:0]. For IMPLEMENTATION DEFINED uses of the instructions the
relative significance of Rt2 and Rt is IMPLEMENTATION DEFINED.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
(R[t2], R[t]) = Coproc_GetTwoWords(cp, ThisInstr());
Exceptions
Undefined Instruction, Hyp Trap.
Uses of these instructions by specific coprocessors might generate other exceptions.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-496 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.109 MRS
Move to Register from Special register moves the value from the APSR into an ARM core register.
For details of system level use of this instruction, see MRS on page B9-1990.
d = UInt(Rd);
if d IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd);
if d == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
MRS<c> <Rd>, <spec_reg>
TOKENMRS<c> <Rd>, <spec_reg>
1 1 1 0 0 1 1 1 1 1 0 (1) (1) (1) (1) 1 0 (0) 0 Rd (0) (0) 0 (0) (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 0 0 (1) (1) (1) (1) Rd (0) (0) 0 (0) 0 0 0 0 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-497
ID051414 Non-Confidential
Assembler syntax
MRS{<c>}{<q>} <Rd>, <spec_reg>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<spec_reg> Is one of:
• APSR
• CPSR.
When the MRS instruction is executed in User mode, CPSR is treated as a synonym of APSR.
ARM recommends that application level software uses the APSR form. For more information, see The
Application Program Status Register (APSR) on page A2-49.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
R[d] = APSR;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-498 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.110 MRS (Banked register)
Move to Register from Banked or Special register is a system instruction, see MRS (Banked register) on
page B9-1992.
A8.8.111 MSR (immediate)
Move immediate value to Special register moves selected bits of an immediate value to the corresponding bits in
the APSR.
For details of system level use of this instruction, see MSR (immediate) on page B9-1996.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if mask == ‘00’ then SEE “Related encodings”;
imm32 = ARMExpandImm(imm12); write_nzcvq = (mask<1> == ‘1’); write_g = (mask<0> == ‘1’);
TOKENMSR<c> <spec_reg>, #<const>
Related encodings See MSR (immediate), and hints on page A5-206.
cond 0 0 1 1 0 0 1 0 mask 0 0 (1) (1) (1) (1) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-499
ID051414 Non-Confidential
Assembler syntax
MSR{<c>}{<q>} <spec_reg>, #<imm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<spec_reg> Is one of:
• APSR_<bits>
• CPSR_<fields>.
ARM recommends that application level software uses the APSR forms. For more
information, see The Application Program Status Register (APSR) on page A2-49.
<imm> Is the immediate value to be transferred to <spec_reg>. See Modified immediate constants in
ARM instructions on page A5-200 for the range of values.
<bits> Is one of nzcvq, g, or nzcvqg.
In the A and R profiles:
• APSR_nzcvq is the same as CPSR_f
• APSR_g is the same as CPSR_s
• APSR_nzcvqg is the same as CPSR_fs.
<fields> Is a sequence of one or more of the following: s, f.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if write_nzcvq then
APSR.N = imm32<31>;
APSR.Z = imm32<30>;
APSR.C = imm32<29>;
APSR.V = imm32<28>;
APSR.Q = imm32<27>;
if write_g then
APSR.GE = imm32<19:16>;
Exceptions
None.
Usage
For details of the APSR see The Application Program Status Register (APSR) on page A2-49. Because of the
Do-Not-Modify nature of its reserved bits, the immediate form of MSR is normally only useful at the Application
level for writing to APSR_nzcvq (CPSR_f).
For the A and R profiles, MSR (immediate) on page B9-1996 describes additional functionality that is available
using the reserved bits. This includes some deprecated functionality that is also available to unprivileged software
and therefore can be used at the Application level.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-500 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.112 MSR (register)
Move to Special register from ARM core register moves selected bits of an ARM core register to the APSR.
For details of system level use of this instruction, see MSR (register) on page B9-1998.
n = UInt(Rn); write_nzcvq = (mask<1> == ‘1’); write_g = (mask<0> == ‘1’);
if mask == ‘00’ then UNPREDICTABLE;
if n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); write_nzcvq = (mask<1> == ‘1’); write_g = (mask<0> == ‘1’);
if mask == ‘00’ then UNPREDICTABLE;
if n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
MSR<c> <spec_reg>, <Rn>
TOKENMSR<c> <spec_reg>, <Rn>
1 1 1 0 0 1 1 1 0 0 0 Rn 1 0 (0) 0 mask 0 0 (0) (0) 0 (0) (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 mask 0 0 (1) (1) (1) (1) (0) (0) 0 (0) 0 0 0 0 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-501
ID051414 Non-Confidential
Assembler syntax
MSR{<c>}{<q>} <spec_reg>, <Rn>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<spec_reg> Is one of:
• APSR_<bits>
• CPSR_<fields>.
ARM recommends that application level software uses the APSR form. For more information, see The
Application Program Status Register (APSR) on page A2-49.
<Rn> Is the ARM core register to be transferred to <spec_reg>.
<bits> Is one of nzcvq, g, or nzcvqg.
In the A and R profiles:
• APSR_nzcvq is the same as CPSR_f
• APSR_g is the same as CPSR_s
• APSR_nzcvqg is the same as CPSR_fs.
<fields> Is a sequence of one or more of the following: s, f.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if write_nzcvq then
APSR.N = R[n]<31>;
APSR.Z = R[n]<30>;
APSR.C = R[n]<29>;
APSR.V = R[n]<28>;
APSR.Q = R[n]<27>;
if write_g then
APSR.GE = R[n]<19:16>;
Exceptions
None.
Usage
For details of the APSR see The Application Program Status Register (APSR) on page A2-49. Because of the
Do-Not-Modify nature of its reserved bits, a read-modify-write sequence is normally needed when the MSR
instruction is being used at Application level and its destination is not APSR_nzcvq (CPSR_f).
For the A and R profiles, MSR (register) on page B9-1998 describes additional functionality that is available using
the reserved bits. This includes some deprecated functionality that is also available to unprivileged software and
therefore can be used at the Application level.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-502 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.113 MSR (Banked register)
Move to Banked or Special register from ARM core register is a system instruction, see MSR (Banked register) on
page B9-1994.
A8.8.114 MUL
Multiply multiplies two register values. The least significant 32 bits of the result are written to the destination
register. These 32 bits do not depend on whether the source register values are considered to be signed values or
unsigned values.
Optionally, it can update the condition flags based on the result. In the Thumb instruction set, this option is limited
to only a few forms of the instruction. Use of this option adversely affects performance on many processor
implementations.
d = UInt(Rdm); n = UInt(Rn); m = UInt(Rdm); setflags = !InITBlock();
if ArchVersion() < 6 && d == n then UNPREDICTABLE;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if ArchVersion() < 6 && d == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
MULS <Rdm>, <Rn>, <Rdm> Outside IT block.
MUL<c> <Rdm>, <Rn>, <Rdm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
MUL<c> <Rd>, <Rn>, <Rm>
TOKENMUL{S}<c> <Rd>, <Rn>, <Rm>
0 1 0 0 0 0 1 1 0 1 Rn Rdm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 1 0 0 0 0 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 0 0 S Rd (0) (0) (0) (0) Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-503
ID051414 Non-Confidential
Assembler syntax
MUL{S}{<c>}{<q>} <Rd>, <Rn>{, <Rm>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
In the Thumb instruction set, S can be specified only if both <Rn> and <Rm> are R0-R7 and the
instruction is outside an IT block.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register. If omitted, <Rd> is used.
Note
Issues A and B of this document showed the MUL syntax as MUL{S}{<c>}{<q>} {<Rd>, }<Rn>, <Rm>. The <Rm> register
is now made optional because omitting <Rd> can generate UNPREDICTABLE instructions in some cases. Some
assembler versions might not support this revised specification.
The pre-UAL syntax MUL<c>S is equivalent to MULS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand1 = SInt(R[n]); // operand1 = UInt(R[n]) produces the same final results
operand2 = SInt(R[m]); // operand2 = UInt(R[m]) produces the same final results
result = operand1 * operand2;
R[d] = result<31:0>;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result<31:0>);
if ArchVersion() == 4 then
APSR.C = bit UNKNOWN;
// else APSR.C unchanged
// APSR.V always unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-504 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.115 MVN (immediate)
Bitwise NOT (immediate) writes the bitwise inverse of an immediate value to the destination register. It can
optionally update the condition flags based on the value.
d = UInt(Rd); setflags = (S == ‘1’);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if d IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); setflags = (S == ‘1’);
(imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
Encoding T1 ARMv6T2, ARMv7
MVN{S}<c> <Rd>, #<const>
TOKENMVN{S}<c> <Rd>, #<const>
1 1 1 0 i 0 0 0 1 1 S 1 1 1 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 1 1 1 S (0) (0) (0) (0) Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-505
ID051414 Non-Confidential
Assembler syntax
MVN{S}{<c>}{<q>} <Rd>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<const> The immediate value to be bitwise inverted. See Modified immediate constants in Thumb
instructions on page A6-232 or Modified immediate constants in ARM instructions on page A5-200
for the range of values.
The pre-UAL syntax MVN<c>S is equivalent to MVNS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = NOT(imm32);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-506 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.116 MVN (register)
Bitwise NOT (register) writes the bitwise inverse of a register value to the destination register. It can optionally
update the condition flags based on the result.
d = UInt(Rd); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
MVNS <Rd>, <Rm> Outside IT block.
MVN<c> <Rd>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
MVN{S}<c>.W <Rd>, <Rm>{, <shift>}
TOKENMVN{S}<c> <Rd>, <Rm>{, <shift>}
0 1 0 0 0 0 1 1 1 1 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 1 1 S 1 1 1 1 (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 1 1 S (0) (0) (0) (0) Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-507
ID051414 Non-Confidential
Assembler syntax
MVN{S}{<c>}{<q>} <Rd>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rm> The register that is optionally shifted and used as the source register. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
The pre-UAL syntax MVN<c>S is equivalent to MVNS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = NOT(shifted);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-508 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.117 MVN (register-shifted register)
Bitwise NOT (register-shifted register) writes the bitwise inverse of a register-shifted register value to the
destination register. It can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENMVN{S}<c> <Rd>, <Rm>, <type> <Rs>
cond 0 0 0 1 1 1 1 S (0) (0) (0) (0) Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-509
ID051414 Non-Confidential
Assembler syntax
MVN{S}{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that is shifted and used as the operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax MVN<c>S is equivalent to MVNS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = NOT(shifted);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-510 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.118 NEG
Negate is a pre-UAL synonym for RSB (immediate) with an immediate value of 0. For details see RSB (immediate)
on page A8-574.
Assembler syntax
NEG{<c>}{<q>} <Rd>, <Rm>
This is equivalent to:
RSBS{<c>}{<q>} <Rd>, <Rm>, #0
Exceptions
None.
A8.8.119 NOP
No Operation does nothing. This instruction can be used for instruction alignment purposes.
See Pre-UAL pseudo-instruction NOP on page D8-2474 for details of NOP before the introduction of UAL and the
ARMv6K and ARMv6T2 architecture variants.
Note
The timing effects of including a NOP instruction in a program are not guaranteed. It can increase execution time,
leave it unchanged, or even reduce it. Therefore, NOP instructions are not suitable for timing loops.
// No additional decoding required
// No additional decoding required
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
// No additional decoding required
Encoding T1 ARMv6T2, ARMv7
NOP<c>
Encoding T2 ARMv6T2, ARMv7
NOP<c>.W
TOKENNOP<c>
1 0 1 1 1 1 1 1 0 0 0 0 0 0 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 0 0
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-511
ID051414 Non-Confidential
Assembler syntax
NOP{<c>}{<q>}
where:
{<c>}{<q>} See Standard assembler syntax fields on page A8-287.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
// Do nothing
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-512 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.120 ORN (immediate)
Bitwise OR NOT (immediate) performs a bitwise (inclusive) OR of a register value and the complement of an
immediate value, and writes the result to the destination register. It can optionally update the condition flags based
on the result.
if Rn == ‘1111’ then SEE MVN (immediate);
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if d IN {13,15} || n == 13 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
ORN{S}<c> <Rd>, <Rn>, #<const>
1 1 1 0 i 0 0 0 1 1 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-513
ID051414 Non-Confidential
Assembler syntax
ORN{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The register that contains the operand.
<const> The immediate value to be bitwise inverted and ORed with the value obtained from <Rn>. See
Modified immediate constants in Thumb instructions on page A6-232 for the range of values.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[n] OR NOT(imm32);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-514 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.121 ORN (register)
Bitwise OR NOT (register) performs a bitwise (inclusive) OR of a register value and the complement of an
optionally-shifted register value, and writes the result to the destination register. It can optionally update the
condition flags based on the result.
if Rn == ‘1111’ then SEE MVN (register);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
ORN{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
1 1 0 1 0 1 0 0 1 1 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-515
ID051414 Non-Confidential
Assembler syntax
ORN{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is optionally shifted and used as the second operand.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] OR NOT(shifted);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-516 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.122 ORR (immediate)
Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate value, and writes
the result to the destination register. It can optionally update the condition flags based on the result.
if Rn == ‘1111’ then SEE MOV (immediate);
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if d IN {13,15} || n == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’);
(imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
Encoding T1 ARMv6T2, ARMv7
ORR{S}<c> <Rd>, <Rn>, #<const>
TOKENORR{S}<c> <Rd>, <Rn>, #<const>
1 1 1 0 i 0 0 0 1 0 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 1 0 0 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-517
ID051414 Non-Confidential
Assembler syntax
ORR{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The register that contains the operand. The PC can be used in ARM instructions, but ARM
deprecates this use of the PC.
<const> The immediate value to be bitwise ORed with the value obtained from <Rn>. See Modified
immediate constants in Thumb instructions on page A6-232 or Modified immediate constants in
ARM instructions on page A5-200 for the range of values.
The pre-UAL syntax ORR<c>S is equivalent to ORRS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[n] OR imm32;
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-518 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.123 ORR (register)
Bitwise OR (register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value,
and writes the result to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
if Rn == ‘1111’ then SEE “Related encodings”;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
ORRS <Rdn>, <Rm> Outside IT block.
ORR<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
ORR{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
TOKENORR{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
Related encodings See Move register and immediate shifts on page A6-244.
0 1 0 0 0 0 1 1 0 0 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 1 0 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 0 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-519
ID051414 Non-Confidential
Assembler syntax
ORR{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
In Thumb assembly:
• outside an IT block, if ORRS <Rd>, <Rn>, <Rd> is written with <Rd> and <Rn> both in the range R0-R7, it is
assembled using encoding T1 as though ORRS <Rd>, <Rn> had been written
• inside an IT block, if ORR<c> <Rd>, <Rn>, <Rd> is written with <Rd> and <Rn> both in the range R0-R7, it is
assembled using encoding T1 as though ORR<c> <Rd>, <Rn> had been written.
To prevent either of these happening, use the .W qualifier.
The pre-UAL syntax ORR<c>S is equivalent to ORRS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] OR shifted;
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-520 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.124 ORR (register-shifted register)
Bitwise OR (register-shifted register) performs a bitwise (inclusive) OR of a register value and a register-shifted
register value, and writes the result to the destination register. It can optionally update the condition flags based on
the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENORR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 1 1 0 0 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-521
ID051414 Non-Confidential
Assembler syntax
ORR{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax ORR<c>S is equivalent to ORRS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] OR shifted;
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-522 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.125 PKH
Pack Halfword combines one halfword of its first operand with the other halfword of its shifted second operand.
if S == ‘1’ || T == ‘1’ then UNDEFINED;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); tbform = (tb == ‘1’);
(shift_t, shift_n) = DecodeImmShift(tb:’0’, imm3:imm2);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); tbform = (tb == ‘1’);
(shift_t, shift_n) = DecodeImmShift(tb:’0’, imm5);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
PKHBT<c> <Rd>, <Rn>, <Rm>{, LSL #<imm>}
PKHTB<c> <Rd>, <Rn>, <Rm>{, ASR #<imm>}
TOKENPKHBT<c> <Rd>, <Rn>, <Rm>{, LSL #<imm>}
PKHTB<c> <Rd>, <Rn>, <Rm>{, ASR #<imm>}
1 1 0 1 0 1 0 1 1 0 S Rn (0) imm3 Rd imm2 tb T Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 1 1 0 1 0 0 0 Rn Rd imm5 tb 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-523
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is optionally shifted and used as the second operand.
<imm> The shift to apply to the value read from <Rm>, encoded in imm3:imm2 for encoding T1 and imm5
for encoding A1.
For PKHBT, it is one of:
omitted No shift, encoded as 0b00000.
1-31 Left shift by specified number of bits, encoded as a binary number.
For PKHTB, it is one of:
omitted Instruction is a pseudo-instruction and is assembled as though PKHBT{<c>}{<q>} <Rd>,
<Rm>, <Rn> had been written.
1-32 Arithmetic right shift by specified number of bits. A shift by 32 bits is encoded as
0b00000. Other shift amounts are encoded as binary numbers.
Note
An assembler can permit <imm> = 0 to mean the same thing as omitting the shift, but this is not
standard UAL and must not be used for disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = Shift(R[m], shift_t, shift_n, APSR.C); // APSR.C ignored
R[d]<15:0> = if tbform then operand2<15:0> else R[n]<15:0>;
R[d]<31:16> = if tbform then R[n]<31:16> else operand2<31:16>;
Exceptions
None.
PKHBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, LSL #<imm>} tbform == FALSE
PKHTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ASR #<imm>} tbform == TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-524 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.126 PLD, PLDW (immediate)
Preload Data signals the memory system that data memory accesses from a specified address are likely in the near
future. The memory system can respond by taking actions that are expected to speed up the memory accesses when
they do occur, such as pre-loading the cache line containing the specified address into the data cache.
On an architecture variant that includes both the PLD and PLDW instructions, the PLD instruction signals that the likely
memory access is a read, and the PLDW instruction signals that it is a write.
The effect of a PLD or PLDW instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches
on page A3-158 and Behavior of Preload Data (PLD, PLDW) and Preload Instruction (PLI) with caches on
page B2-1269.
if Rn == ‘1111’ then SEE PLD (literal);
n = UInt(Rn); imm32 = ZeroExtend(imm12, 32); add = TRUE; is_pldw = (W == ‘1’);
if Rn == ‘1111’ then SEE PLD (literal);
n = UInt(Rn); imm32 = ZeroExtend(imm8, 32); add = FALSE; is_pldw = (W == ‘1’);
if Rn == ‘1111’ then SEE PLD (literal);
n = UInt(Rn); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’); is_pldw = (R == ‘0’);
Encoding T1 ARMv6T2, ARMv7 for PLD
ARMv7 with MP Extensions for PLDW
PLD{W}<c> [<Rn>, #<imm12>]
Encoding T2 ARMv6T2, ARMv7 for PLD
ARMv7 with MP Extensions for PLDW
PLD{W}<c> [<Rn>, #-<imm8>]
TOKENARMv7 with MP Extensions for PLDW
PLD{W} [<Rn>, #+/-<imm12>]
1 1 1 1 0 0 0 1 0 W 1 Rn 1 1 1 1 imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 W 1 Rn 1 1 1 1 1 1 0 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 U R 0 1 Rn (1) (1) (1) (1) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-525
ID051414 Non-Confidential
Assembler syntax
where:
W If specified, selects PLDW, encoded as W = 1 in Thumb encodings and R = 0 in ARM encodings.
If omitted, selects PLD, encoded as W = 0 in Thumb encodings and R = 1 in ARM encodings.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM PLD or PLDW instruction must be
unconditional.
<Rn> The base register. The SP can be used. For PC use in the PLD instruction, see PLD (literal) on
page A8-526.
+/- Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE),
or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated
for #0 and #-0.
<imm> The immediate offset used for forming the address. This offset can be omitted, meaning an offset of
0. Values are:
Encoding T1, A1 any value in the range 0-4095
Encoding T2 any value in the range 0-255.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
address = if add then (R[n] + imm32) else (R[n] - imm32);
if is_pldw then
Hint_PreloadDataForWrite(address);
else
Hint_PreloadData(address);
Exceptions
None.
PLD{W}{<c>}{<q>} [<Rn> {, #+/-<imm>}]
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-526 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.127 PLD (literal)
Preload Data signals the memory system that data memory accesses from a specified address are likely in the near
future. The memory system can respond by taking actions that are expected to speed up the memory accesses when
they do occur, such as pre-loading the cache line containing the specified address into the data cache.
The effect of a PLD instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches on
page A3-158 and Behavior of Preload Data (PLD, PLDW) and Preload Instruction (PLI) with caches on
page B2-1269.
imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
Encoding T1 ARMv6T2, ARMv7
PLD<c> <label>
PLD<c> [PC, #-0] Special case
TOKENPLD <label>
PLD [PC, #-0] Special case
1 1 1 1 0 0 0 U 0 (0) 1 1 1 1 1 1 1 1 1 imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 U (1) 0 1 1 1 1 1 (1) (1) (1) (1) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-527
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM PLD instruction must be
unconditional.
<label> The label of the literal data item that is likely to be accessed in the near future. The assembler
calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.
The offset must be in the range –4095 to 4095.
If the offset is zero or positive, imm32 is equal to the offset and add == TRUE.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE.
+/- Is + or omitted to indicate that the immediate offset is added to the Align(PC, 4) value (add == TRUE),
or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated
for #0 and #-0.
<imm> The immediate offset used for forming the address. Values are in the range 0-4095.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
Hint_PreloadData(address);
Exceptions
None.
PLD{<c>}{<q>} <label> Normal form
PLD{<c>}{<q>} [PC, #+/-<imm>] Alternative form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-528 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.128 PLD, PLDW (register)
Preload Data signals the memory system that data memory accesses from a specified address are likely in the near
future. The memory system can respond by taking actions that are expected to speed up the memory accesses when
they do occur, such as pre-loading the cache line containing the specified address into the data cache.
On an architecture variant that includes both the PLD and PLDW instructions, the PLD instruction signals that the likely
memory access is a read, and the PLDW instruction signals that it is a write.
The effect of a PLD or PLDW instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches
on page A3-158 and Behavior of Preload Data (PLD, PLDW) and Preload Instruction (PLI) with caches on
page B2-1269.
if Rn == ‘1111’ then SEE PLD (literal);
n = UInt(Rn); m = UInt(Rm); add = TRUE; is_pldw = (W == ‘1’);
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m IN {13,15} then UNPREDICTABLE;
n = UInt(Rn); m = UInt(Rm); add = (U == ‘1’); is_pldw = (R == ‘0’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
if m == 15 || (n == 15 && is_pldw) then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7 for PLD
ARMv7 with MP Extensions for PLDW
PLD{W}<c> [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENARMv7 with MP Extensions for PLDW
PLD{W} [<Rn>,+/-<Rm>{, <shift>}]
1 1 1 1 0 0 0 0 0 W 1 Rn 1 1 1 1 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 1 1 U R 0 1 Rn (1) (1) (1) (1) imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-529
ID051414 Non-Confidential
Assembler syntax
PLD{W}{<c>}{<q>} [<Rn>, +/-<Rm> {, <shift>}]
where:
W If specified, selects PLDW, encoded as W = 1 in Thumb encodings and R = 0 in ARM encodings.
If omitted, selects PLD, encoded as W = 0 in Thumb encodings and R = 1 in ARM encodings.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM PLD or PLDW instruction must be
unconditional.
<Rn> Is the base register. The SP can be used. The PC can be used in ARM PLD instructions, but not in
Thumb PLD instructions or in any PLDW instructions.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally shifted and applied to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If absent, no shift is applied. For encoding T1, <shift>
can only be omitted, encoded as imm2 = 0b00, or LSL #<imm> with <imm> = 1, 2, or 3, with <imm>
encoded in imm2. For encoding A1, see Shifts applied to a register on page A8-291.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset = Shift(R[m], shift_t, shift_n, APSR.C);
address = if add then (R[n] + offset) else (R[n] - offset);
if is_pldw then
Hint_PreloadDataForWrite(address);
else
Hint_PreloadData(address);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-530 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.129 PLI (immediate, literal)
Preload Instruction signals the memory system that instruction memory accesses from a specified address are likely
in the near future. The memory system can respond by taking actions that are expected to speed up the memory
accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction
cache.
The effect of a PLI instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches on
page A3-158 and Behavior of Preload Data (PLD, PLDW) and Preload Instruction (PLI) with caches on
page B2-1269.
if Rn == ‘1111’ then SEE encoding T3;
n = UInt(Rn); imm32 = ZeroExtend(imm12, 32); add = TRUE;
if Rn == ‘1111’ then SEE encoding T3;
n = UInt(Rn); imm32 = ZeroExtend(imm8, 32); add = FALSE;
n = 15; imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
n = UInt(Rn); imm32 = ZeroExtend(imm12, 32); add = (U == ‘1’);
Encoding T1 ARMv7
PLI<c> [<Rn>, #<imm12>]
Encoding T2 ARMv7
PLI<c> [<Rn>, #-<imm8>]
Encoding T3 ARMv7
PLI<c> <label>
PLI<c> [PC, #-0] Special case
TOKENPLI [<Rn>, #+/-<imm12>]
PLI <label>
PLI [PC, #-0] Special case
1 1 1 1 0 0 1 1 0 0 1 Rn 1 1 1 1 imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 0 0 1 Rn 1 1 1 1 1 1 0 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 U 0 0 1 1 1 1 1 1 1 1 1 imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 U 1 0 1 Rn (1) (1) (1) (1) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-531
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM PLI instruction must be
unconditional.
<Rn> Is the base register. The SP can be used.
+/- Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE),
or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated
for #0 and #-0.
<imm> The immediate offset used for forming the address. For the immediate form of the syntax, <imm> can
be omitted, in which case the #0 form of the instruction is assembled. Values are:
Encoding T1, T3, A1 any value in the range 0 to 4095
Encoding T2 any value in the range 0 to 255.
<label> The label of the instruction that is likely to be accessed in the near future. The assembler calculates
the required value of the offset from the Align(PC, 4) value of the instruction to this label. The offset
must be in the range –4095 to 4095.
If the offset is zero or positive, imm32 is equal to the offset and add == TRUE.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE.
For the literal forms of the instruction, encoding T3 is used, or Rn is encoded as 0b1111 in encoding A1, to indicate
that the PC is the base register.
The alternative literal syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
base = if n == 15 then Align(PC,4) else R[n];
address = if add then (base + imm32) else (base - imm32);
Hint_PreloadInstr(address);
Exceptions
None.
PLI{<c>}{<q>} [<Rn> {, #+/-<imm>}] Immediate form
PLI{<c>}{<q>} <label> Normal literal form
PLI{<c>}{<q>} [PC, #+/-<imm>] Alternative literal form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-532 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.130 PLI (register)
Preload Instruction signals the memory system that instruction memory accesses from a specified address are likely
in the near future. The memory system can respond by taking actions that are expected to speed up the memory
accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction
cache. For more information, see Behavior of Preload Data (PLD, PLDW) and Preload Instruction (PLI) with
caches on page B2-1269.
The effect of a PLI instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches on
page A3-158 and Behavior of Preload Data (PLD, PLDW) and Preload Instruction (PLI) with caches on
page B2-1269.
if Rn == ‘1111’ then SEE PLI (immediate, literal);
n = UInt(Rn); m = UInt(Rm); add = TRUE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m IN {13,15} then UNPREDICTABLE;
n = UInt(Rn); m = UInt(Rm); add = (U == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
if m == 15 then UNPREDICTABLE;
Encoding T1 ARMv7
PLI<c> [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENPLI [<Rn>,+/-<Rm>{, <shift>}]
1 1 1 1 0 0 1 0 0 0 1 Rn 1 1 1 1 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 1 0 U 1 0 1 Rn (1) (1) (1) (1) imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-533
ID051414 Non-Confidential
Assembler syntax
PLI{<c>}{<q>} [<Rn>, +/-<Rm> {, <shift>}]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM PLI instruction must be
unconditional.
<Rn> Is the base register. The SP can be used.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally shifted and applied to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If absent, no shift is applied. For encoding T1, <shift>
can only be omitted, encoded as imm2 = 0b00, or LSL #<imm> with <imm> = 1, 2, or 3, with <imm>
encoded in imm2. For encoding A1, see Shifts applied to a register on page A8-291.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset = Shift(R[m], shift_t, shift_n, APSR.C);
address = if add then (R[n] + offset) else (R[n] - offset);
Hint_PreloadInstr(address);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-534 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.131 POP (Thumb)
Pop Multiple Registers loads multiple registers from the stack, loading from consecutive memory locations starting
at the address in SP, and updates SP to point just above the loaded data.
registers = P:’0000000’:register_list; UnalignedAllowed = FALSE;
if BitCount(registers) < 1 then UNPREDICTABLE;
if registers<15> == ‘1’ && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
registers = P:M:’0’:register_list; UnalignedAllowed = FALSE;
if BitCount(registers) < 2 || (P == ‘1’ && M == ‘1’) then UNPREDICTABLE;
if registers<15> == ‘1’ && InITBlock() && !LastInITBlock() then UNPREDICTABLE;
t = UInt(Rt); registers = Zeros(16); registers<t> = ‘1’; UnalignedAllowed = TRUE;
if t == 13 || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
POP<c> <registers>
Encoding T2 ARMv6T2, ARMv7
POP<c>.W <registers> <registers> contains more than one register
Encoding T3 ARMv6T2, ARMv7
POP<c>.W <registers> <registers> contains one register, <Rt>
1 0 1 1 1 1 0 P register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 0 0 1 0 1 1 1 1 0 1 P M (0) register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 1 0 1 1 1 0 1 Rt 1 0 1 1 0 0 0 0 0 1 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-535
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<registers> Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The
lowest-numbered register is loaded from the lowest memory address, through to the
highest-numbered register from the highest memory address. See also Encoding of lists of ARM core
registers on page A8-295.
If the list contains more than one register, the instruction is assembled to encoding T1 or T2. If the
list contains exactly one register, the instruction is assembled to encoding T1 or T3.
The PC can be in the list. If it is, the instruction branches to the address loaded to the PC. In
ARMv5T and above, this is an interworking branch, see Pseudocode details of operations on ARM
core registers on page A2-47. If the PC is in the list:
• the LR must not be in the list
• the instruction must be either outside any IT block, or the last instruction in an IT block.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(13);
address = SP;
for i = 0 to 14
if registers<i> == ‘1’ then
R[i] = if UnalignedAllowed then MemU[address,4] else MemA[address,4];
address = address + 4;
if registers<15> == ‘1’ then
if UnalignedAllowed then
if address<1:0> == ‘00’ then
LoadWritePC(MemU[address,4]);
else
UNPREDICTABLE;
else
LoadWritePC(MemA[address,4]);
if registers<13> == ‘0’ then SP = SP + 4*BitCount(registers);
if registers<13> == ‘1’ then SP = bits(32) UNKNOWN;
Exceptions
Data Abort.
POP{<c>}{<q>} <registers> Standard syntax
LDM{<c>}{<q>} SP!, <registers> Equivalent LDM syntax
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-536 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.132 POP (ARM)
Pop Multiple Registers loads multiple registers from the stack, loading from consecutive memory locations starting
at the address in SP, and updates SP to point just above the loaded data.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if BitCount(register_list) < 2 then SEE LDM / LDMIA / LDMFD;
registers = register_list; UnalignedAllowed = FALSE;
if registers<13> == ‘1’ && ArchVersion() >= 7 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); registers = Zeros(16); registers<t> = ‘1’; UnalignedAllowed = TRUE;
if t == 13 then UNPREDICTABLE;
TOKENPOP<c> <registers> <registers> contains more than one register
Encoding A2 ARMv4*, ARMv5T*, ARMv6*, ARMv7
POP<c> <registers> <registers> contains one register, <Rt>
cond 1 0 0 0 1 0 1 1 1 1 0 1 register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 0 1 0 0 1 1 1 0 1 Rt 0 0 0 0 0 0 0 0 0 1 0 0
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-537
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<registers> Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The
lowest-numbered register is loaded from the lowest memory address, through to the
highest-numbered register from the highest memory address. See also Encoding of lists of ARM core
registers on page A8-295.
If the list contains more than one register, the instruction is assembled to encoding A1. If the list
contains exactly one register, the instruction is assembled to encoding A2.
The SP can only be in the list before ARMv7. ARM deprecates any use of ARM instructions that
include the SP, and the value of the SP after such an instruction is UNKNOWN.
The PC can be in the list. If it is, the instruction branches to the address loaded to the PC. In
ARMv5T and above, this is an interworking branch, see Pseudocode details of operations on ARM
core registers on page A2-47.
ARM deprecates the use of this instruction with both the LR and the PC in the list.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(13);
address = SP;
for i = 0 to 14
if registers<i> == ‘1’ then
R[i] = if UnalignedAllowed then MemU[address,4] else MemA[address,4];
address = address + 4;
if registers<15> == ‘1’ then
if UnalignedAllowed then
if address<1:0> == ‘00’ then
LoadWritePC(MemU[address,4]);
else
UNPREDICTABLE;
else
LoadWritePC(MemA[address,4]);
if registers<13> == ‘0’ then SP = SP + 4*BitCount(registers);
if registers<13> == ‘1’ then SP = bits(32) UNKNOWN;
Exceptions
Data Abort.
POP{<c>}{<q>} <registers> Standard syntax
LDM{<c>}{<q>} SP!, <registers> Equivalent LDM syntax
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-538 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.133 PUSH
Push Multiple Registers stores multiple registers to the stack, storing to consecutive memory locations ending just
below the address in SP, and updates SP to point to the start of the stored data.
registers = ‘0’:M:’000000’:register_list; UnalignedAllowed = FALSE;
if BitCount(registers) < 1 then UNPREDICTABLE;
registers = ‘0’:M:’0’:register_list; UnalignedAllowed = FALSE;
if BitCount(registers) < 2 then UNPREDICTABLE;
t = UInt(Rt); registers = Zeros(16); registers<t> = ‘1’; UnalignedAllowed = TRUE;
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if BitCount(register_list) < 2 then SEE STMDB / STMFD;
registers = register_list; UnalignedAllowed = FALSE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); registers = Zeros(16); registers<t> = ‘1’; UnalignedAllowed = TRUE;
if t == 13 then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
PUSH<c> <registers>
Encoding T2 ARMv6T2, ARMv7
PUSH<c>.W <registers> <registers> contains more than one register
Encoding T3 ARMv6T2, ARMv7
PUSH<c>.W <registers> <registers> contains one register, <Rt>
TOKENPUSH<c> <registers> <registers> contains more than one register
Encoding A2 ARMv4*, ARMv5T*, ARMv6*, ARMv7
PUSH<c> <registers> <registers> contains one register, <Rt>
1 0 1 1 0 1 0 M register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 0 1 0 0 1 0 1 1 0 1 (0) M (0) register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 1 0 0 1 1 0 1 Rt 1 1 0 1 0 0 0 0 0 1 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 0 0 1 0 0 1 0 1 1 0 1 register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 1 0 0 1 0 1 1 0 1 Rt 0 0 0 0 0 0 0 0 0 1 0 0
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-539
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<registers> Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The
lowest-numbered register is stored to the lowest memory address, through to the highest-numbered
register to the highest memory address. See also Encoding of lists of ARM core registers on
page A8-295.
If the list contains more than one register, the instruction is assembled to encoding T1, T2, or A1. If
the list contains exactly one register, the instruction is assembled to encoding T1, T3, or A2.
The SP and PC can be in the list in ARM instructions, but not in Thumb instructions. However:
• ARM deprecates the use of ARM instructions that include the PC in the list
• if the SP is in the list, and it is not the lowest-numbered register in the list, the instruction
stores an UNKNOWN value for the SP.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(13);
address = SP - 4*BitCount(registers);
for i = 0 to 14
if registers<i> == ‘1’ then
if i == 13 && i != LowestSetBit(registers) then // Only possible for encoding A1
MemA[address,4] = bits(32) UNKNOWN;
else
if UnalignedAllowed then
MemU[address,4] = R[i];
else
MemA[address,4] = R[i];
address = address + 4;
if registers<15> == ‘1’ then // Only possible for encoding A1 or A2
if UnalignedAllowed then
MemU[address,4] = PCStoreValue();
else
MemA[address,4] = PCStoreValue();
SP = SP - 4*BitCount(registers);
Exceptions
Data Abort.
PUSH{<c>}{<q>} <registers> Standard syntax
STMDB{<c>}{<q>} SP!, <registers> Equivalent STM syntax
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-540 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.134 QADD
Saturating Add adds two register values, saturates the result to the 32-bit signed integer range –231 to (231 – 1), and
writes the result to the destination register. If saturation occurs, it sets the Q flag in the APSR.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QADD<c> <Rd>, <Rm>, <Rn>
TOKENQADD<c> <Rd>, <Rm>, <Rn>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 1 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 0 0 Rn Rd (0) (0) (0) (0) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-541
ID051414 Non-Confidential
Assembler syntax
QADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The first operand register.
<Rn> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(R[d], sat) = SignedSatQ(SInt(R[m]) + SInt(R[n]), 32);
if sat then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-542 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.135 QADD16
Saturating Add 16 performs two 16-bit integer additions, saturates the results to the 16-bit signed integer range
–215 ≤ x ≤ 215 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QADD16<c> <Rd>, <Rn>, <Rm>
TOKENQADD16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 1 Rn 1 1 1 1 Rd 0 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 1 1 0 0 0 1 0 Rn Rd (1) (1) (1) (1) 0 0 0 1 Rm
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-543
ID051414 Non-Confidential
Assembler syntax
QADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
R[d]<15:0> = SignedSat(sum1, 16);
R[d]<31:16> = SignedSat(sum2, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-544 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.136 QADD8
Saturating Add 8 performs four 8-bit integer additions, saturates the results to the 8-bit signed integer range
–27 ≤ x ≤ 27 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QADD8<c> <Rd>, <Rn>, <Rm>
TOKENQADD8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 0 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 1 1 0 0 0 1 0 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rm
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-545
ID051414 Non-Confidential
Assembler syntax
QADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
R[d]<7:0> = SignedSat(sum1, 8);
R[d]<15:8> = SignedSat(sum2, 8);
R[d]<23:16> = SignedSat(sum3, 8);
R[d]<31:24> = SignedSat(sum4, 8);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-546 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.137 QASX
Saturating Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one
16-bit integer addition and one 16-bit subtraction, saturates the results to the 16-bit signed integer range
–215 ≤ x ≤ 215 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QASX<c> <Rd>, <Rn>, <Rm>
TOKENQASX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 1 0 Rn 1 1 1 1 Rd 0 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 0 Rn Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-547
ID051414 Non-Confidential
Assembler syntax
QASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax QADDSUBX<c> is equivalent to QASX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
sum = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
R[d]<15:0> = SignedSat(diff, 16);
R[d]<31:16> = SignedSat(sum, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-548 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.138 QDADD
Saturating Double and Add adds a doubled register value to another register value, and writes the result to the
destination register. Both the doubling and the addition have their results saturated to the 32-bit signed integer range
–231 ≤ x ≤ 231 – 1. If saturation occurs in either operation, it sets the Q flag in the APSR.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QDADD<c> <Rd>, <Rm>, <Rn>
TOKENQDADD<c> <Rd>, <Rm>, <Rn>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 1 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 0 0 1 0 1 0 0 Rn Rd (0) (0) (0) (0) 0 1 0 1 Rm
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-549
ID051414 Non-Confidential
Assembler syntax
QDADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The first operand register.
<Rn> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
(R[d], sat2) = SignedSatQ(SInt(R[m]) + SInt(doubled), 32);
if sat1 || sat2 then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-550 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.139 QDSUB
Saturating Double and Subtract subtracts a doubled register value from another register value, and writes the result
to the destination register. Both the doubling and the subtraction have their results saturated to the 32-bit signed
integer range –231 ≤ x ≤ 231 – 1. If saturation occurs in either operation, it sets the Q flag in the APSR.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QDSUB<c> <Rd>, <Rm>, <Rn>
TOKENQDSUB<c> <Rd>, <Rm>, <Rn>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 1 0 1 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 1 1 0 Rn Rd (0) (0) (0) (0) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-551
ID051414 Non-Confidential
Assembler syntax
QDSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The first operand register.
<Rn> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
(R[d], sat2) = SignedSatQ(SInt(R[m]) - SInt(doubled), 32);
if sat1 || sat2 then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-552 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.140 QSAX
Saturating Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one
16-bit integer subtraction and one 16-bit addition, saturates the results to the 16-bit signed integer range
–215 ≤ x ≤ 215 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QSAX<c> <Rd>, <Rn>, <Rm>
TOKENQSAX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 1 0 Rn 1 1 1 1 Rd 0 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 0 Rn Rd (1) (1) (1) (1) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-553
ID051414 Non-Confidential
Assembler syntax
QSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax QSUBADDX<c> is equivalent to QSAX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
R[d]<15:0> = SignedSat(sum, 16);
R[d]<31:16> = SignedSat(diff, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-554 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.141 QSUB
Saturating Subtract subtracts one register value from another register value, saturates the result to the 32-bit signed
integer range –231 ≤ x ≤ 231 – 1, and writes the result to the destination register. If saturation occurs, it sets the Q
flag in the APSR.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QSUB<c> <Rd>, <Rm>, <Rn>
TOKENQSUB<c> <Rd>, <Rm>, <Rn>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 1 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 Rn Rd (0) (0) (0) (0) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-555
ID051414 Non-Confidential
Assembler syntax
QSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The first operand register.
<Rn> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(R[d], sat) = SignedSatQ(SInt(R[m]) - SInt(R[n]), 32);
if sat then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-556 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.142 QSUB16
Saturating Subtract 16 performs two 16-bit integer subtractions, saturates the results to the 16-bit signed integer
range –215 ≤ x ≤ 215 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QSUB16<c> <Rd>, <Rn>, <Rm>
TOKENQSUB16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 1 Rn 1 1 1 1 Rd 0 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 0 Rn Rd (1) (1) (1) (1) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-557
ID051414 Non-Confidential
Assembler syntax
QSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
R[d]<15:0> = SignedSat(diff1, 16);
R[d]<31:16> = SignedSat(diff2, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-558 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.143 QSUB8
Saturating Subtract 8 performs four 8-bit integer subtractions, saturates the results to the 8-bit signed integer range
–27 ≤ x ≤ 27 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
QSUB8<c> <Rd>, <Rn>, <Rm>
TOKENQSUB8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 0 Rn 1 1 1 1 Rd 0 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 0 Rn Rd (1) (1) (1) (1) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-559
ID051414 Non-Confidential
Assembler syntax
QSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
R[d]<7:0> = SignedSat(diff1, 8);
R[d]<15:8> = SignedSat(diff2, 8);
R[d]<23:16> = SignedSat(diff3, 8);
R[d]<31:24> = SignedSat(diff4, 8);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-560 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.144 RBIT
Reverse Bits reverses the bit order in a 32-bit register.
if !Consistent(Rm) then UNPREDICTABLE;
d = UInt(Rd); m = UInt(Rm);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
RBIT<c> <Rd>, <Rm>
TOKENRBIT<c> <Rd>, <Rm>
1 1 1 1 0 1 0 1 0 0 1 Rm 1 1 1 1 Rd 1 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 1 1 (1) (1) (1) (1) Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-561
ID051414 Non-Confidential
Assembler syntax
RBIT{<c>}{<q>} <Rd>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand. In encoding T1, its number must be encoded twice.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
bits(32) result;
for i = 0 to 31
result<31-i> = R[m]<i>;
R[d] = result;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-562 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.145 REV
Byte-Reverse Word reverses the byte order in a 32-bit register.
d = UInt(Rd); m = UInt(Rm);
if !Consistent(Rm) then UNPREDICTABLE;
d = UInt(Rd); m = UInt(Rm);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7
REV<c> <Rd>, <Rm>
Encoding T2 ARMv6T2, ARMv7
REV<c>.W <Rd>, <Rm>
TOKENREV<c> <Rd>, <Rm>
1 0 1 1 1 0 1 0 0 0 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 1 0 0 1 Rm 1 1 1 1 Rd 1 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 1 (1) (1) (1) (1) Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-563
ID051414 Non-Confidential
Assembler syntax
REV{<c>}{<q>} <Rd>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand. Its number must be encoded twice in encoding T2.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
bits(32) result;
result<31:24> = R[m]<7:0>;
result<23:16> = R[m]<15:8>;
result<15:8> = R[m]<23:16>;
result<7:0> = R[m]<31:24>;
R[d] = result;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-564 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.146 REV16
Byte-Reverse Packed Halfword reverses the byte order in each16-bit halfword of a 32-bit register.
d = UInt(Rd); m = UInt(Rm);
if !Consistent(Rm) then UNPREDICTABLE;
d = UInt(Rd); m = UInt(Rm);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7
REV16<c> <Rd>, <Rm>
Encoding T2 ARMv6T2, ARMv7
REV16<c>.W <Rd>, <Rm>
TOKENREV16<c> <Rd>, <Rm>
1 0 1 1 1 0 1 0 0 1 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 1 0 0 1 Rm 1 1 1 1 Rd 1 0 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 1 (1) (1) (1) (1) Rd (1) (1) (1) (1) 1 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-565
ID051414 Non-Confidential
Assembler syntax
REV16{<c>}{<q>} <Rd>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand. Its number must be encoded twice in encoding T2.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
bits(32) result;
result<31:24> = R[m]<23:16>;
result<23:16> = R[m]<31:24>;
result<15:8> = R[m]<7:0>;
result<7:0> = R[m]<15:8>;
R[d] = result;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-566 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.147 REVSH
Byte-Reverse Signed Halfword reverses the byte order in the lower 16-bit halfword of a 32-bit register, and
sign-extends the result to 32 bits.
d = UInt(Rd); m = UInt(Rm);
if !Consistent(Rm) then UNPREDICTABLE;
d = UInt(Rd); m = UInt(Rm);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7
REVSH<c> <Rd>, <Rm>
Encoding T2 ARMv6T2, ARMv7
REVSH<c>.W <Rd>, <Rm>
TOKENREVSH<c> <Rd>, <Rm>
1 0 1 1 1 0 1 0 1 1 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 1 0 0 1 Rm 1 1 1 1 Rd 1 0 1 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 1 1 (1) (1) (1) (1) Rd (1) (1) (1) (1) 1 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-567
ID051414 Non-Confidential
Assembler syntax
REVSH{<c>}{<q>} <Rd>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand. Its number must be encoded twice in encoding T2.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
bits(32) result;
result<31:8> = SignExtend(R[m]<7:0>, 24);
result<7:0> = R[m]<15:8>;
R[d] = result;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-568 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.148 RFE
Return From Exception is a system instruction. For details see RFE on page B9-2000.
A8.8.149 ROR (immediate)
Rotate Right (immediate) provides the value of the contents of a register rotated by a constant value. The bits that
are rotated off the right end are inserted into the vacated bit positions on the left. It can optionally update the
condition flags based on the result.
if (imm3:imm2) == ‘00000’ then SEE RRX;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘11’, imm3:imm2);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
if imm5 == ‘00000’ then SEE RRX;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(-, shift_n) = DecodeImmShift(‘11’, imm5);
Encoding T1 ARMv6T2, ARMv7
ROR{S}<c> <Rd>, <Rm>, #<imm>
TOKENROR{S}<c> <Rd>, <Rm>, #<imm>
1 1 0 1 0 1 0 0 1 0 S 1 1 1 1 (0) imm3 Rd imm2 1 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd imm5 1 1 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-569
ID051414 Non-Confidential
Assembler syntax
ROR{S}{<c>}{<q>} {<Rd>,} <Rm>, #<imm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rm> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<imm> The shift amount, in the range 1 to 31. See Shifts applied to a register on page A8-291.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry) = Shift_C(R[m], SRType_ROR, shift_n, APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-570 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.150 ROR (register)
Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits
that are rotated off the right end are inserted into the vacated bit positions on the left. The variable number of bits is
read from the bottom byte of a register. It can optionally update the condition flags based on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
RORS <Rdn>, <Rm> Outside IT block.
ROR<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
ROR{S}<c>.W <Rd>, <Rn>, <Rm>
TOKENROR{S}<c> <Rd>, <Rn>, <Rm>
0 1 0 0 0 0 0 1 1 1 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 1 1 S Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd Rm 0 1 1 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-571
ID051414 Non-Confidential
Assembler syntax
ROR{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register whose bottom byte contains the amount to rotate by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[m]<7:0>);
(result, carry) = Shift_C(R[n], SRType_ROR, shift_n, APSR.C);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-572 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.151 RRX
Rotate Right with Extend provides the value of the contents of a register shifted right by one place, with the Carry
flag shifted into bit[31].
RRX can optionally update the condition flags based on the result. In that case, bit[0] is shifted into the Carry flag.
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
Encoding T1 ARMv6T2, ARMv7
RRX{S}<c> <Rd>, <Rm>
TOKENRRX{S}<c> <Rd>, <Rm>
1 1 0 1 0 1 0 0 1 0 S 1 1 1 1 (0) 0 0 0 Rd 0 0 1 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 S (0) (0) (0) (0) Rd 0 0 0 0 0 1 1 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-573
ID051414 Non-Confidential
Assembler syntax
RRX{S}{<c>}{<q>} {<Rd>,} <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rm> The register that contains the operand. The PC can be used in ARM instructions, but ARM
deprecates this use of the PC.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry) = Shift_C(R[m], SRType_RRX, 1, APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-574 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.152 RSB (immediate)
Reverse Subtract (immediate) subtracts a register value from an immediate value, and writes the result to the
destination register. It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); setflags = !InITBlock(); imm32 = Zeros(32); // immediate = #0
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ThumbExpandImm(i:imm3:imm8);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
RSBS <Rd>, <Rn>, #0 Outside IT block.
RSB<c> <Rd>, <Rn>, #0 Inside IT block.
Encoding T2 ARMv6T2, ARMv7
RSB{S}<c>.W <Rd>, <Rn>, #<const>
TOKENRSB{S}<c> <Rd>, <Rn>, #<const>
0 1 0 0 0 0 1 0 0 1 Rn Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 0 1 1 1 0 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 0 1 1 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-575
ID051414 Non-Confidential
Assembler syntax
RSB{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<const> The immediate value to be added to the value obtained from <Rn>. The only permitted value for
encoding T1 is 0. See Modified immediate constants in Thumb instructions on page A6-232 or
Modified immediate constants in ARM instructions on page A5-200 for the range of values for
encoding T2 or A1.
The pre-UAL syntax RSB<c>S is equivalent to RSBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(NOT(R[n]), imm32, ‘1’);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-576 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.153 RSB (register)
Reverse Subtract (register) subtracts a register value from an optionally-shifted register value, and writes the result
to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv6T2, ARMv7
RSB{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
TOKENRSB{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
1 1 0 1 0 1 1 1 1 0 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 1 1 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-577
ID051414 Non-Confidential
Assembler syntax
RSB{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
The pre-UAL syntax RSB<c>S is equivalent to RSBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(NOT(R[n]), shifted, ‘1’);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-578 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.154 RSB (register-shifted register)
Reverse Subtract (register-shifted register) subtracts a register value from a register-shifted register value, and
writes the result to the destination register. It can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENRSB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 0 0 1 1 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-579
ID051414 Non-Confidential
Assembler syntax
RSB{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax RSB<c>S is equivalent to RSBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(NOT(R[n]), shifted, ‘1’);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-580 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.155 RSC (immediate)
Reverse Subtract with Carry (immediate) subtracts a register value and the value of NOT (Carry flag) from an
immediate value, and writes the result to the destination register. It can optionally update the condition flags based
on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
TOKENRSC{S}<c> <Rd>, <Rn>, #<const>
cond 0 0 1 0 1 1 1 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-581
ID051414 Non-Confidential
Assembler syntax
RSC{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR and related
instructions (ARM) on page B9-2012.
<Rn> The first operand register. The PC can be used, but ARM deprecates this use of the PC.
<const> The immediate value that the value obtained from <Rn> is to be subtracted from. See Modified
immediate constants in ARM instructions on page A5-200 for the range of values.
The pre-UAL syntax RSC<c>S is equivalent to RSCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(NOT(R[n]), imm32, APSR.C);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-582 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.156 RSC (register)
Reverse Subtract with Carry (register) subtracts a register value and the value of NOT (Carry flag) from an
optionally-shifted register value, and writes the result to the destination register. It can optionally update the
condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
TOKENRSC{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
cond 0 0 0 0 1 1 1 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-583
ID051414 Non-Confidential
Assembler syntax
RSC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR and related
instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used, but ARM deprecates this use of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used, but ARM
deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
The pre-UAL syntax RSC<c>S is equivalent to RSCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(NOT(R[n]), shifted, APSR.C);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-584 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.157 RSC (register-shifted register)
Reverse Subtract (register-shifted register) subtracts a register value and the value of NOT (Carry flag) from a
register-shifted register value, and writes the result to the destination register. It can optionally update the condition
flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENRSC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 0 1 1 1 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-585
ID051414 Non-Confidential
Assembler syntax
RSC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax RSC<c>S is equivalent to RSCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(NOT(R[n]), shifted, APSR.C);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-586 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.158 SADD16
Signed Add 16 performs two 16-bit signed integer additions, and writes the results to the destination register. It sets
the APSR.GE bits according to the results of the additions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SADD16<c> <Rd>, <Rn>, <Rm>
TOKENSADD16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 1 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 0 1 Rn Rd (1) (1) (1) (1) 0 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-587
ID051414 Non-Confidential
Assembler syntax
SADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
R[d]<15:0> = sum1<15:0>;
R[d]<31:16> = sum2<15:0>;
APSR.GE<1:0> = if sum1 >= 0 then ‘11’ else ‘00’;
APSR.GE<3:2> = if sum2 >= 0 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-588 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.159 SADD8
Signed Add 8 performs four 8-bit signed integer additions, and writes the results to the destination register. It sets
the APSR.GE bits according to the results of the additions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SADD8<c> <Rd>, <Rn>, <Rm>
TOKENSADD8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 0 1 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-589
ID051414 Non-Confidential
Assembler syntax
SADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
R[d]<7:0> = sum1<7:0>;
R[d]<15:8> = sum2<7:0>;
R[d]<23:16> = sum3<7:0>;
R[d]<31:24> = sum4<7:0>;
APSR.GE<0> = if sum1 >= 0 then ‘1’ else ‘0’;
APSR.GE<1> = if sum2 >= 0 then ‘1’ else ‘0’;
APSR.GE<2> = if sum3 >= 0 then ‘1’ else ‘0’;
APSR.GE<3> = if sum4 >= 0 then ‘1’ else ‘0’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-590 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.160 SASX
Signed Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one 16-bit
integer addition and one 16-bit subtraction, and writes the results to the destination register. It sets the APSR.GE
bits according to the results.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SASX<c> <Rd>, <Rn>, <Rm>
TOKENSASX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 1 0 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 0 1 Rn Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-591
ID051414 Non-Confidential
Assembler syntax
SASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax SADDSUBX<c> is equivalent to SASX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
sum = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
R[d]<15:0> = diff<15:0>;
R[d]<31:16> = sum<15:0>;
APSR.GE<1:0> = if diff >= 0 then ‘11’ else ‘00’;
APSR.GE<3:2> = if sum >= 0 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-592 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.161 SBC (immediate)
Subtract with Carry (immediate) subtracts an immediate value and the value of NOT (Carry flag) from a register
value, and writes the result to the destination register. It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ThumbExpandImm(i:imm3:imm8);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
Encoding T1 ARMv6T2, ARMv7
SBC{S}<c> <Rd>, <Rn>, #<const>
TOKENSBC{S}<c> <Rd>, <Rn>, #<const>
1 1 1 0 i 0 1 0 1 1 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 1 1 0 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-593
ID051414 Non-Confidential
Assembler syntax
SBC{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<const> The immediate value to be subtracted from the value obtained from <Rn>. See Modified immediate
constants in Thumb instructions on page A6-232 or Modified immediate constants in ARM
instructions on page A5-200 for the range of values.
The pre-UAL syntax SBC<c>S is equivalent to SBCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], NOT(imm32), APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-594 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.162 SBC (register)
Subtract with Carry (register) subtracts an optionally-shifted register value and the value of NOT (Carry flag) from
a register value, and writes the result to the destination register. It can optionally update the condition flags based
on the result.
d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
SBCS <Rdn>, <Rm> Outside IT block.
SBC<c> <Rdn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
SBC{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
TOKENSBC{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 0 1 1 0 Rm Rdn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 0 1 1 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 1 1 0 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-595
ID051414 Non-Confidential
Assembler syntax
SBC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47. ARM deprecates this use of the PC.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
The pre-UAL syntax SBC<c>S is equivalent to SBCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], NOT(shifted), APSR.C);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-596 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.163 SBC (register-shifted register)
Subtract with Carry (register-shifted register) subtracts a register-shifted register value and the value of NOT (Carry
flag) from a register value, and writes the result to the destination register. It can optionally update the condition
flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENSBC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 0 1 1 0 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-597
ID051414 Non-Confidential
Assembler syntax
SBC{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax SBC<c>S is equivalent to SBCS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], NOT(shifted), APSR.C);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-598 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.164 SBFX
Signed Bit Field Extract extracts any number of adjacent bits at any position from a register, sign-extends them to
32 bits, and writes the result to the destination register.
d = UInt(Rd); n = UInt(Rn);
lsbit = UInt(imm3:imm2); widthminus1 = UInt(widthm1);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn);
lsbit = UInt(lsb); widthminus1 = UInt(widthm1);
if d == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SBFX<c> <Rd>, <Rn>, #<lsb>, #<width>
TOKENSBFX<c> <Rd>, <Rn>, #<lsb>, #<width>
1 1 1 0 (0) 1 1 0 1 0 0 Rn 0 imm3 Rd imm2 (0) widthm1
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 1 0 1 widthm1 Rd lsb 1 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-599
ID051414 Non-Confidential
Assembler syntax
SBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<lsb> is the bit number of the least significant bit in the field, in the range 0-31. This determines the
required value of lsbit.
<width> is the width of the field, in the range 1 to 32-<lsb>. The required value of widthminus1 is <width>-1.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
msbit = lsbit + widthminus1;
if msbit <= 31 then
R[d] = SignExtend(R[n]<msbit:lsbit>, 32);
else
UNPREDICTABLE;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-600 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.165 SDIV
Signed Divide divides a 32-bit signed integer register value by a 32-bit signed integer register value, and writes the
result to the destination register. The condition flags are not affected.
See ARMv7 implementation requirements and options for the divide instructions on page A4-172 for more
information about this instruction.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv7-R, ARMv7VE, otherwise OPTIONAL in ARMv7-A
SDIV<c> <Rd>, <Rn>, <Rm>
TOKENSDIV<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 0 0 1 Rn (1) (1) (1) (1) Rd 1 1 1 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 1 1 1 0 0 0 1 Rd (1) (1) (1) (1) Rm 0 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-601
ID051414 Non-Confidential
Assembler syntax
SDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The register that contains the dividend.
<Rm> The register that contains the divisor.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if SInt(R[m]) == 0 then
if IntegerZeroDivideTrappingEnabled() then
GenerateIntegerZeroDivide();
else
result = 0;
else
result = RoundTowardsZero(SInt(R[n]) / SInt(R[m]));
R[d] = result<31:0>;
Exceptions
In ARMv7-R profile, Undefined Instruction, see Divide instructions on page A4-172.
In ARMv7-A profile, none.
Overflow
If the signed integer division 0x80000000 / 0xFFFFFFFF is performed, the pseudocode produces the intermediate
integer result +231, that overflows the 32-bit signed integer range. No indication of this overflow case is produced,
and the 32-bit result written to R[d] must be the bottom 32 bits of the binary representation of +231. So the result of
the division is 0x80000000.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-602 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.166 SEL
Select Bytes selects each byte of its result from either its first operand or its second operand, according to the values
of the GE flags.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SEL<c> <Rd>, <Rn>, <Rm>
TOKENSEL<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 1 0 Rn 1 1 1 1 Rd 1 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 0 0 Rn Rd (1) (1) (1) (1) 1 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-603
ID051414 Non-Confidential
Assembler syntax
SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
R[d]<7:0> = if APSR.GE<0> == ‘1’ then R[n]<7:0> else R[m]<7:0>;
R[d]<15:8> = if APSR.GE<1> == ‘1’ then R[n]<15:8> else R[m]<15:8>;
R[d]<23:16> = if APSR.GE<2> == ‘1’ then R[n]<23:16> else R[m]<23:16>;
R[d]<31:24> = if APSR.GE<3> == ‘1’ then R[n]<31:24> else R[m]<31:24>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-604 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.167 SETEND
Set Endianness writes a new value to ENDIANSTATE.
set_bigend = (E == ‘1’);
if InITBlock() then UNPREDICTABLE;
set_bigend = (E == ‘1’);
Encoding T1 ARMv6*, ARMv7
SETEND <endian_specifier> Not permitted in IT block
TOKENSETEND <endian_specifier> Cannot be conditional
1 0 1 1 0 1 1 0 0 1 0 (1) E (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 0 1 0 0 0 0 (0) (0) (0) 1 (0) (0) (0) (0) (0) (0) E (0) 0 0 0 0 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-605
ID051414 Non-Confidential
Assembler syntax
SETEND{<q>} <endian_specifier>
where:
<q> See Standard assembler syntax fields on page A8-287. A SETEND instruction must be unconditional.
<endian_specifier>
Is one of:
BE Sets the E bit in the instruction. This sets ENDIANSTATE.
LE Clears the E bit in the instruction. This clears ENDIANSTATE.
Operation
EncodingSpecificOperations();
ENDIANSTATE = if set_bigend then ‘1’ else ‘0’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-606 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.168 SEV
Send Event is a hint instruction. It causes an event to be signaled to all processors in the multiprocessor system. For
more information, see Wait For Event and Send Event on page B1-1200.
// No additional decoding required
// No additional decoding required
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
// No additional decoding required
Encoding T1 ARMv7 (executes as NOP in ARMv6T2)
SEV<c>
Encoding T2 ARMv7 (executes as NOP in ARMv6T2)
SEV<c>.W
TOKENSEV<c>
1 0 1 1 1 1 1 1 0 1 0 0 0 0 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 1 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 1 0 0
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-607
ID051414 Non-Confidential
Assembler syntax
SEV{<c>}{<q>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
SendEvent();
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-608 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.169 SHADD16
Signed Halving Add 16 performs two signed 16-bit integer additions, halves the results, and writes the results to the
destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SHADD16<c> <Rd>, <Rn>, <Rm>
TOKENSHADD16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 1 Rn 1 1 1 1 Rd 0 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 1 Rn Rd (1) (1) (1) (1) 0 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-609
ID051414 Non-Confidential
Assembler syntax
SHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);
sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);
R[d]<15:0> = sum1<16:1>;
R[d]<31:16> = sum2<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-610 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.170 SHADD8
Signed Halving Add 8 performs four signed 8-bit integer additions, halves the results, and writes the results to the
destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SHADD8<c> <Rd>, <Rn>, <Rm>
TOKENSHADD8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 0 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 1 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-611
ID051414 Non-Confidential
Assembler syntax
SHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);
sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);
sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);
sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);
R[d]<7:0> = sum1<8:1>;
R[d]<15:8> = sum2<8:1>;
R[d]<23:16> = sum3<8:1>;
R[d]<31:24> = sum4<8:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-612 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.171 SHASX
Signed Halving Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one
signed 16-bit integer addition and one signed 16-bit subtraction, halves the results, and writes the results to the
destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SHASX<c> <Rd>, <Rn>, <Rm>
TOKENSHASX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 1 0 Rn 1 1 1 1 Rd 0 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 1 Rn Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-613
ID051414 Non-Confidential
Assembler syntax
SHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax SHADDSUBX<c> is equivalent to SHASX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);
sum = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);
R[d]<15:0> = diff<16:1>;
R[d]<31:16> = sum<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-614 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.172 SHSAX
Signed Halving Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one
signed 16-bit integer subtraction and one signed 16-bit addition, halves the results, and writes the results to the
destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SHSAX<c> <Rd>, <Rn>, <Rm>
TOKENSHSAX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 1 0 Rn 1 1 1 1 Rd 0 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 1 Rn Rd (1) (1) (1) (1) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-615
ID051414 Non-Confidential
Assembler syntax
SHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax SHSUBADDX<c> is equivalent to SHSAX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
R[d]<15:0> = sum<16:1>;
R[d]<31:16> = diff<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-616 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.173 SHSUB16
Signed Halving Subtract 16 performs two signed 16-bit integer subtractions, halves the results, and writes the results
to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SHSUB16<c> <Rd>, <Rn>, <Rm>
TOKENSHSUB16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 1 Rn 1 1 1 1 Rd 0 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 1 Rn Rd (1) (1) (1) (1) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-617
ID051414 Non-Confidential
Assembler syntax
SHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
R[d]<15:0> = diff1<16:1>;
R[d]<31:16> = diff2<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-618 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.174 SHSUB8
Signed Halving Subtract 8 performs four signed 8-bit integer subtractions, halves the results, and writes the results
to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SHSUB8<c> <Rd>, <Rn>, <Rm>
TOKENSHSUB8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 0 Rn 1 1 1 1 Rd 0 0 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 1 1 Rn Rd (1) (1) (1) (1) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-619
ID051414 Non-Confidential
Assembler syntax
SHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
R[d]<7:0> = diff1<8:1>;
R[d]<15:8> = diff2<8:1>;
R[d]<23:16> = diff3<8:1>;
R[d]<31:24> = diff4<8:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-620 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.175 SMC (previously SMI)
Secure Monitor Call is a system instruction. For details see SMC (previously SMI) on page B9-2002.
A8.8.176 SMLABB, SMLABT, SMLATB, SMLATT
Signed Multiply Accumulate (halfwords) performs a signed multiply accumulate operation. The multiply acts on
two signed 16-bit quantities, taken from either the bottom or the top half of their respective source registers. The
other halves of these source registers are ignored. The 32-bit product is added to a 32-bit accumulate value and the
result is written to the destination register.
If overflow occurs during the addition of the accumulate value, the instruction sets the Q flag in the APSR. It is not
possible for overflow to occur during the multiplication.
if Ra == ‘1111’ then SEE SMULBB, SMULBT, SMULTB, SMULTT;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
n_high = (N == ‘1’); m_high = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
n_high = (N == ‘1’); m_high = (M == ‘1’);
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENSMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 0 0 1 Rn Ra Rd 0 0 N M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 0 0 Rd Ra Rm 1 M N 0 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-621
ID051414 Non-Confidential
Assembler syntax
SMLA<x><y>{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
<x> Specifies which half of the source register <Rn> is used as the first multiply operand. If <x> is B, then
the bottom half (bits[15:0]) of <Rn> is used. If <x> is T, then the top half (bits[31:16]) of <Rn> is used.
<y> Specifies which half of the source register <Rm> is used as the second multiply operand. If <y> is B,
then the bottom half (bits[15:0]) of <Rm> is used. If <y> is T, then the top half (bits[31:16]) of <Rm> is
used.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The source register whose bottom or top half (selected by <x>) is the first multiply operand.
<Rm> The source register whose bottom or top half (selected by <y>) is the second multiply operand.
<Ra> The register that contains the accumulate value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
result = SInt(operand1) * SInt(operand2) + SInt(R[a]);
R[d] = result<31:0>;
if result != SInt(result<31:0>) then // Signed overflow
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-622 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.177 SMLAD
Signed Multiply Accumulate Dual performs two signed 16 × 16-bit multiplications. It adds the products to a 32-bit
accumulate operand.
Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This
produces top × bottom and bottom × top multiplication.
This instruction sets the Q flag if the accumulate operation overflows. Overflow cannot occur during the
multiplications.
if Ra == ‘1111’ then SEE SMUAD;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
m_swap = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Ra == ‘1111’ then SEE SMUAD;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
m_swap = (M == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENSMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 0 1 0 Rn Ra Rd 0 0 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 0 0 0 Rd Ra Rm 0 0 M 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-623
ID051414 Non-Confidential
Assembler syntax
SMLAD{X}{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
X If X is present (encoded as M = 1), the multiplications are bottom × top and top × bottom.
If the X is omitted (encoded as M = 0), the multiplications are bottom × bottom and top × top.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<Ra> The register that contains the accumulate value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
result = product1 + product2 + SInt(R[a]);
R[d] = result<31:0>;
if result != SInt(result<31:0>) then // Signed overflow
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-624 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.178 SMLAL
Signed Multiply Accumulate Long multiplies two signed 32-bit values to produce a 64-bit value, and accumulates
this with a 64-bit value.
In ARM instructions, the condition flags can optionally be updated based on the result. Use of this option adversely
affects performance on many processor implementations.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
if ArchVersion() < 6 && (dHi == n || dLo == n) then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENSMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 1 0 0 Rn RdLo RdHi 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 1 1 1 S RdHi RdLo Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-625
ID051414 Non-Confidential
Assembler syntax
SMLAL{S}{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
S can be specified only for the ARM instruction set.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Supplies the lower 32 bits of the accumulate value, and is the destination register for the lower 32
bits of the result.
<RdHi> Supplies the upper 32 bits of the accumulate value, and is the destination register for the upper 32
bits of the result.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax SMLAL<c>S is equivalent to SMLALS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = SInt(R[n]) * SInt(R[m]) + SInt(R[dHi]:R[dLo]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
if setflags then
APSR.N = result<63>;
APSR.Z = IsZeroBit(result<63:0>);
if ArchVersion() == 4 then
APSR.C = bit UNKNOWN;
APSR.V = bit UNKNOWN;
// else APSR.C, APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-626 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.179 SMLALBB, SMLALBT, SMLALTB, SMLALTT
Signed Multiply Accumulate Long (halfwords) multiplies two signed 16-bit values to produce a 32-bit value, and
accumulates this with a 64-bit value. The multiply acts on two signed 16-bit quantities, taken from either the bottom
or the top half of their respective source registers. The other halves of these source registers are ignored. The 32-bit
product is sign-extended and accumulated with a 64-bit accumulate value.
Overflow is possible during this instruction, but only as a result of the 64-bit addition. This overflow is not detected
if it occurs. Instead, the result wraps around modulo 264.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);
n_high = (N == ‘1’); m_high = (M == ‘1’);
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);
n_high = (N == ‘1’); m_high = (M == ‘1’);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENSMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 1 0 0 Rn RdLo RdHi 1 0 N M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 1 0 0 RdHi RdLo Rm 1 M N 0 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-627
ID051414 Non-Confidential
Assembler syntax
SMLAL<x><y>{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
<x> Specifies which half of the source register <Rn> is used as the first multiply operand. If <x> is B, then
the bottom half (bits[15:0]) of <Rn> is used. If <x> is T, then the top half (bits[31:16]) of <Rn> is used.
<y> Specifies which half of the source register <Rm> is used as the second multiply operand. If <y> is B,
then the bottom half (bits[15:0]) of <Rm> is used. If <y> is T, then the top half (bits[31:16]) of <Rm> is
used.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Supplies the lower 32 bits of the accumulate value, and is the destination register for the lower 32
bits of the result.
<RdHi> Supplies the upper 32 bits of the accumulate value, and is the destination register for the upper 32
bits of the result.
<Rn> The source register whose bottom or top half (selected by <x>) is the first multiply operand.
<Rm> The source register whose bottom or top half (selected by <y>) is the second multiply operand.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
result = SInt(operand1) * SInt(operand2) + SInt(R[dHi]:R[dLo]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-628 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.180 SMLALD
Signed Multiply Accumulate Long Dual performs two signed 16 × 16-bit multiplications. It adds the products to a
64-bit accumulate operand.
Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This
produces top × bottom and bottom × top multiplication.
Overflow is possible during this instruction, but only as a result of the 64-bit addition. This overflow is not detected
if it occurs. Instead, the result wraps around modulo 264.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENSMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 1 0 0 Rn RdLo RdHi 1 1 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 1 0 0 RdHi RdLo Rm 0 0 M 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-629
ID051414 Non-Confidential
Assembler syntax
SMLALD{X}{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
X If X is present, the multiplications are bottom × top and top × bottom.
If the X is omitted, the multiplications are bottom × bottom and top × top.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Supplies the lower 32 bits of the accumulate value, and is the destination register for the lower 32
bits of the result.
<RdHi> Supplies the upper 32 bits of the accumulate value, and is the destination register for the upper 32
bits of the result.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
result = product1 + product2 + SInt(R[dHi]:R[dLo]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-630 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.181 SMLAWB, SMLAWT
Signed Multiply Accumulate (word by halfword) performs a signed multiply accumulate operation. The multiply
acts on a signed 32-bit quantity and a signed 16-bit quantity. The signed 16-bit quantity is taken from either the
bottom or the top half of its source register. The other half of the second source register is ignored. The top 32 bits
of the 48-bit product are added to a 32-bit accumulate value and the result is written to the destination register. The
bottom 16 bits of the 48-bit product are ignored.
If overflow occurs during the addition of the accumulate value, the instruction sets the Q flag in the APSR. No
overflow can occur during the multiplication.
if Ra == ‘1111’ then SEE SMULWB, SMULWT;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); m_high = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); m_high = (M == ‘1’);
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENSMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 0 1 1 Rn Ra Rd 0 0 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 Rd Ra Rm 1 M 0 0 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-631
ID051414 Non-Confidential
Assembler syntax
SMLAW<y>{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
<y> Specifies which half of the source register <Rm> is used as the second multiply operand. If <y> is B,
then the bottom half (bits[15:0]) of <Rm> is used. If <y> is T, then the top half (bits[31:16]) of <Rm> is
used.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The source register whose bottom or top half (selected by <y>) is the second multiply operand.
<Ra> The register that contains the accumulate value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
result = SInt(R[n]) * SInt(operand2) + (SInt(R[a]) << 16);
R[d] = result<47:16>;
if (result >> 16) != SInt(R[d]) then // Signed overflow
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-632 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.182 SMLSD
Signed Multiply Subtract Dual performs two signed 16 × 16-bit multiplications. It adds the difference of the
products to a 32-bit accumulate operand.
Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This
produces top × bottom and bottom × top multiplication.
This instruction sets the Q flag if the accumulate operation overflows. Overflow cannot occur during the
multiplications or subtraction.
if Ra == ‘1111’ then SEE SMUSD;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); m_swap = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Ra == ‘1111’ then SEE SMUSD;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); m_swap = (M == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENSMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 1 0 0 Rn Ra Rd 0 0 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 0 0 0 Rd Ra Rm 0 1 M 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-633
ID051414 Non-Confidential
Assembler syntax
SMLSD{X}{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
X If X is present, the multiplications are bottom × top and top × bottom.
If the X is omitted, the multiplications are bottom × bottom and top × top.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<Ra> The register that contains the accumulate value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
result = product1 - product2 + SInt(R[a]);
R[d] = result<31:0>;
if result != SInt(result<31:0>) then // Signed overflow
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-634 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.183 SMLSLD
Signed Multiply Subtract Long Dual performs two signed 16 × 16-bit multiplications. It adds the difference of the
products to a 64-bit accumulate operand.
Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This
produces top × bottom and bottom × top multiplication.
Overflow is possible during this instruction, but only as a result of the 64-bit addition. This overflow is not detected
if it occurs. Instead, the result wraps around modulo 264.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENSMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 1 0 1 Rn RdLo RdHi 1 1 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 1 0 0 RdHi RdLo Rm 0 1 M 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-635
ID051414 Non-Confidential
Assembler syntax
SMLSLD{X}{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
X If X is present, the multiplications are bottom × top and top × bottom.
If the X is omitted, the multiplications are bottom × bottom and top × top.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Supplies the lower 32 bits of the accumulate value, and is the destination register for the lower 32
bits of the result.
<RdHi> Supplies the upper 32 bits of the accumulate value, and is the destination register for the upper 32
bits of the result.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
result = product1 - product2 + SInt(R[dHi]:R[dLo]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-636 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.184 SMMLA
Signed Most Significant Word Multiply Accumulate multiplies two signed 32-bit values, extracts the most
significant 32 bits of the result, and adds an accumulate value.
Optionally, the instruction can specify that the result is rounded instead of being truncated. In this case, the constant
0x80000000 is added to the product before the high word is extracted.
if Ra == ‘1111’ then SEE SMMUL;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); round = (R == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Ra == ‘1111’ then SEE SMMUL;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); round = (R == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENSMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 1 0 1 Rn Ra Rd 0 0 0 R Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 1 0 1 Rd Ra Rm 0 0 R 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-637
ID051414 Non-Confidential
Assembler syntax
SMMLA{R}{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
R If R is present, the multiplication is rounded.
If the R is omitted, the multiplication is truncated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The register that contains the first multiply operand.
<Rm> The register that contains the second multiply operand.
<Ra> The register that contains the accumulate value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = (SInt(R[a]) << 32) + SInt(R[n]) * SInt(R[m]);
if round then result = result + 0x80000000;
R[d] = result<63:32>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-638 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.185 SMMLS
Signed Most Significant Word Multiply Subtract multiplies two signed 32-bit values, subtracts the result from a
32-bit accumulate value that is shifted left by 32 bits, and extracts the most significant 32 bits of the result of that
subtraction.
Optionally, the instruction can specify that the result of the instruction is rounded instead of being truncated. In this
case, the constant 0x80000000 is added to the result of the subtraction before the high word is extracted.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); round = (R == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); round = (R == ‘1’);
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENSMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 1 1 0 Rn Ra Rd 0 0 0 R Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 1 0 1 Rd Ra Rm 1 1 R 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-639
ID051414 Non-Confidential
Assembler syntax
SMMLS{R}{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
R If R is present, the multiplication is rounded.
If the R is omitted, the multiplication is truncated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The register that contains the first multiply operand.
<Rm> The register that contains the second multiply operand.
<Ra> The register that contains the accumulate value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = (SInt(R[a]) << 32) - SInt(R[n]) * SInt(R[m]);
if round then result = result + 0x80000000;
R[d] = result<63:32>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-640 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.186 SMMUL
Signed Most Significant Word Multiply multiplies two signed 32-bit values, extracts the most significant 32 bits of
the result, and writes those bits to the destination register.
Optionally, the instruction can specify that the result is rounded instead of being truncated. In this case, the constant
0x80000000 is added to the product before the high word is extracted.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); round = (R == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); round = (R == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMMUL{R}<c> <Rd>, <Rn>, <Rm>
TOKENSMMUL{R}<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 0 1 0 1 Rn 1 1 1 1 Rd 0 0 0 R Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 1 0 1 Rd 1 1 1 1 Rm 0 0 R 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-641
ID051414 Non-Confidential
Assembler syntax
SMMUL{R}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
R If R is present, the multiplication is rounded.
If the R is omitted, the multiplication is truncated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = SInt(R[n]) * SInt(R[m]);
if round then result = result + 0x80000000;
R[d] = result<63:32>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-642 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.187 SMUAD
Signed Dual Multiply Add performs two signed 16 × 16-bit multiplications. It adds the products together, and writes
the result to the destination register.
Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This
produces top × bottom and bottom × top multiplication.
This instruction sets the Q flag if the addition overflows. The multiplications cannot overflow.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMUAD{X}<c> <Rd>, <Rn>, <Rm>
TOKENSMUAD{X}<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 0 0 1 0 Rn 1 1 1 1 Rd 0 0 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 0 0 0 Rd 1 1 1 1 Rm 0 0 M 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-643
ID051414 Non-Confidential
Assembler syntax
SMUAD{X}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
X If X is present, the multiplications are bottom × top and top × bottom.
If the X is omitted, the multiplications are bottom × bottom and top × top.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
result = product1 + product2;
R[d] = result<31:0>;
if result != SInt(result<31:0>) then // Signed overflow
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-644 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.188 SMULBB, SMULBT, SMULTB, SMULTT
Signed Multiply (halfwords) multiplies two signed 16-bit quantities, taken from either the bottom or the top half of
their respective source registers. The other halves of these source registers are ignored. The 32-bit product is written
to the destination register. No overflow is possible during this instruction.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
n_high = (N == ‘1’); m_high = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
n_high = (N == ‘1’); m_high = (M == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMUL<x><y><c> <Rd>, <Rn>, <Rm>
TOKENSMUL<x><y><c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 0 0 0 1 Rn 1 1 1 1 Rd 0 0 N M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 1 1 0 Rd (0) (0) (0) (0) Rm 1 M N 0 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-645
ID051414 Non-Confidential
Assembler syntax
SMUL<x><y>{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<x> Specifies which half of the source register <Rn> is used as the first multiply operand. If <x> is B, then
the bottom half (bits[15:0]) of <Rn> is used. If <x> is T, then the top half (bits[31:16]) of <Rn> is used.
<y> Specifies which half of the source register <Rm> is used as the second multiply operand. If <y> is B,
then the bottom half (bits[15:0]) of <Rm> is used. If <y> is T, then the top half (bits[31:16]) of <Rm> is
used.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The source register whose bottom or top half (selected by <x>) is the first multiply operand.
<Rm> The source register whose bottom or top half (selected by <y>) is the second multiply operand.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;
operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
result = SInt(operand1) * SInt(operand2);
R[d] = result<31:0>;
// Signed overflow cannot occur
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-646 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.189 SMULL
Signed Multiply Long multiplies two 32-bit signed values to produce a 64-bit result.
In ARM instructions, the condition flags can optionally be updated based on the result. Use of this option adversely
affects performance on many processor implementations.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
if ArchVersion() < 6 && (dHi == n || dLo == n) then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENSMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 0 0 0 Rn RdLo RdHi 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 1 1 0 S RdHi RdLo Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-647
ID051414 Non-Confidential
Assembler syntax
SMULL{S}{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
S can be specified only for the ARM instruction set.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Stores the lower 32 bits of the result.
<RdHi> Stores the upper 32 bits of the result.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax SMULL<c>S is equivalent to SMULLS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = SInt(R[n]) * SInt(R[m]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
if setflags then
APSR.N = result<63>;
APSR.Z = IsZeroBit(result<63:0>);
if ArchVersion() == 4 then
APSR.C = bit UNKNOWN;
APSR.V = bit UNKNOWN;
// else APSR.C, APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-648 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.190 SMULWB, SMULWT
Signed Multiply (word by halfword) multiplies a signed 32-bit quantity and a signed 16-bit quantity. The signed
16-bit quantity is taken from either the bottom or the top half of its source register. The other half of the second
source register is ignored. The top 32 bits of the 48-bit product are written to the destination register. The bottom
16 bits of the 48-bit product are ignored. No overflow is possible during this instruction.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_high = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_high = (M == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMULW<y><c> <Rd>, <Rn>, <Rm>
TOKENSMULW<y><c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 0 0 1 1 Rn 1 1 1 1 Rd 0 0 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 0 Rd (0) (0) (0) (0) Rm 1 M 1 0 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-649
ID051414 Non-Confidential
Assembler syntax
SMULW<y>{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<y> Specifies which half of the source register <Rm> is used as the second multiply operand. If <y> is B,
then the bottom half (bits[15:0]) of <Rm> is used. If <y> is T, then the top half (bits[31:16]) of <Rm> is
used.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The source register whose bottom or top half (selected by <y>) is the second multiply operand.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;
product = SInt(R[n]) * SInt(operand2);
R[d] = product<47:16>;
// Signed overflow cannot occur
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-650 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.191 SMUSD
Signed Multiply Subtract Dual performs two signed 16 × 16-bit multiplications. It subtracts one of the products from
the other, and writes the result to the destination register.
Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This
produces top × bottom and bottom × top multiplication.
Overflow cannot occur.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == ‘1’);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SMUSD{X}<c> <Rd>, <Rn>, <Rm>
TOKENSMUSD{X}<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 0 1 0 0 Rn 1 1 1 1 Rd 0 0 0 M Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 0 0 0 0 Rd 1 1 1 1 Rm 0 1 M 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-651
ID051414 Non-Confidential
Assembler syntax
SMUSD{X}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
X If X is present, the multiplications are bottom × top and top × bottom.
If the X is omitted, the multiplications are bottom × bottom and top × top.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);
product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);
result = product1 - product2;
R[d] = result<31:0>;
// Signed overflow cannot occur
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-652 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.192 SRS
Store Return State is a system instruction. For details see SRS (Thumb) on page B9-2004 and SRS (ARM) on
page B9-2006.
A8.8.193 SSAT
Signed Saturate saturates an optionally-shifted signed value to a selectable signed range.
The Q flag is set if the operation saturates.
if sh == ‘1’ && (imm3:imm2) == ‘00000’ then SEE SSAT16;
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;
(shift_t, shift_n) = DecodeImmShift(sh:’0’, imm3:imm2);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;
(shift_t, shift_n) = DecodeImmShift(sh:’0’, imm5);
if d == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SSAT<c> <Rd>, #<imm>, <Rn>{, <shift>}
TOKENSSAT<c> <Rd>, #<imm>, <Rn>{, <shift>}
1 1 1 0 (0) 1 1 0 0 sh 0 Rn 0 imm3 Rd imm2 (0) sat_imm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 sat_imm Rd imm5 sh 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-653
ID051414 Non-Confidential
Assembler syntax
SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, <shift>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<imm> The bit position for saturation, in the range 1 to 32. The sat_imm field of the instruction encodes this
bit position, by taking the value (<imm>-1).
<Rn> The register that contains the value to be saturated.
<shift> The optional shift, encoded in the sh bit and the immsh field, where immsh is:
• imm3:imm2 for encoding T1
• imm5 for encoding A1.
<shift> must be one of:
omitted No shift. Encoded as sh = 0, immsh = 0b00000.
LSL #<n> Left shift by <n> bits, with <n> in the range 1-31.
Encoded as sh = 0, immsh = <n>.
ASR #<n> Arithmetic right shift by <n> bits, with <n> in the range 1-31.
Encoded as sh = 1, immsh = <n>.
ASR #32 Arithmetic right shift by 32 bits, permitted only for encoding A1.
Encoded as sh = 1, immsh = 0b00000.
Note
An assembler can permit ASR #0 or LSL #0 to mean the same thing as omitting the shift, but this is
not standard UAL and must not be used for disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand = Shift(R[n], shift_t, shift_n, APSR.C); // APSR.C ignored
(result, sat) = SignedSatQ(SInt(operand), saturate_to);
R[d] = SignExtend(result, 32);
if sat then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-654 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.194 SSAT16
Signed Saturate 16 saturates two signed 16-bit values to a selected signed range.
The Q flag is set if the operation saturates.
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;
if d == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SSAT16<c> <Rd>, #<imm>, <Rn>
TOKENSSAT16<c> <Rd>, #<imm>, <Rn>
1 1 1 0 (0) 1 1 0 0 1 0 Rn 0 0 0 0 Rd 0 0 (0) (0) sat_imm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 0 sat_imm Rd (1) (1) (1) (1) 0 0 1 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-655
ID051414 Non-Confidential
Assembler syntax
SSAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<imm> The bit position for saturation, in the range 1 to 16. The sat_imm field of the instruction encodes this
bit position, by taking the value (<imm>-1).
<Rn> The register that contains the values to be saturated.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result1, sat1) = SignedSatQ(SInt(R[n]<15:0>), saturate_to);
(result2, sat2) = SignedSatQ(SInt(R[n]<31:16>), saturate_to);
R[d]<15:0> = SignExtend(result1, 16);
R[d]<31:16> = SignExtend(result2, 16);
if sat1 || sat2 then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-656 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.195 SSAX
Signed Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one 16-bit
integer subtraction and one 16-bit addition, and writes the results to the destination register. It sets the APSR.GE
bits according to the results.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SSAX<c> <Rd>, <Rn>, <Rm>
TOKENSSAX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 1 0 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 0 1 Rn Rd (1) (1) (1) (1) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-657
ID051414 Non-Confidential
Assembler syntax
SSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax SSUBADDX<c> is equivalent to SSAX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);
diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);
R[d]<15:0> = sum<15:0>;
R[d]<31:16> = diff<15:0>;
APSR.GE<1:0> = if sum >= 0 then ‘11’ else ‘00’;
APSR.GE<3:2> = if diff >= 0 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-658 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.196 SSUB16
Signed Subtract 16 performs two 16-bit signed integer subtractions, and writes the results to the destination register.
It sets the APSR.GE bits according to the results of the subtractions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SSUB16<c> <Rd>, <Rn>, <Rm>
TOKENSSUB16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 1 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 0 1 Rn Rd (1) (1) (1) (1) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-659
ID051414 Non-Confidential
Assembler syntax
SSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);
diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);
R[d]<15:0> = diff1<15:0>;
R[d]<31:16> = diff2<15:0>;
APSR.GE<1:0> = if diff1 >= 0 then ‘11’ else ‘00’;
APSR.GE<3:2> = if diff2 >= 0 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-660 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.197 SSUB8
Signed Subtract 8 performs four 8-bit signed integer subtractions, and writes the results to the destination register.
It sets the APSR.GE bits according to the results of the subtractions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SSUB8<c> <Rd>, <Rn>, <Rm>
TOKENSSUB8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 0 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 0 0 1 Rn Rd (1) (1) (1) (1) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-661
ID051414 Non-Confidential
Assembler syntax
SSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);
diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);
diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);
diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);
R[d]<7:0> = diff1<7:0>;
R[d]<15:8> = diff2<7:0>;
R[d]<23:16> = diff3<7:0>;
R[d]<31:24> = diff4<7:0>;
APSR.GE<0> = if diff1 >= 0 then ‘1’ else ‘0’;
APSR.GE<1> = if diff2 >= 0 then ‘1’ else ‘0’;
APSR.GE<2> = if diff3 >= 0 then ‘1’ else ‘0’;
APSR.GE<3> = if diff4 >= 0 then ‘1’ else ‘0’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-662 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.198 STC, STC2
Store Coprocessor stores data from a coprocessor to a sequence of consecutive memory addresses. If no coprocessor
can execute the instruction, an Undefined Instruction exception is generated.
This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and
are free for use by the coprocessor instruction set designer. These are the D bit, the CRd field, and in the Unindexed
addressing mode only, the imm8 field. However, coprocessors CP8-CP15 are reserved for use by ARM, and this
manual defines the valid STC and STC2 instructions when coproc is in the range p8-p15. For more information see
Coprocessor support on page A2-94 and General behavior of system control registers on page B5-1776.
In an implementation that includes the Virtualization Extensions, the permitted STC access to a system control
register can be trapped to Hyp mode, meaning that an attempt to execute an STC instruction in a Non-secure mode
other than Hyp mode, that would be permitted in the absence of the Hyp trap controls, generates a Hyp Trap
exception. For more information, see Trapping general CP14 accesses to debug registers on page B1-1261.
Note
For simplicity, the STC pseudocode does not show this possible trap to Hyp mode.
For the case when cond is 0b1111, see the T2/A2 encoding.
if P == ‘0’ && U == ‘0’ && D == ‘0’ && W == ‘0’ then UNDEFINED;
if P == ‘0’ && U == ‘0’ && D == ‘1’ && W == ‘0’ then SEE MCRR, MCRR2;
if coproc IN “101x” then SEE “Advanced SIMD and Floating-point”;
n = UInt(Rn); cp = UInt(coproc);
imm32 = ZeroExtend(imm8:’00’, 32); index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if n == 15 && (wback || CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if P == ‘0’ && U == ‘0’ && D == ‘0’ && W == ‘0’ then UNDEFINED;
if P == ‘0’ && U == ‘0’ && D == ‘1’ && W == ‘0’ then SEE MCRR, MCRR2;
if coproc IN “101x” then UNDEFINED;
n = UInt(Rn); cp = UInt(coproc);
imm32 = ZeroExtend(imm8:’00’, 32); index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if n == 15 && (wback || CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
Encoding T1/A1 ARMv6T2, ARMv7 for encoding T1
ARMv4*, ARMv5T*, ARMv6*, ARMv7 for encoding A1
STC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}
STC{L}<c> <coproc>, <CRd>, [<Rn>], #+/-<imm>
STC{L}<c> <coproc>, <CRd>, [<Rn>], <option>
Encoding T2/A2 ARMv6T2, ARMv7 for encoding T2
ARMv5T*, ARMv6*, ARMv7 for encoding A2
STC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}
STC2{L}<c> <coproc>, <CRd>, [<Rn>], #+/-<imm>
STC2{L}<c> <coproc>, <CRd>, [<Rn>], <option>
1 1 0 1 1 0 P U D W 0 Rn CRd coproc imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 P U D W 0 Rn CRd coproc imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 P U D W 0 Rn CRd coproc imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 1 0 P U D W 0 Rn CRd coproc imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-663
ID051414 Non-Confidential
Assembler syntax
where:
2 If specified, selects encoding T2/A2. If omitted, selects encoding T1/A1.
L If specified, selects the D == 1 form of the encoding. If omitted, selects the D == 0 form.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM STC2 instruction must be
unconditional.
<coproc> The name of the coprocessor. The generic coprocessor names are p0-p15.
<CRd> The coprocessor source register.
<Rn> The base register. The SP can be used. In the ARM instruction set, for offset and unindexed
addressing only, the PC can be used. However, ARM deprecates use of the PC.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are multiples of 4 in the range 0-1020.
For the offset addressing syntax, <imm> can be omitted, meaning an offset of +0.
<option> A coprocessor option. An integer in the range 0-255 enclosed in { }. Encoded in imm8.
The pre-UAL syntax STC<c>L is equivalent to STCL<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if !Coproc_Accepted(cp, ThisInstr()) then
GenerateCoprocessorException();
else
NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
repeat
MemA[address,4] = Coproc_GetWordToStore(cp, ThisInstr());
address = address + 4;
until Coproc_DoneStoring(cp, ThisInstr());
if wback then R[n] = offset_addr;
Exceptions
Undefined Instruction, Data Abort, Hyp Trap.
Uses of these instructions by specific coprocessors might generate other exceptions.
Advanced SIMD and Floating-point See Extension register load/store instructions on page A7-274
STC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #+/-<imm>}] Offset. P = 1, W = 0.
STC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #+/-<imm>]! Pre-indexed. P = 1, W = 1.
STC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #+/-<imm> Post-indexed. P = 0, W = 1.
STC{2}{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option> Unindexed. P = 0, W = 0, U = 1.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-664 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.199 STM (STMIA, STMEA)
Store Multiple Increment After (Store Multiple Empty Ascending) stores multiple registers to consecutive memory
locations using an address from a base register. The consecutive memory locations start at this address, and the
address just above the last of those locations can optionally be written back to the base register.
For details of related system instructions see STM (User registers) on page B9-2008.
if CurrentInstrSet() == InstrSet_ThumbEE then SEE “ThumbEE instructions”;
n = UInt(Rn); registers = ‘00000000’:register_list; wback = TRUE;
if BitCount(registers) < 1 then UNPREDICTABLE;
n = UInt(Rn); registers = ‘0’:M:’0’:register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
if wback && registers<n> == ‘1’ then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7 (not in ThumbEE)
STM<c> <Rn>!, <registers>
Encoding T2 ARMv6T2, ARMv7
STM<c>.W <Rn>{!}, <registers>
TOKENSTM<c> <Rn>{!}, <registers>
ThumbEE instructions See 16-bit ThumbEE instructions on page A9-1115.
1 1 0 0 0 Rn register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 0 0 1 0 W 0 Rn (0) M (0) register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 0 0 0 1 0 W 0 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-665
ID051414 Non-Confidential
Assembler syntax
STM{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. The SP can be used.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The
lowest-numbered register is stored to the lowest memory address, through to the highest-numbered
register to the highest memory address. See also Encoding of lists of ARM core registers on
page A8-295.
Encoding T2 does not support a list containing only one register. If an STM instruction with just one
register <Rt> in the list is assembled to Thumb and encoding T1 is not available, it is assembled to
the equivalent STR{<c>}{<q>} <Rt>, [<Rn>]{, #4} instruction.
The SP and PC can be in the list in ARM instructions, but not in Thumb instructions. However,
ARM deprecates the use of ARM instructions that include the SP or the PC in the list.
ARM deprecates the use of instructions with the base register in the list and ! specified. If the base
register is not the lowest-numbered register in the list, such an instruction stores an UNKNOWN value
for the base register.
An instruction with the base register in the list and ! specified cannot use encoding T2.
STMEA and STMIA are pseudo-instructions for STM. STMEA refers to its use for pushing data onto Empty Ascending
stacks.
The pre-UAL syntaxes STM<c>IA and STM<c>EA are equivalent to STM<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
for i = 0 to 14
if registers<i> == ‘1’ then
if i == n && wback && i != LowestSetBit(registers) then
MemA[address,4] = bits(32) UNKNOWN; // Only possible for encodings T1 and A1
else
MemA[address,4] = R[i];
address = address + 4;
if registers<15> == ‘1’ then // Only possible for encoding A1
MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] + 4*BitCount(registers);
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-666 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.200 STMDA (STMED)
Store Multiple Decrement After (Store Multiple Empty Descending) stores multiple registers to consecutive
memory locations using an address from a base register. The consecutive memory locations end at this address, and
the address just below the lowest of those locations can optionally be written back to the base register.
For details of related system instructions see STM (User registers) on page B9-2008.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
TOKENSTMDA<c> <Rn>{!}, <registers>
cond 1 0 0 0 0 0 W 0 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-667
ID051414 Non-Confidential
Assembler syntax
STMDA{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. The SP can be used.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The
lowest-numbered register is stored to the lowest memory address, through to the highest-numbered
register to the highest memory address. See also Encoding of lists of ARM core registers on
page A8-295.
The SP and PC can be in the list. However, ARM deprecates the use of instructions that include the
SP or the PC in the list.
ARM deprecates the use of instructions with the base register in the list and ! specified. If the base
register is not the lowest-numbered register in the list, such an instruction stores an UNKNOWN value
for the base register.
STMED is s pseudo-instruction for STMDA, referring to its use for pushing data onto Empty Descending stacks.
The pre-UAL syntaxes STM<c>DA and STM<c>ED are equivalent to STMDA<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
address = R[n] - 4*BitCount(registers) + 4;
for i = 0 to 14
if registers<i> == ‘1’ then
if i == n && wback && i != LowestSetBit(registers) then
MemA[address,4] = bits(32) UNKNOWN;
else
MemA[address,4] = R[i];
address = address + 4;
if registers<15> == ‘1’ then
MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] - 4*BitCount(registers);
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-668 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.201 STMDB (STMFD)
Store Multiple Decrement Before (Store Multiple Full Descending) stores multiple registers to consecutive memory
locations using an address from a base register. The consecutive memory locations end just below this address, and
the address of the first of those locations can optionally be written back to the base register.
For details of related system instructions see STM (User registers) on page B9-2008.
if W == ‘1’ && Rn == ‘1101’ then SEE PUSH;
n = UInt(Rn); registers = ‘0’:M:’0’:register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
if wback && registers<n> == ‘1’ then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if W == ‘1’ && Rn == ‘1101’ && BitCount(register_list) >= 2 then SEE PUSH;
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
STMDB<c> <Rn>{!}, <registers>
TOKENSTMDB<c> <Rn>{!}, <registers>
1 1 0 1 0 0 1 0 0 W 0 Rn (0) M (0) register_list
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 0 0 1 0 0 W 0 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-669
ID051414 Non-Confidential
Assembler syntax
STMDB{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. The SP can be used. If the SP is used, and ! is specified:
• for encoding T1, it is treated as described in PUSH on page A8-538
• for encoding A1, if there is more than one register in the <registers> list, it is treated as
described in PUSH on page A8-538.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The
lowest-numbered register is stored to the lowest memory address, through to the highest-numbered
register to the highest memory address. See also Encoding of lists of ARM core registers on
page A8-295.
Encoding T1 does not support a list containing only one register. If an STMDB instruction with just
one register <Rt> in the list is assembled to Thumb, it is assembled to the equivalent STR{<c>}{<q>}
<Rt>, [<Rn>, #-4]{!} instruction.
The SP and PC can be in the list in ARM instructions, but not in Thumb instructions. However,
ARM deprecates the use of ARM instructions that include the SP or the PC in the list.
Instructions with the base register in the list and ! specified are only available in the ARM
instruction set, and ARM deprecates the use of such instructions. If the base register is not the
lowest-numbered register in the list, such an instruction stores an UNKNOWN value for the base
register.
STMFD is a pseudo-instruction for STMDB, referring to its use for pushing data onto Full Descending stacks.
The pre-UAL syntaxes STM<c>DB and STM<c>FD are equivalent to STMDB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n] - 4*BitCount(registers);
for i = 0 to 14
if registers<i> == ‘1’ then
if i == n && wback && i != LowestSetBit(registers) then
MemA[address,4] = bits(32) UNKNOWN; // Only possible for encoding A1
else
MemA[address,4] = R[i];
address = address + 4;
if registers<15> == ‘1’ then // Only possible for encoding A1
MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] - 4*BitCount(registers);
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-670 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.202 STMIB (STMFA)
Store Multiple Increment Before (Store Multiple Full Ascending) stores multiple registers to consecutive memory
locations using an address from a base register. The consecutive memory locations start just above this address, and
the address of the last of those locations can optionally be written back to the base register.
For details of related system instructions see STM (User registers) on page B9-2008.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); registers = register_list; wback = (W == ‘1’);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
TOKENSTMIB<c> <Rn>{!}, <registers>
cond 1 0 0 1 1 0 W 0 Rn register_list
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-671
ID051414 Non-Confidential
Assembler syntax
STMIB{<c>}{<q>} <Rn>{!}, <registers>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. The SP can be used.
! Causes the instruction to write a modified value back to <Rn>. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<registers> Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The
lowest-numbered register is stored to the lowest memory address, through to the highest-numbered
register to the highest memory address. See also Encoding of lists of ARM core registers on
page A8-295.
The SP and PC can be in the list. However, ARM deprecates the use of instructions that include the
SP or the PC in the list.
ARM deprecates the use of instructions with the base register in the list and ! specified. If the base
register is not the lowest-numbered register in the list, such an instruction stores an UNKNOWN value
for the base register.
STMFA is a pseudo-instruction for STMIB, referring to its use for pushing data onto Full Ascending stacks.
The pre-UAL syntax STM<c>IB and STM<c>FA are equivalent to STMIB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
address = R[n] + 4;
for i = 0 to 14
if registers<i> == ‘1’ then
if i == n && wback && i != LowestSetBit(registers) then
MemA[address,4] = bits(32) UNKNOWN;
else
MemA[address,4] = R[i];
address = address + 4;
if registers<15> == ‘1’ then
MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] + 4*BitCount(registers);
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-672 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.203 STR (immediate, Thumb)
Store Register (immediate) calculates an address from a base register value and an immediate offset, and stores a
word from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about
memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm5:’00’, 32);
index = TRUE; add = TRUE; wback = FALSE;
t = UInt(Rt); n = 13; imm32 = ZeroExtend(imm8:’00’, 32);
index = TRUE; add = TRUE; wback = FALSE;
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = TRUE; add = TRUE; wback = FALSE;
if t == 15 then UNPREDICTABLE;
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE STRT;
if Rn == ‘1101’ && P == ‘1’ && U == ‘0’ && W == ‘1’ && imm8 == ‘00000100’ then SEE PUSH;
if Rn == ‘1111’ || (P == ‘0’ && W == ‘0’) then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if t == 15 || (wback && n == t) then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
STR<c> <Rt>, [<Rn>{, #<imm>}]
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
STR<c> <Rt>, [SP, #<imm>]
Encoding T3 ARMv6T2, ARMv7
STR<c>.W <Rt>, [<Rn>, #<imm12>]
Encoding T4 ARMv6T2, ARMv7
STR<c> <Rt>, [<Rn>, #-<imm8>]
STR<c> <Rt>, [<Rn>], #+/-<imm8>
STR<c> <Rt>, [<Rn>, #+/-<imm8>]!
0 1 1 0 0 imm5 Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 0 0 1 0 Rt imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 1 1 0 0 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 1 0 0 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-673
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register. The SP can be used.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are:
Encoding T1 multiples of 4 in the range 0-124
Encoding T2 multiples of 4 in the range 0-1020
Encoding T3 any value in the range 0-4095
Encoding T4 any value in the range 0-255.
For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
if UnalignedSupport() || address<1:0> == ‘00’ then
MemU[address,4] = R[t];
else // Can only occur before ARMv7
MemU[address,4] = bits(32) UNKNOWN;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
ThumbEE instruction
ThumbEE has an additional STR (immediate) encoding. For details see STR (immediate) on page A9-1130.
STR{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
STR{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
STR{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-674 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.204 STR (immediate, ARM)
Store Register (immediate) calculates an address from a base register value and an immediate offset, and stores a
word from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about
memory accesses see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE STRT;
if Rn == ‘1101’ && P == ‘1’ && U == ‘0’ && W == ‘1’ && imm12 == ‘000000000100’ then SEE PUSH;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if wback && (n == 15 || n == t) then UNPREDICTABLE;
TOKENSTR<c> <Rt>, [<Rn>{, #+/-<imm12>}]
STR<c> <Rt>, [<Rn>], #+/-<imm12>
STR<c> <Rt>, [<Rn>, #+/-<imm12>]!
cond 0 1 0 P U 0 W 0 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-675
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register. The SP or the PC can be used. However, ARM deprecates use of the PC.
<Rn> The base register. The SP can be used. For offset addressing only, the PC can be used. However,
ARM deprecates use of the PC.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Any value in the range 0-4095 is permitted. For
the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
MemU[address,4] = if t == 15 then PCStoreValue() else R[t];
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STR{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
STR{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
STR{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-676 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.205 STR (register)
Store Register (register) calculates an address from a base register value and an offset register value, stores a word
from a register to memory. The offset register value can optionally be shifted. For information about memory
accesses see Memory accesses on page A8-294.
if CurrentInstrSet() == InstrSet_ThumbEE then SEE “Modified operation in ThumbEE”;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 15 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE STRT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
if m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
STR<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
STR<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENSTR<c> <Rt>, [<Rn>,+/-<Rm>{, <shift>}]{!}
STR<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
Modified operation in ThumbEE See STR (register) on page A9-1121
0 1 0 1 0 0 0 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 1 0 0 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 P U 0 W 0 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-677
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register. The SP can be used. In the ARM instruction set, the PC can be used. However,
ARM deprecates use of the PC.
<Rn> The base register. The SP can be used. In the ARM instruction set, for offset addressing only, the
PC can be used. However, ARM deprecates use of the PC.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally shifted and added to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. For encoding T2, <shift> can only be omitted,
encoded as imm2 = 0b00, or LSL #<imm> with <imm> = 1, 2, or 3, and <imm> encoded in imm2. For
TOKENOperation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
if t == 15 then // Only possible for encoding A1
data = PCStoreValue();
else
data = R[t];
if UnalignedSupport() || address<1:0> == ‘00’ || CurrentInstrSet() == InstrSet_ARM then
MemU[address,4] = data;
else // Can only occur before ARMv7
MemU[address,4] = bits(32) UNKNOWN;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STR{<c>}{<q>} <Rt>, [<Rn>, <Rm>{, <shift>}] Offset: index==TRUE, wback==FALSE
STR{<c>}{<q>} <Rt>, [<Rn>, <Rm>{, <shift>}]! Pre-indexed: index==TRUE, wback==TRUE
STR{<c>}{<q>} <Rt>, [<Rn>], <Rm>{, <shift>} Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-678 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.206 STRB (immediate, Thumb)
Store Register Byte (immediate) calculates an address from a base register value and an immediate offset, and stores
a byte from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about
memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm5, 32);
index = TRUE; add = TRUE; wback = FALSE;
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = TRUE; add = TRUE; wback = FALSE;
if t IN {13,15} then UNPREDICTABLE;
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE STRBT;
if Rn == ‘1111’ || (P == ‘0’ && W == ‘0’) then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if t IN {13,15} || (wback && n == t) then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
STRB<c> <Rt>, [<Rn>, #<imm5>]
Encoding T2 ARMv6T2, ARMv7
STRB<c>.W <Rt>, [<Rn>, #<imm12>]
Encoding T3 ARMv6T2, ARMv7
STRB<c> <Rt>, [<Rn>, #-<imm8>]
STRB<c> <Rt>, [<Rn>], #+/-<imm8>
STRB<c> <Rt>, [<Rn>, #+/-<imm8>]!
0 1 1 1 0 imm5 Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 1 0 0 0 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 0 0 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-679
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are:
Encoding T1 any value in the range 0-31
Encoding T2 any value in the range 0-4095
Encoding T3 any value in the range 0-255.
For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.
The pre-UAL syntax STR<c>B is equivalent to STRB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
MemU[address,1] = R[t]<7:0>;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRB{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
STRB{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
STRB{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-680 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.207 STRB (immediate, ARM)
Store Register Byte (immediate) calculates an address from a base register value and an immediate offset, and stores
a byte from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about
memory accesses see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE STRBT;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if t == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
TOKENSTRB<c> <Rt>, [<Rn>{, #+/-<imm12>}]
STRB<c> <Rt>, [<Rn>], #+/-<imm12>
STRB<c> <Rt>, [<Rn>, #+/-<imm12>]!
cond 0 1 0 P U 1 W 0 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-681
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used. For offset addressing only, the PC can be used. However,
ARM deprecates use of the PC.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are 0-4095. For the offset addressing
syntax, <imm> can be omitted, meaning an offset of 0.
The pre-UAL syntax STR<c>B is equivalent to STRB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
MemU[address,1] = R[t]<7:0>;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRB{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
STRB{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
STRB{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-682 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.208 STRB (register)
Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores
a byte from a register to memory. The offset register value can optionally be shifted. For information about memory
accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE STRBT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
STRB<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
STRB<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENSTRB<c> <Rt>, [<Rn>,+/-<Rm>{, <shift>}]{!}
STRB<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
0 1 0 1 0 1 0 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 0 0 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 P U 1 W 0 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-683
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used. In the ARM instruction set, for offset addressing only, the
PC can be used. However, ARM deprecates use of the PC.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally shifted and added to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. For encoding T2, <shift> can only be omitted,
encoded as imm2 = 0b00, or LSL #<imm> with <imm> = 1, 2, or 3, and <imm> encoded in imm2. For
TOKENThe pre-UAL syntax STR<c>B is equivalent to STRB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
MemU[address,1] = R[t]<7:0>;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRB{<c>}{<q>} <Rt>, [<Rn>, <Rm>{, <shift>}] Offset: index==TRUE, wback==FALSE
STRB{<c>}{<q>} <Rt>, [<Rn>, <Rm>{, <shift>}]! Pre-indexed: index==TRUE, wback==TRUE
STRB{<c>}{<q>} <Rt>, [<Rn>], <Rm>{, <shift>} Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-684 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.209 STRBT
Store Register Byte Unprivileged stores a byte from a register to memory. For information about memory accesses
see Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
STRBT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or an optionally-shifted register value.
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm12, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;
if ArchVersion() < 6 && m == n then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
STRBT<c> <Rt>, [<Rn>, #<imm8>]
TOKENSTRBT<c> <Rt>, [<Rn>], #+/-<imm12>
Encoding A2 ARMv4*, ARMv5T*, ARMv6*, ARMv7
STRBT<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
1 1 1 1 0 0 0 0 0 0 0 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 0 U 1 1 0 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 U 1 1 0 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-685
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<imm> The immediate offset applied to the value of <Rn>. Values are 0-255 for encoding T1, and 0-4095 for
TOKEN<Rm> Contains the offset that is optionally shifted and added to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
The pre-UAL syntax STR<c>BT is equivalent to STRBT<c>.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then Shift(R[m], shift_t, shift_n, APSR.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
MemU_unpriv[address,1] = R[t]<7:0>;
if postindex then R[n] = offset_addr;
Exceptions
Data Abort.
STRBT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
STRBT{<c>}{<q>} <Rt>, [<Rn>] {, #<imm>} Post-indexed: ARM only
STRBT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> {, <shift>} Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-686 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.210 STRD (immediate)
Store Register Dual (immediate) calculates an address from a base register value and an immediate offset, and stores
two words from two registers to memory. It can use offset, post-indexed, or pre-indexed addressing. For information
about memory accesses see Memory accesses on page A8-294.
if P == ‘0’ && W == ‘0’ then SEE “Related encodings”;
t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn); imm32 = ZeroExtend(imm8:’00’, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if wback && (n == t || n == t2) then UNPREDICTABLE;
if n == 15 || t IN {13,15} || t2 IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rt<0> == ‘1’ then UNPREDICTABLE;
t = UInt(Rt); t2 = t+1; n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if P == ‘0’ && W == ‘1’ then UNPREDICTABLE;
if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;
if t2 == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
STRD<c> <Rt>, <Rt2>, [<Rn>{, #+/-<imm>}]
STRD<c> <Rt>, <Rt2>, [<Rn>], #+/-<imm>
STRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]!
TOKENSTRD<c> <Rt>, <Rt2>, [<Rn>{, #+/-<imm8>}]
STRD<c> <Rt>, <Rt2>, [<Rn>], #+/-<imm8>
STRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm8>]!
Related encodings See Load/store dual, load/store exclusive, table branch on page A6-238.
1 1 0 1 0 0 P U 1 W 0 Rn Rt Rt2 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 1 W 0 Rn Rt imm4H 1 1 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-687
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The first source register. For an ARM instruction, <Rt> must be even-numbered and not R14.
<Rt2> The second source register. For an ARM instruction, <Rt2> must be <R(t+1)>.
<Rn> The base register. The SP can be used. In the ARM instruction set, for offset addressing only, the
PC can be used. However, ARM deprecates use of the PC.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are multiples of 4 in the range 0-1020
for encoding T1, and any value in the range 0-255 for encoding A1. For the offset addressing syntax,
<imm> can be omitted, meaning an offset of 0.
The pre-UAL syntax STR<c>D is equivalent to STRD<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
if HaveLPAE() && address<2:0> == ‘000’ then
bits(64) data;
if BigEndian() then
data<63:32> = R[t];
data<31:0> = R[t2];
else
data<31:0> = R[t];
data<63:32> = R[t2];
MemA[address,8] = data;
else
MemA[address,4] = R[t];
MemA[address+4,4] = R[t2];
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-688 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.211 STRD (register)
Store Register Dual (register) calculates an address from a base register value and a register offset, and stores two
words from two registers to memory. It can use offset, post-indexed, or pre-indexed addressing. For information
about memory accesses see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rt<0> == ‘1’ then UNPREDICTABLE;
t = UInt(Rt); t2 = t+1; n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if P == ‘0’ && W == ‘1’ then UNPREDICTABLE;
if t2 == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
TOKENSTRD<c> <Rt>, <Rt2>, [<Rn>,+/-<Rm>]{!}
STRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm>
cond 0 0 0 P U 0 W 0 Rn Rt (0) (0) (0) (0) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-689
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The first source register. This register must be even-numbered and not R14.
<Rt2> The second source register. This register must be <R(t+1)>.
<Rn> The base register. The SP can be used. For offset addressing only, the PC can be used. However,
ARM deprecates use of the PC.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE).
<Rm> Contains the offset that is added to the value of <Rn> to form the address.
The pre-UAL syntax STR<c>D is equivalent to STRD<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
address = if index then offset_addr else R[n];
if HaveLPAE() && address<2:0> == ‘000’ then
bits(64) data;
if BigEndian() then
data<63:32> = R[t];
data<31:0> = R[t2];
else
data<31:0> = R[t];
data<63:32> = R[t2];
MemA[address,8] = data;
else
MemA[address,4] = R[t];
MemA[address+4,4] = R[t2];
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, +/-<Rm>] Offset: index==TRUE, wback==FALSE
STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, +/-<Rm>]! Pre-indexed: index==TRUE, wback==TRUE
STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], +/-<Rm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-690 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.212 STREX
Store Register Exclusive calculates an address from a base register value and an immediate offset, stores a word
from a register to memory if the executing processor has exclusive access to the memory addressed, and returns a
status word that indicates whether this store was performed.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
d = UInt(Rd); t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8:’00’, 32);
if d IN {13,15} || t IN {13,15} || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); t = UInt(Rt); n = UInt(Rn); imm32 = Zeros(32); // Zero offset
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
STREX<c> <Rd>, <Rt>, [<Rn>{, #<imm>}]
TOKENSTREX<c> <Rd>, <Rt>, [<Rn>]
1 1 0 1 0 0 0 0 1 0 0 Rn Rt Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 0 0 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rt
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-691
ID051414 Non-Confidential
Assembler syntax
STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, #<imm>}]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register for the returned status value. The value returned is:
0 if the operation updates memory
1 if the operation fails to update memory.
<Rt> The source register.
<Rn> The base register. The SP can be used.
<imm> The immediate offset added to the value of <Rn> to form the address. Values are multiples of 4 in the
range 0-1020 for encoding T1, and 0 for encoding A1. <imm> can be omitted, meaning an offset of 0.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n] + imm32;
if ExclusiveMonitorsPass(address,4) then
MemA[address,4] = R[t];
R[d] = ZeroExtend(‘0’, 32);
else
R[d] = ZeroExtend(‘1’, 32);
Exceptions
Data Abort.
Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:
• memory is not updated
• <Rd> is not updated.
In ARMv7, a non word-aligned memory address causes an Alignment fault Data Abort exception to be generated,
subject to the following rules:
• If ExclusiveMonitorsPass() returns TRUE, the exception is generated.
• Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.
If ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data
Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.
Note
In ARMv6:
• If SCTLR.A and SCTLR.U are both 0, a non word-aligned memory address causes UNPREDICTABLE
behavior.
• Otherwise, the ARMv7 behavior applies.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-692 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.213 STREXB
Store Register Exclusive Byte derives an address from a base register value, stores a byte from a register to memory
if the executing processor has exclusive access to the memory addressed, and returns a status word that indicates
whether this store was performed.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);
if d IN {13,15} || t IN {13,15} || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;
Encoding T1 ARMv7
STREXB<c> <Rd>, <Rt>, [<Rn>]
TOKENSTREXB<c> <Rd>, <Rt>, [<Rn>]
1 1 0 1 0 0 0 1 1 0 0 Rn Rt (1) (1) (1) (1) 0 1 0 0 Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 1 0 0 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rt
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-693
ID051414 Non-Confidential
Assembler syntax
STREXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register for the returned status value. The value returned is:
0 if the operation updates memory
1 if the operation fails to update memory.
<Rt> The source register.
<Rn> The base register. The SP can be used.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
if ExclusiveMonitorsPass(address,1) then
MemA[address,1] = R[t]<7:0>;
R[d] = ZeroExtend(‘0’, 32);
else
R[d] = ZeroExtend(‘1’, 32);
Exceptions
Data Abort.
Aborts
If a synchronous Data Abort exception is generated by the execution of this instruction:
• memory is not updated
• <Rd> is not updated.
If ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data
Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-694 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.214 STREXD
Store Register Exclusive Doubleword derives an address from a base register value, stores a 64-bit doubleword from
two registers to memory if the executing processor has exclusive access to the memory addressed, and returns a
status word that indicates whether this store was performed.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
d = UInt(Rd); t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn);
if d IN {13,15} || t IN {13,15} || t2 IN {13,15} || n == 15 then UNPREDICTABLE;
if d == n || d == t || d == t2 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); t = UInt(Rt); t2 = t+1; n = UInt(Rn);
if d == 15 || Rt<0> == ‘1’ || Rt == ‘1110’ || n == 15 then UNPREDICTABLE;
if d == n || d == t || d == t2 then UNPREDICTABLE;
Encoding T1 ARMv7
STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>]
TOKENSTREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>]
1 1 0 1 0 0 0 1 1 0 0 Rn Rt Rt2 0 1 1 1 Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 0 1 0 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rt
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-695
ID051414 Non-Confidential
Assembler syntax
STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register for the returned status value. The value returned is:
0 if the operation updates memory
1 if the operation fails to update memory.
<Rd> must not be the same as <Rn>, <Rt>, or <Rt2>.
<Rt> The first source register. For an ARM instruction, <Rt> must be even-numbered and not R14.
<Rt2> The second source register. For an ARM instruction, <Rt2> must be <R(t+1)>.
<Rn> The base register. The SP can be used.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
// For the alignment requirements see “Aborts and alignment”
// Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.
value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];
if ExclusiveMonitorsPass(address,8) then
MemA[address,8] = value;
R[d] = ZeroExtend(‘0’, 32);
else
R[d] = ZeroExtend(‘1’, 32);
Exceptions
Data Abort.
Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:
• memory is not updated
• <Rd> is not updated.
In ARMv7, a non doubleword-aligned memory address causes an Alignment fault Data Abort exception to be
generated, subject to the following rules:
• If ExclusiveMonitorsPass() returns TRUE, the exception is generated.
• Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.
If ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data
Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.
Note
In ARMv6K:
• If SCTLR.A and SCTLR.U are both 0, a non doubleword-aligned memory address causes UNPREDICTABLE
behavior.
• Otherwise, the ARMv7 behavior applies.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-696 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.215 STREXH
Store Register Exclusive Halfword derives an address from a base register value, stores a halfword from a register
to memory if the executing processor has exclusive access to the memory addressed, and returns a status word that
indicates whether this store was performed.
For more information about support for shared memory see Synchronization and semaphores on page A3-114. For
information about memory accesses see Memory accesses on page A8-294.
d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);
if d IN {13,15} || t IN {13,15} || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;
Encoding T1 ARMv7
STREXH<c> <Rd>, <Rt>, [<Rn>]
TOKENSTREXH<c> <Rd>, <Rt>, [<Rn>]
1 1 0 1 0 0 0 1 1 0 0 Rn Rt (1) (1) (1) (1) 0 1 0 1 Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 1 1 1 0 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rt
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-697
ID051414 Non-Confidential
Assembler syntax
STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register for the returned status value. The value returned is:
0 if the operation updates memory
1 if the operation fails to update memory.
<Rt> The source register.
<Rn> The base register. The SP can be used.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
address = R[n];
if ExclusiveMonitorsPass(address,2) then
MemA[address,2] = R[t]<15:0>;
R[d] = ZeroExtend(‘0’, 32);
else
R[d] = ZeroExtend(‘1’, 32);
Exceptions
Data Abort.
Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:
• memory is not updated
• <Rd> is not updated.
In ARMv7, a non halfword-aligned memory address causes an Alignment fault Data Abort exception to be
generated, subject to the following rules:
• If ExclusiveMonitorsPass() returns TRUE, the exception is generated.
• Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.
If ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data
Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.
Note
In ARMv6K:
• If SCTLR.A and SCTLR.U are both 0, a non halfword-aligned memory address causes UNPREDICTABLE
behavior.
• Otherwise, the ARMv7 behavior applies.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-698 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.216 STRH (immediate, Thumb)
Store Register Halfword (immediate) calculates an address from a base register value and an immediate offset, and
stores a halfword from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For
information about memory accesses see Memory accesses on page A8-294.
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm5:’0’, 32);
index = TRUE; add = TRUE; wback = FALSE;
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);
index = TRUE; add = TRUE; wback = FALSE;
if t IN {13,15} then UNPREDICTABLE;
if P == ‘1’ && U == ‘1’ && W == ‘0’ then SEE STRHT;
if Rn == ‘1111’ || (P == ‘0’ && W == ‘0’) then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (W == ‘1’);
if t IN {13,15} || (wback && n == t) then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
STRH<c> <Rt>, [<Rn>{, #<imm>}]
Encoding T2 ARMv6T2, ARMv7
STRH<c>.W <Rt>, [<Rn>{, #<imm12>}]
Encoding T3 ARMv6T2, ARMv7
STRH<c> <Rt>, [<Rn>, #-<imm8>]
STRH<c> <Rt>, [<Rn>], #+/-<imm8>
STRH<c> <Rt>, [<Rn>, #+/-<imm8>]!
1 0 0 0 0 imm5 Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 1 0 1 0 Rn Rt imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 1 0 Rn Rt 1 P U W imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-699
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are:
Encoding T1 multiples of 2 in the range 0-62
Encoding T2 any value in the range 0-4095
Encoding T3 any value in the range 0-255.
For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.
The pre-UAL syntax STR<c>H is equivalent to STRH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
if UnalignedSupport() || address<0> == ‘0’ then
MemU[address,2] = R[t]<15:0>;
else // Can only occur before ARMv7
MemU[address,2] = bits(16) UNKNOWN;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRH{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
STRH{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
STRH{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-700 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.217 STRH (immediate, ARM)
Store Register Halfword (immediate) calculates an address from a base register value and an immediate offset, and
stores a halfword from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For
information about memory accesses see Memory accesses on page A8-294.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE STRHT;
t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
if t == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
TOKENSTRH<c> <Rt>, [<Rn>{, #+/-<imm8>}]
STRH<c> <Rt>, [<Rn>], #+/-<imm8>
STRH<c> <Rt>, [<Rn>, #+/-<imm8>]!
cond 0 0 0 P U 1 W 0 Rn Rt imm4H 1 0 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-701
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used. For offset addressing only, the PC can be used. However,
ARM deprecates use of the PC.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are 0-255. For the offset addressing
syntax, <imm> can be omitted, meaning an offset of 0.
The pre-UAL syntax STR<c>H is equivalent to STRH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
if UnalignedSupport() || address<0> == ‘0’ then
MemU[address,2] = R[t]<15:0>;
else // Can only occur before ARMv7
MemU[address,2] = bits(16) UNKNOWN;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRH{<c>}{<q>} <Rt>, [<Rn> {, #+/-<imm>}] Offset: index==TRUE, wback==FALSE
STRH{<c>}{<q>} <Rt>, [<Rn>, #+/-<imm>]! Pre-indexed: index==TRUE, wback==TRUE
STRH{<c>}{<q>} <Rt>, [<Rn>], #+/-<imm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-702 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.218 STRH (register)
Store Register Halfword (register) calculates an address from a base register value and an offset register value, and
stores a halfword from a register to memory. The offset register value can be shifted left by 0, 1, 2, or 3 bits. For
information about memory accesses see Memory accesses on page A8-294.
if CurrentInstrSet() == InstrSet_ThumbEE then SEE “Modified operation in ThumbEE”;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = TRUE; add = TRUE; wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && W == ‘1’ then SEE STRHT;
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);
index = (P == ‘1’); add = (U == ‘1’); wback = (P == ‘0’) || (W == ‘1’);
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
STRH<c> <Rt>, [<Rn>, <Rm>]
Encoding T2 ARMv6T2, ARMv7
STRH<c>.W <Rt>, [<Rn>, <Rm>{, LSL #<imm2>}]
TOKENSTRH<c> <Rt>, [<Rn>,+/-<Rm>]{!}
STRH<c> <Rt>, [<Rn>],+/-<Rm>
Modified operation in ThumbEE See STRH (register) on page A9-1122
0 1 0 1 0 0 1 Rm Rn Rt
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 0 0 0 1 0 Rn Rt 0 0 0 0 0 0 imm2 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 P U 0 W 0 Rn Rt (0) (0) (0) (0) 1 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-703
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used. In the ARM instruction set, for offset addressing only, the
PC can be used. However, ARM deprecates use of the PC.
+/- Is + or omitted if the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<Rm> Contains the offset that is optionally left shifted and added to the value of <Rn> to form the address.
<imm> If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. Only encoding
T2 is permitted, and <imm> is encoded in imm2.
If absent, no shift is specified and all encodings are permitted. In encoding T2, imm2 is encoded as
0b00.
The pre-UAL syntax STR<c>H is equivalent to STRH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = Shift(R[m], shift_t, shift_n, APSR.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
if UnalignedSupport() || address<0> == ‘0’ then
MemU[address,2] = R[t]<15:0>;
else // Can only occur before ARMv7
MemU[address,2] = bits(16) UNKNOWN;
if wback then R[n] = offset_addr;
Exceptions
Data Abort.
STRH{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>{, LSL #<imm>}]Offset: index==TRUE, wback==FALSE
STRH{<c>}{<q>} <Rt>, [<Rn>, +/-<Rm>]! Pre-indexed: index==TRUE, wback==TRUE
STRH{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: index==FALSE, wback==TRUE
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-704 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.219 STRHT
Store Register Halfword Unprivileged stores a halfword from a register to memory. For information about memory
accesses see Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
STRHT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or a register value.
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
STRHT<c> <Rt>, [<Rn>, #<imm8>]
TOKENSTRHT<c> <Rt>, [<Rn>] {, #+/-<imm8>}
Encoding A2 ARMv6T2, ARMv7
STRHT<c> <Rt>, [<Rn>], +/-<Rm>
1 1 1 1 0 0 0 0 0 1 0 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 1 1 0 Rn Rt imm4H 1 0 1 1 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 U 0 1 0 Rn Rt (0) (0) (0) (0) 1 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-705
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<imm> The immediate offset applied to the value of <Rn>. Any value in the range 0-255 is permitted. <imm>
can be omitted, meaning an offset of 0.
<Rm> Contains the offset that is applied to the value of <Rn> to form the address.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
if UnalignedSupport() || address<0> == ‘0’ then
MemU_unpriv[address,2] = R[t]<15:0>;
else // Can only occur before ARMv7
MemU_unpriv[address,2] = bits(16) UNKNOWN;
if postindex then R[n] = offset_addr;
Exceptions
Data Abort.
STRHT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
STRHT{<c>}{<q>} <Rt>, [<Rn>] {, #+/-<imm>} Post-indexed: ARM only
STRHT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-706 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.220 STRT
Store Register Unprivileged stores a word from a register to memory. For information about memory accesses see
Memory accesses on page A8-294.
The memory access is restricted as if the processor were running in User mode. This makes no difference if the
processor is actually running in User mode.
STRT is UNPREDICTABLE in Hyp mode.
The Thumb instruction uses an offset addressing mode, that calculates the address used for the memory access from
a base register value and an immediate offset, and leaves the base register unchanged.
The ARM instruction uses a post-indexed addressing mode, that uses a base register value as the address for the
memory access, and calculates a new address from a base register value and an offset and writes it back to the base
register. The offset can be an immediate value or an optionally-shifted register value.
if Rn == ‘1111’ then UNDEFINED;
t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;
register_form = FALSE; imm32 = ZeroExtend(imm8, 32);
if t IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == ‘1’);
register_form = FALSE; imm32 = ZeroExtend(imm12, 32);
if n == 15 || n == t then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == ‘1’);
register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);
if n == 15 || n == t || m == 15 then UNPREDICTABLE;
if ArchVersion() < 6 && m == n then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
STRT<c> <Rt>, [<Rn>, #<imm8>]
TOKENSTRT<c> <Rt>, [<Rn>] {, +/-<imm12>}
Encoding A2 ARMv4*, ARMv5T*, ARMv6*, ARMv7
STRT<c> <Rt>, [<Rn>],+/-<Rm>{, <shift>}
1 1 1 1 0 0 0 0 1 0 0 Rn Rt 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 0 0 U 0 1 0 Rn Rt imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 U 0 1 0 Rn Rt imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-707
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The source register. In the ARM instruction set, the PC can be used. However, ARM deprecates use
of the PC.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if <imm> or the optionally shifted value of <Rm> is to be added to the base register value
(add == TRUE), or – if it is to be subtracted (permitted in ARM instructions only, add == FALSE).
<imm> The immediate offset applied to the value of <Rn>. Values are 0-255 for encoding T1, and 0-4095 for
TOKEN<Rm> Contains the offset that is optionally shifted and added to the value of <Rn> to form the address.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
The pre-UAL syntax STR<c>T is equivalent to STRT<c>.
Operation
if ConditionPassed() then
if CurrentModeIsHyp() then UNPREDICTABLE; // Hyp mode
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
offset = if register_form then Shift(R[m], shift_t, shift_n, APSR.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
if t == 15 then // Only possible for encodings A1 and A2
data = PCStoreValue();
else
data = R[t];
if UnalignedSupport() || address<1:0> == ‘00’ || CurrentInstrSet() == InstrSet_ARM then
MemU_unpriv[address,4] = data;
else // Can only occur before ARMv7
MemU_unpriv[address,4] = bits(32) UNKNOWN;
if postindex then R[n] = offset_addr;
Exceptions
Data Abort.
STRT{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}] Offset: Thumb only
STRT{<c>}{<q>} <Rt>, [<Rn>] {, #+/-<imm>} Post-indexed: ARM only
STRT{<c>}{<q>} <Rt>, [<Rn>], +/-<Rm> {, <shift>} Post-indexed: ARM only
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-708 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.221 SUB (immediate, Thumb)
This instruction subtracts an immediate value from a register value, and writes the result to the destination register.
It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); setflags = !InITBlock(); imm32 = ZeroExtend(imm3, 32);
d = UInt(Rdn); n = UInt(Rdn); setflags = !InITBlock(); imm32 = ZeroExtend(imm8, 32);
if Rd == ‘1111’ && S == ‘1’ then SEE CMP (immediate);
if Rn == ‘1101’ then SEE SUB (SP minus immediate);
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ThumbExpandImm(i:imm3:imm8);
if d == 13 || (d == 15 && S == ‘0’) || n == 15 then UNPREDICTABLE;
if Rn == ‘1111’ then SEE ADR;
if Rn == ‘1101’ then SEE SUB (SP minus immediate);
d = UInt(Rd); n = UInt(Rn); setflags = FALSE; imm32 = ZeroExtend(i:imm3:imm8, 32);
if d IN {13,15} then UNPREDICTABLE;
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
SUBS <Rd>, <Rn>, #<imm3> Outside IT block.
SUB<c> <Rd>, <Rn>, #<imm3> Inside IT block.
Encoding T2 ARMv4T, ARMv5T*, ARMv6*, ARMv7
SUBS <Rdn>, #<imm8> Outside IT block.
SUB<c> <Rdn>, #<imm8> Inside IT block.
Encoding T3 ARMv6T2, ARMv7
SUB{S}<c>.W <Rd>, <Rn>, #<const>
Encoding T4 ARMv6T2, ARMv7
SUBW<c> <Rd>, <Rn>, #<imm12>
0 0 0 1 1 1 1 imm3 Rn Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0 0 1 1 1 Rdn imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 0 1 1 0 1 S Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 1 0 1 0 1 0 Rn 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-709
ID051414 Non-Confidential
Assembler syntax
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010.
<Rn> The first operand register. If the SP is specified for <Rn>, see SUB (SP minus immediate) on
page A8-716. If the PC is specified for <Rn>, see ADR on page A8-322.
<const> The immediate value to be subtracted from the value obtained from <Rn>. The range of values is 0-7
for encoding T1, 0-255 for encoding T2 and 0-4095 for encoding T4. See Modified immediate
constants in Thumb instructions on page A6-232 for the range of values for encoding T3.
When multiple encodings of the same length are available for an instruction, encoding T3 is
preferred to encoding T4. If encoding T4 is required, use the SUBW syntax. Encoding T1 is preferred
to encoding T2 if <Rd> is specified and encoding T2 is preferred to encoding T1 if <Rd> is omitted.
The pre-UAL syntax SUB<c>S is equivalent to SUBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], NOT(imm32), ‘1’);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
SUB{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const> All encodings permitted
SUBW{<c>}{<q>} {<Rd>,} <Rn>, #<const> Only encoding T4 permitted
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-710 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.222 SUB (immediate, ARM)
This instruction subtracts an immediate value from a register value, and writes the result to the destination register.
It can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ && S == ‘0’ then SEE ADR;
if Rn == ‘1101’ then SEE SUB (SP minus immediate);
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); n = UInt(Rn); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
TOKENSUB{S}<c> <Rd>, <Rn>, #<const>
cond 0 0 1 0 0 1 0 S Rn Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-711
ID051414 Non-Confidential
Assembler syntax
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR and related
instructions (ARM) on page B9-2012.
If S is not specified and <Rd> is the PC, the instruction is a branch to the address calculated by the
operation. This is an interworking branch, see Pseudocode details of operations on ARM core
registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. If the SP is specified for <Rn>, see SUB (SP minus immediate) on
page A8-716. If the PC is specified for <Rn>, see ADR on page A8-322.
<const> The immediate value to be subtracted from the value obtained from <Rn>. See Modified immediate
constants in ARM instructions on page A5-200 for the range of values.
The pre-UAL syntax SUB<c>S is equivalent to SUBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(R[n], NOT(imm32), ‘1’);
if d == 15 then
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
SUB{S}{<c>}{<q>} {<Rd>,} <Rn>, #<const>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-712 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.223 SUB (register)
This instruction subtracts an optionally-shifted register value from a register value, and writes the result to the
destination register. It can optionally update the condition flags based on the result.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);
if Rd == ‘1111’ && S == ‘1’ then SEE CMP (register);
if Rn == ‘1101’ then SEE SUB (SP minus register);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d == 13 || (d == 15 && S == ‘0’) || n == 15 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
if Rn == ‘1101’ then SEE SUB (SP minus register);
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
SUBS <Rd>, <Rn>, <Rm> Outside IT block.
SUB<c> <Rd>, <Rn>, <Rm> Inside IT block.
Encoding T2 ARMv6T2, ARMv7
SUB{S}<c>.W <Rd>, <Rn>, <Rm>{, <shift>}
TOKENSUB{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}
0 0 0 1 1 0 1 Rm Rn Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 1 0 1 S Rn (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 1 0 S Rn Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-713
ID051414 Non-Confidential
Assembler syntax
SUB{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC. If the SP is specified for <Rn>, see SUB (SP minus register) on page A8-718.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
The pre-UAL syntax SUB<c>S is equivalent to SUBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], NOT(shifted), ‘1’);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-714 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.224 SUB (register-shifted register)
This instruction subtracts a register-shifted register value from a register value, and writes the result to the
destination register. It can optionally update the condition flags based on the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
setflags = (S == ‘1’); shift_t = DecodeRegShift(type);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENSUB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 0 0 1 0 S Rn Rd Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-715
ID051414 Non-Confidential
Assembler syntax
SUB{S}{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
The pre-UAL syntax SUB<c>S is equivalent to SUBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(R[n], NOT(shifted), ‘1’);
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-716 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.225 SUB (SP minus immediate)
This instruction subtracts an immediate value from the SP value, and writes the result to the destination register.
d = 13; setflags = FALSE; imm32 = ZeroExtend(imm7:’00’, 32);
if Rd == ‘1111’ && S == ‘1’ then SEE CMP (immediate);
d = UInt(Rd); setflags = (S == ‘1’); imm32 = ThumbExpandImm(i:imm3:imm8);
if d == 15 && S == ‘0’ then UNPREDICTABLE;
d = UInt(Rd); setflags = FALSE; imm32 = ZeroExtend(i:imm3:imm8, 32);
if d == 15 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); setflags = (S == ‘1’); imm32 = ARMExpandImm(imm12);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
SUB<c> SP, SP, #<imm>
Encoding T2 ARMv6T2, ARMv7
SUB{S}<c>.W <Rd>, SP, #<const>
Encoding T3 ARMv6T2, ARMv7
SUBW<c> <Rd>, SP, #<imm12>
TOKENSUB{S}<c> <Rd>, SP, #<const>
1 0 1 1 0 0 0 0 1 imm7
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 0 1 1 0 1 S 1 1 0 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 i 1 0 1 0 1 0 1 1 0 1 0 imm3 Rd imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 0 0 1 0 S 1 1 0 1 Rd imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-717
ID051414 Non-Confidential
Assembler syntax
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012. If omitted, <Rd>
is SP.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<const> The immediate value to be subtracted from the value obtained from SP. Values are multiples of 4 in
the range 0-508 for encoding T1 and any value in the range 0-4095 for encoding T3. See Modified
immediate constants in Thumb instructions on page A6-232 or Modified immediate constants in
ARM instructions on page A5-200 for the range of values for encodings T2 and A1.
When both 32-bit encodings are available for an instruction, encoding T2 is preferred to encoding
T3 (if encoding T3 is required, use the SUBW syntax).
The pre-UAL syntax SUB<c>S is equivalent to SUBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result, carry, overflow) = AddWithCarry(SP, NOT(imm32), ‘1’);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
SUB{S}{<c>}{<q>} {<Rd>,} SP, #<const> All encodings permitted
SUBW{<c>}{<q>} {<Rd>,} SP, #<const> Only encoding T3 permitted
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-718 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.226 SUB (SP minus register)
This instruction subtracts an optionally-shifted register value from the SP value, and writes the result to the
destination register.
if Rd == ‘1111’ && S == ‘1’ then SEE CMP (register);
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if d == 13 && (shift_t != SRType_LSL || shift_n > 3) then UNPREDICTABLE;
if (d == 15 && S == ‘0’) || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rd == ‘1111’ && S == ‘1’ then SEE SUBS PC, LR and related instructions;
d = UInt(Rd); m = UInt(Rm); setflags = (S == ‘1’);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv6T2, ARMv7
SUB{S}<c> <Rd>, SP, <Rm>{, <shift>}
TOKENSUB{S}<c> <Rd>, SP, <Rm>{, <shift>}
1 1 0 1 0 1 1 1 0 1 S 1 1 0 1 (0) imm3 Rd imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 1 0 S 1 1 0 1 Rd imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-719
ID051414 Non-Confidential
Assembler syntax
SUB{S}{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift>}
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
<c><q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register. If S is specified and <Rd> is the PC, see SUBS PC, LR (Thumb) on
page B9-2010 or SUBS PC, LR and related instructions (ARM) on page B9-2012. If omitted, <Rd>
is SP.
In ARM instructions, if S is not specified and <Rd> is the PC, the instruction is a branch to the address
calculated by the operation. This is an interworking branch, see Pseudocode details of operations
on ARM core registers on page A2-47.
Note
Before ARMv7, this was a simple branch.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
In the Thumb instruction set, if <Rd> is SP or omitted, <shift> is only permitted to be omitted, LSL #1,
LSL #2, or LSL #3.
The pre-UAL syntax SUB<c>S is equivalent to SUBS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shifted = Shift(R[m], shift_t, shift_n, APSR.C);
(result, carry, overflow) = AddWithCarry(SP, NOT(shifted), ‘1’);
if d == 15 then // Can only occur for ARM encoding
ALUWritePC(result); // setflags is always FALSE here
else
R[d] = result;
if setflags then
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
APSR.V = overflow;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-720 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.227 SUBS PC, LR and related instructions
These instructions are for system level use only. See SUBS PC, LR (Thumb) on page B9-2010 and SUBS PC, LR
and related instructions (ARM) on page B9-2012.
A8.8.228 SVC (previously SWI)
Supervisor Call, previously called Software Interrupt, causes a Supervisor Call exception. For more information,
see Supervisor Call (SVC) exception on page B1-1210.
Software can use this instruction as a call to an operating system to provide a service.
In the following cases, the Supervisor Call exception generated by the SVC instruction is taken to Hyp mode:
• If the SVC is executed in Hyp mode.
• If HCR.TGE is set to 1, and the SVC is executed in Non-secure User mode. For more information, see
Supervisor Call exception, when HCR.TGE is set to 1 on page B1-1192
In these cases, the HSR identifies that the exception entry was caused by a Supervisor Call exception, EC value 0x11,
see Use of the HSR on page B3-1424. The immediate field in the HSR:
• if the SVC is unconditional:
— for the Thumb instruction, is the zero-extended value of the imm8 field
— for the ARM instruction, is the least-significant 16 bits the imm24 field
• if the SVC is conditional, is UNKNOWN.
imm32 = ZeroExtend(imm8, 32);
// imm32 is for assembly/disassembly. SVC handlers in some
// systems interpret imm8 in software, for example to determine the required service.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
imm32 = ZeroExtend(imm24, 32);
// imm32 is for assembly/disassembly. SVC handlers in some
// systems interpret imm24 in software, for example to determine the required service.
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
SVC<c> #<imm8>
TOKENSVC<c> #<imm24>
1 1 0 1 1 1 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 1 1 imm24
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-721
ID051414 Non-Confidential
Assembler syntax
SVC{<c>}{<q>} {#}<imm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<imm> Specifies an immediate constant, 8-bit in Thumb instructions, or 24-bit in ARM instructions.
The pre-UAL syntax SWI<c> is equivalent to SVC<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
CallSupervisor(imm32<15:0>);
Exceptions
Supervisor Call.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-722 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.229 SWP, SWPB
SWP (Swap) swaps a word between registers and memory. SWP loads a word from the memory address given by the
value of register <Rn>. The value of register <Rt2> is then stored to the memory address given by the value of <Rn>,
and the original loaded value is written to register <Rt>. If the same register is specified for <Rt> and <Rt2>, this
instruction swaps the value of the register and the value at the memory address.
SWPB (Swap Byte) swaps a byte between registers and memory. SWPB loads a byte from the memory address given by
the value of register <Rn>. The value of the least significant byte of register <Rt2> is stored to the memory address
given by <Rn>, the original loaded value is zero-extended to a 32-bit word, and the word is written to register <Rt>.
If the same register is specified for <Rt> and <Rt2>, this instruction swaps the value of the least significant byte of
the register and the byte value at the memory address, and clears the most significant three bytes of the register.
For both instructions, the memory system ensures that no other memory access can occur to the memory location
between the load access and the store access.
Note
• The SWP and SWPB instructions rely on the properties of the system beyond the processor to ensure that no
stores from other observers can occur between the load access and the store access, and this might not be
implemented for all regions of memory on some system implementations. In all cases, SWP and SWPB do ensure
that no stores from the processor that executed the SWP or SWPB instruction can occur between the load access
and the store access of the SWP or SWPB.
• ARM deprecates the use of SWP and SWPB, and strongly recommends that new software uses:
— LDREX/STREX in preference to SWP
— LDREXB/STREXB in preference to SWPB.
• If the translation table entries that relate to a memory location accessed by the SWP or SWPB instruction change,
or are seen to change by the executing processor as a result of TLB eviction, this might mean that the
translation table attributes, permissions or addresses for the load are different to those for the store. In this
case, the architecture makes no guarantee that no memory access occur to these memory locations between
the load and store.
The Virtualization Extensions make the SWP and SWPB instructions OPTIONAL and deprecated:
• If an implementation does not include the SWP and SWPB instructions, the ID_ISAR0.Swap_instrs and
ID_ISAR4.SWP_frac fields are zero, see About the Instruction Set Attribute registers on page B7-1952.
• In an implementation that includes SWP and SWPB, both instructions are UNDEFINED in Hyp mode.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn); size = if B == ‘1’ then 1 else 4;
if t == 15 || t2 == 15 || n == 15 || n == t || n == t2 then UNPREDICTABLE;
TOKENSWP{B}<c> <Rt>, <Rt2>, [<Rn>]
cond 0 0 0 1 0 B 0 0 Rn Rt (0) (0) (0) (0) 1 0 0 1 Rt2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-723
ID051414 Non-Confidential
Assembler syntax
SWP{B}{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]
where:
B If B is present, the instruction operates on a byte. Otherwise, it operates on a word.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination register.
<Rt2> Contains the value that is stored to memory.
<Rn> Contains the memory address to load from.
The pre-UAL syntax SWP<c>B is equivalent to SWPB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if CurrentModeIsHyp() then UNDEFINED;
// The MemA[] accesses in the next two statements are locked together, that is, the memory
// system must ensure that no other access to the same location can occur between them.
data = ZeroExtend(MemA[R[n], size],32);
MemA[R[n], size] = R[t2]<8*size-1:0>;
if size == 1 then // SWPB
R[t] = data;
else // SWP
// Rotation in the following will always be by zero in ARMv7, due to alignment checks,
// but can be nonzero in legacy configurations.
R[t] = ROR(data, 8*UInt(R[n]<1:0>));
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-724 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.230 SXTAB
Signed Extend and Add Byte extracts an 8-bit value from a register, sign-extends it to 32 bits, adds the result to the
value in another register, and writes the final result to the destination register. The instruction can specify a rotation
by 0, 8, 16, or 24 bits before extracting the 8-bit value.
if Rn == ‘1111’ then SEE SXTB;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE SXTB;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SXTAB<c> <Rd>, <Rn>, <Rm>{, <rotation>}
TOKENSXTAB<c> <Rd>, <Rn>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 1 0 0 Rn 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 0 Rn Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-725
ID051414 Non-Confidential
Assembler syntax
SXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = R[n] + SignExtend(rotated<7:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-726 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.231 SXTAB16
Signed Extend and Add Byte 16 extracts two 8-bit values from a register, sign-extends them to 16 bits each, adds
the results to two 16-bit values from another register, and writes the final results to the destination register. The
instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values.
if Rn == ‘1111’ then SEE SXTB16;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE SXTB16;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SXTAB16<c> <Rd>, <Rn>, <Rm>{, <rotation>}
TOKENSXTAB16<c> <Rd>, <Rn>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 0 1 0 Rn 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 0 0 Rn Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-727
ID051414 Non-Confidential
Assembler syntax
SXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d]<15:0> = R[n]<15:0> + SignExtend(rotated<7:0>, 16);
R[d]<31:16> = R[n]<31:16> + SignExtend(rotated<23:16>, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-728 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.232 SXTAH
Signed Extend and Add Halfword extracts a 16-bit value from a register, sign-extends it to 32 bits, adds the result
to a value from another register, and writes the final result to the destination register. The instruction can specify a
rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.
if Rn == ‘1111’ then SEE SXTH;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE SXTH;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SXTAH<c> <Rd>, <Rn>, <Rm>{, <rotation>}
TOKENSXTAH<c> <Rd>, <Rn>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 0 0 0 Rn 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 1 Rn Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-729
ID051414 Non-Confidential
Assembler syntax
SXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = R[n] + SignExtend(rotated<15:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-730 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.233 SXTB
Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to 32 bits, and writes the result to the
destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.
d = UInt(Rd); m = UInt(Rm); rotation = 0;
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7
SXTB<c> <Rd>, <Rm>
Encoding T2 ARMv6T2, ARMv7
SXTB<c>.W <Rd>, <Rm>{, <rotation>}
TOKENSXTB<c> <Rd>, <Rm>{, <rotation>}
1 0 1 1 0 0 1 0 0 1 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 1 0 0 1 1 1 1 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 0 1 1 1 1 Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-731
ID051414 Non-Confidential
Assembler syntax
SXTB{<c>}{<q>} {<Rd>,} <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand.
<rotation> This can be any one of:
omitted any encoding, encoded as rotate = 0b00 in encoding T2 or A1
ROR #8 encoding T2 or A1, encoded as rotate = 0b01
ROR #16 encoding T2 or A1, encoded as rotate = 0b10
ROR #24 encoding T2 or A1, encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = SignExtend(rotated<7:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-732 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.234 SXTB16
Signed Extend Byte 16 extracts two 8-bit values from a register, sign-extends them to 16 bits each, and writes the
results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the
8-bit values.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
SXTB16<c> <Rd>, <Rm>{, <rotation>}
TOKENSXTB16<c> <Rd>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 0 1 0 1 1 1 1 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 0 0 1 1 1 1 Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-733
ID051414 Non-Confidential
Assembler syntax
SXTB16{<c>}{<q>} {<Rd>,} <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d]<15:0> = SignExtend(rotated<7:0>, 16);
R[d]<31:16> = SignExtend(rotated<23:16>, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-734 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.235 SXTH
Signed Extend Halfword extracts a 16-bit value from a register, sign-extends it to 32 bits, and writes the result to
the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit
value.
d = UInt(Rd); m = UInt(Rm); rotation = 0;
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7
SXTH<c> <Rd>, <Rm>
Encoding T2 ARMv6T2, ARMv7
SXTH<c>.W <Rd>, <Rm>{, <rotation>}
TOKENSXTH<c> <Rd>, <Rm>{, <rotation>}
1 0 1 1 0 0 1 0 0 0 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 0 0 0 1 1 1 1 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 0 1 1 1 1 1 1 Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-735
ID051414 Non-Confidential
Assembler syntax
SXTH{<c>}{<q>} {<Rd>,} <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The register that contains the operand.
<rotation> This can be any one of:
omitted any encoding, encoded as rotate = 0b00 in encoding T2 or A1
ROR #8 encoding T2 or A1, encoded as rotate = 0b01
ROR #16 encoding T2 or A1, encoded as rotate = 0b10
ROR #24 encoding T2 or A1, encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = SignExtend(rotated<15:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-736 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.236 TBB, TBH
Table Branch Byte causes a PC-relative forward branch using a table of single byte offsets. A base register provides
a pointer to the table, and a second register supplies an index into the table. The branch length is twice the value of
the byte returned from the table.
Table Branch Halfword causes a PC-relative forward branch using a table of single halfword offsets. A base register
provides a pointer to the table, and a second register supplies an index into the table. The branch length is twice the
value of the halfword returned from the table.
n = UInt(Rn); m = UInt(Rm); is_tbh = (H == ‘1’);
if n == 13 || m IN {13,15} then UNPREDICTABLE;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
TBB<c> [<Rn>, <Rm>] Outside or last in IT block
TBH<c> [<Rn>, <Rm>, LSL #1] Outside or last in IT block
1 1 0 1 0 0 0 1 1 0 1 Rn (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 H Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-737
ID051414 Non-Confidential
Assembler syntax
TBB{<c>}{<q>} [<Rn>, <Rm>]
TBH{<c>}{<q>} [<Rn>, <Rm>, LSL #1]
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The base register. This contains the address of the table of branch lengths. The PC can be used. If it
is, the table immediately follows this instruction.
<Rm> The index register.
For TBB, this contains an integer pointing to a single byte in the table. The offset in the table is the
value of the index.
For TBH, this contains an integer pointing to a halfword in the table. The offset in the table is twice
the value of the index.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); NullCheckIfThumbEE(n);
if is_tbh then
halfwords = UInt(MemU[R[n]+LSL(R[m],1), 2]);
else
halfwords = UInt(MemU[R[n]+R[m], 1]);
BranchWritePC(PC + 2*halfwords);
Exceptions
Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-738 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.237 TEQ (immediate)
Test Equivalence (immediate) performs a bitwise exclusive OR operation on a register value and an immediate
value. It updates the condition flags based on the result, and discards the result.
n = UInt(Rn);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn);
(imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
Encoding T1 ARMv6T2, ARMv7
TEQ<c> <Rn>, #<const>
TOKENTEQ<c> <Rn>, #<const>
1 1 1 0 i 0 0 1 0 0 1 Rn 0 imm3 1 1 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 1 1 Rn (0) (0) (0) (0) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-739
ID051414 Non-Confidential
Assembler syntax
TEQ{<c>}{<q>} <Rn>, #<const>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The operand register. The PC can be used in ARM instructions, but ARM deprecates this use of the
PC.
<const> The immediate value to be tested against the value obtained from <Rn>. See Modified immediate
constants in Thumb instructions on page A6-232 or Modified immediate constants in ARM
instructions on page A5-200 for the range of values.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[n] EOR imm32;
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-740 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.238 TEQ (register)
Test Equivalence (register) performs a bitwise exclusive OR operation on a register value and an optionally-shifted
register value. It updates the condition flags based on the result, and discards the result.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv6T2, ARMv7
TEQ<c> <Rn>, <Rm>{, <shift>}
TOKENTEQ<c> <Rn>, <Rm>{, <shift>}
1 1 0 1 0 1 0 1 0 0 1 Rn (0) imm3 1 1 1 1 imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 1 1 Rn (0) (0) (0) (0) imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-741
ID051414 Non-Confidential
Assembler syntax
TEQ{<c>}{<q>} <Rn>, <Rm> {, <shift>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If omitted, no shift is applied. Shifts applied to a
register on page A8-291 describes the shifts and how they are encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] EOR shifted;
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-742 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.239 TEQ (register-shifted register)
Test Equivalence (register-shifted register) performs a bitwise exclusive OR operation on a register value and a
register-shifted register value. It updates the condition flags based on the result, and discards the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
shift_t = DecodeRegShift(type);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENTEQ<c> <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 1 0 0 1 1 Rn (0) (0) (0) (0) Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-743
ID051414 Non-Confidential
Assembler syntax
TEQ{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] EOR shifted;
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-744 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.240 TST (immediate)
Test (immediate) performs a bitwise AND operation on a register value and an immediate value. It updates the
condition flags based on the result, and discards the result.
n = UInt(Rn);
(imm32, carry) = ThumbExpandImm_C(i:imm3:imm8, APSR.C);
if n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn);
(imm32, carry) = ARMExpandImm_C(imm12, APSR.C);
Encoding T1 ARMv6T2, ARMv7
TST<c> <Rn>, #<const>
TOKENTST<c> <Rn>, #<const>
1 1 1 0 i 0 0 0 0 0 1 Rn 0 imm3 1 1 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 0 1 Rn (0) (0) (0) (0) imm12
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-745
ID051414 Non-Confidential
Assembler syntax
TST{<c>}{<q>} <Rn>, #<const>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The operand register. The PC can be used in ARM instructions, but ARM deprecates this use of the
PC.
<const> The immediate value to be tested against the value obtained from <Rn>. See Modified immediate
constants in Thumb instructions on page A6-232 or Modified immediate constants in ARM
instructions on page A5-200 for the range of values.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = R[n] AND imm32;
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-746 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.241 TST (register)
Test (register) performs a bitwise AND operation on a register value and an optionally-shifted register value. It
updates the condition flags based on the result, and discards the result.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);
if n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(type, imm5);
Encoding T1 ARMv4T, ARMv5T*, ARMv6*, ARMv7
TST<c> <Rn>, <Rm>
Encoding T2 ARMv6T2, ARMv7
TST<c>.W <Rn>, <Rm>{, <shift>}
TOKENTST<c> <Rn>, <Rm>{, <shift>}
0 1 0 0 0 0 1 0 0 0 Rm Rn
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 0 0 0 1 Rn (0) imm3 1 1 1 1 imm2 type Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 1 0 0 0 1 Rn (0) (0) (0) (0) imm5 type 0 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-747
ID051414 Non-Confidential
Assembler syntax
TST{<c>}{<q>} <Rn>, <Rm> {, <shift>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register. The PC can be used in ARM instructions, but ARM deprecates this use
of the PC.
<Rm> The register that is optionally shifted and used as the second operand. The PC can be used in ARM
instructions, but ARM deprecates this use of the PC.
<shift> The shift to apply to the value read from <Rm>. If present, encoding T1 is not permitted. If absent, no
shift is applied and all encodings are permitted. Shifts applied to a register on page A8-291
describes the shifts and how they are encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] AND shifted;
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-748 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.242 TST (register-shifted register)
Test (register-shifted register) performs a bitwise AND operation on a register value and a register-shifted register
value. It updates the condition flags based on the result, and discards the result.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);
shift_t = DecodeRegShift(type);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;
TOKENTST<c> <Rn>, <Rm>, <type> <Rs>
cond 0 0 0 1 0 0 0 1 Rn (0) (0) (0) (0) Rs 0 type 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-749
ID051414 Non-Confidential
Assembler syntax
TST{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rn> The first operand register.
<Rm> The register that is shifted and used as the second operand.
<type> The type of shift to apply to the value read from <Rm>. It must be one of:
ASR Arithmetic shift right, encoded as type = 0b10.
LSL Logical shift left, encoded as type = 0b00.
LSR Logical shift right, encoded as type = 0b01.
ROR Rotate right, encoded as type = 0b11.
<Rs> The register whose bottom byte contains the amount to shift by.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
shift_n = UInt(R[s]<7:0>);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, APSR.C);
result = R[n] AND shifted;
APSR.N = result<31>;
APSR.Z = IsZeroBit(result);
APSR.C = carry;
// APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-750 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.243 UADD16
Unsigned Add 16 performs two 16-bit unsigned integer additions, and writes the results to the destination register.
It sets the APSR.GE bits according to the results of the additions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UADD16<c> <Rd>, <Rn>, <Rm>
TOKENUADD16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 1 Rn 1 1 1 1 Rd 0 1 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 0 1 Rn Rd (1) (1) (1) (1) 0 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-751
ID051414 Non-Confidential
Assembler syntax
UADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
R[d]<15:0> = sum1<15:0>;
R[d]<31:16> = sum2<15:0>;
APSR.GE<1:0> = if sum1 >= 0x10000 then ‘11’ else ‘00’;
APSR.GE<3:2> = if sum2 >= 0x10000 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-752 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.244 UADD8
Unsigned Add 8 performs four unsigned 8-bit integer additions, and writes the results to the destination register. It
sets the APSR.GE bits according to the results of the additions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UADD8<c> <Rd>, <Rn>, <Rm>
TOKENUADD8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 0 1 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 0 1 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-753
ID051414 Non-Confidential
Assembler syntax
UADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
R[d]<7:0> = sum1<7:0>;
R[d]<15:8> = sum2<7:0>;
R[d]<23:16> = sum3<7:0>;
R[d]<31:24> = sum4<7:0>;
APSR.GE<0> = if sum1 >= 0x100 then ‘1’ else ‘0’;
APSR.GE<1> = if sum2 >= 0x100 then ‘1’ else ‘0’;
APSR.GE<2> = if sum3 >= 0x100 then ‘1’ else ‘0’;
APSR.GE<3> = if sum4 >= 0x100 then ‘1’ else ‘0’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-754 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.245 UASX
Unsigned Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one
unsigned 16-bit integer addition and one unsigned 16-bit subtraction, and writes the results to the destination
register. It sets the APSR.GE bits according to the results.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UASX<c> <Rd>, <Rn>, <Rm>
TOKENUASX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 1 0 Rn 1 1 1 1 Rd 0 1 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 0 1 Rn Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-755
ID051414 Non-Confidential
Assembler syntax
UASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax UADDSUBX<c> is equivalent to UASX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
sum = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
R[d]<15:0> = diff<15:0>;
R[d]<31:16> = sum<15:0>;
APSR.GE<1:0> = if diff >= 0 then ‘11’ else ‘00’;
APSR.GE<3:2> = if sum >= 0x10000 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-756 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.246 UBFX
Unsigned Bit Field Extract extracts any number of adjacent bits at any position from a register, zero-extends them
to 32 bits, and writes the result to the destination register.
d = UInt(Rd); n = UInt(Rn);
lsbit = UInt(imm3:imm2); widthminus1 = UInt(widthm1);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn);
lsbit = UInt(lsb); widthminus1 = UInt(widthm1);
if d == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UBFX<c> <Rd>, <Rn>, #<lsb>, #<width>
TOKENUBFX<c> <Rd>, <Rn>, #<lsb>, #<width>
1 1 1 0 (0) 1 1 1 1 0 0 Rn 0 imm3 Rd imm2 (0) widthm1
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 1 1 1 widthm1 Rd lsb 1 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-757
ID051414 Non-Confidential
Assembler syntax
UBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<lsb> is the bit number of the least significant bit in the field, in the range 0-31. This determines the
required value of lsbit.
<width> is the width of the field, in the range 1 to 32-<lsb>. The required value of widthminus1 is <width>-1.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
msbit = lsbit + widthminus1;
if msbit <= 31 then
R[d] = ZeroExtend(R[n]<msbit:lsbit>, 32);
else
UNPREDICTABLE;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-758 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.247 UDF
Permanently Undefined generates an Undefined Instruction exception.
The encodings for UDF used in this section are defined as permanently UNDEFINED in the versions of the architecture
specified in this section. Issue C.a of this manual first defines an assembler mnemonic for these encodings.
However:
• with the Thumb instruction set, ARM deprecates using the UDF instruction in an IT block
• in the ARM instruction set, UDF is not conditional.
imm32 = ZeroExtend(imm8, 32);
// imm32 is for assembly and disassembly only, and is ignored by hardware.
imm32 = ZeroExtend(imm4:imm12, 32);
// imm32 is for assembly and disassembly only, and is ignored by hardware.
imm32 = ZeroExtend(imm12:imm4, 32);
// imm32 is for assembly and disassembly only, and is ignored by hardware.
Encoding T1 ARMv4T, ARMv5T*, ARMv6, ARMv7
UDF<c> #<imm8>
Encoding T2 ARMv6T2, ARMv7
UDF<c>.W #<imm16>
TOKENUDF<c> #<imm16>
1 1 0 1 1 1 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 1 1 1 1 1 1 imm4 1 0 1 0 imm12
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 1 1 1 1 imm12 1 1 1 1 imm4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-759
ID051414 Non-Confidential
Assembler syntax
UDF{<c>}{<q>} {#}<imm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
In the ARM instruction set, <c> must be AL or omitted.
In the Thumb instruction set, ARM deprecates using any <c> value other than AL.
<imm> Specifies an immediate constant, that is 8-bit in encoding T1, and 16-bit in encodings T2 and A1.
The processor ignores the value of this constant.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
UNDEFINED;
Exceptions
Undefined Instruction.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-760 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.248 UDIV
Unsigned Divide divides a 32-bit unsigned integer register value by a 32-bit unsigned integer register value, and
writes the result to the destination register. The condition flags are not affected.
See ARMv7 implementation requirements and options for the divide instructions on page A4-172 for more
information about this instruction.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv7-R, ARMv7VE, otherwise OPTIONAL in ARMv7-A
UDIV<c> <Rd>, <Rn>, <Rm>
TOKENUDIV<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 0 1 1 Rn (1) (1) (1) (1) Rd 1 1 1 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
0 1 1 1 0 0 1 1 Rd (1) (1) (1) (1) Rm 0 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-761
ID051414 Non-Confidential
Assembler syntax
UDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The register that contains the dividend.
<Rm> The register that contains the divisor.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if UInt(R[m]) == 0 then
if IntegerZeroDivideTrappingEnabled() then
GenerateIntegerZeroDivide();
else
result = 0;
else
result = RoundTowardsZero(UInt(R[n]) / UInt(R[m]));
R[d] = result<31:0>;
Exceptions
In ARMv7-R profile, Undefined Instruction, see Divide instructions on page A4-172.
In ARMv7-A profile, none.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-762 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.249 UHADD16
Unsigned Halving Add 16 performs two unsigned 16-bit integer additions, halves the results, and writes the results
to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UHADD16<c> <Rd>, <Rn>, <Rm>
TOKENUHADD16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 1 Rn 1 1 1 1 Rd 0 1 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 1 Rn Rd (1) (1) (1) (1) 0 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-763
ID051414 Non-Confidential
Assembler syntax
UHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
R[d]<15:0> = sum1<16:1>;
R[d]<31:16> = sum2<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-764 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.250 UHADD8
Unsigned Halving Add 8 performs four unsigned 8-bit integer additions, halves the results, and writes the results to
the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UHADD8<c> <Rd>, <Rn>, <Rm>
TOKENUHADD8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 0 1 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 1 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-765
ID051414 Non-Confidential
Assembler syntax
UHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
R[d]<7:0> = sum1<8:1>;
R[d]<15:8> = sum2<8:1>;
R[d]<23:16> = sum3<8:1>;
R[d]<31:24> = sum4<8:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-766 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.251 UHASX
Unsigned Halving Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs
one unsigned 16-bit integer addition and one unsigned 16-bit subtraction, halves the results, and writes the results
to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UHASX<c> <Rd>, <Rn>, <Rm>
TOKENUHASX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 1 0 Rn 1 1 1 1 Rd 0 1 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 1 Rn Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-767
ID051414 Non-Confidential
Assembler syntax
UHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax UHADDSUBX<c> is equivalent to UHASX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
sum = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
R[d]<15:0> = diff<16:1>;
R[d]<31:16> = sum<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-768 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.252 UHSAX
Unsigned Halving Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs
one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, halves the results, and writes the results
to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UHSAX<c> <Rd>, <Rn>, <Rm>
TOKENUHSAX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 1 0 Rn 1 1 1 1 Rd 0 1 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 1 Rn Rd (1) (1) (1) (1) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-769
ID051414 Non-Confidential
Assembler syntax
UHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax UHSUBADDX<c> is equivalent to UHSAX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
R[d]<15:0> = sum<16:1>;
R[d]<31:16> = diff<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-770 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.253 UHSUB16
Unsigned Halving Subtract 16 performs two unsigned 16-bit integer subtractions, halves the results, and writes the
results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UHSUB16<c> <Rd>, <Rn>, <Rm>
TOKENUHSUB16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 1 Rn 1 1 1 1 Rd 0 1 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 1 Rn Rd (1) (1) (1) (1) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-771
ID051414 Non-Confidential
Assembler syntax
UHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
R[d]<15:0> = diff1<16:1>;
R[d]<31:16> = diff2<16:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-772 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.254 UHSUB8
Unsigned Halving Subtract 8 performs four unsigned 8-bit integer subtractions, halves the results, and writes the
results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UHSUB8<c> <Rd>, <Rn>, <Rm>
TOKENUHSUB8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 0 Rn 1 1 1 1 Rd 0 1 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 1 Rn Rd (1) (1) (1) (1) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-773
ID051414 Non-Confidential
Assembler syntax
UHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
R[d]<7:0> = diff1<8:1>;
R[d]<15:8> = diff2<8:1>;
R[d]<23:16> = diff3<8:1>;
R[d]<31:24> = diff4<8:1>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-774 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.255 UMAAL
Unsigned Multiply Accumulate Accumulate Long multiplies two unsigned 32-bit values to produce a 64-bit value,
adds two unsigned 32-bit values, and writes the 64-bit result to two registers.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENUMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 1 1 0 Rn RdLo RdHi 0 1 1 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 0 1 0 0 RdHi RdLo Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-775
ID051414 Non-Confidential
Assembler syntax
UMAAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Supplies one of the 32-bit values to be added, and is the destination register for the lower 32 bits of
the result.
<RdHi> Supplies the other of the 32-bit values to be added, and is the destination register for the upper
32 bits of the result.
<Rn> The register that contains the first multiply operand.
<Rm> The register that contains the second multiply operand.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]) + UInt(R[dLo]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-776 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.256 UMLAL
Unsigned Multiply Accumulate Long multiplies two unsigned 32-bit values to produce a 64-bit value, and
accumulates this with a 64-bit value.
In ARM instructions, the condition flags can optionally be updated based on the result. Use of this option adversely
affects performance on many processor implementations.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
if ArchVersion() < 6 && (dHi == n || dLo == n) then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENUMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 1 1 0 Rn RdLo RdHi 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 1 0 1 S RdHi RdLo Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-777
ID051414 Non-Confidential
Assembler syntax
UMLAL{S}{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
S can be specified only for the ARM instruction set.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Supplies the lower 32 bits of the accumulate value, and is the destination register for the lower 32
bits of the result.
<RdHi> Supplies the upper 32 bits of the accumulate value, and is the destination register for the upper 32
bits of the result.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax UMLAL<c>S is equivalent to UMLALS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]:R[dLo]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
if setflags then
APSR.N = result<63>;
APSR.Z = IsZeroBit(result<63:0>);
if ArchVersion() == 4 then
APSR.C = bit UNKNOWN;
APSR.V = bit UNKNOWN;
// else APSR.C, APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-778 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.257 UMULL
Unsigned Multiply Long multiplies two 32-bit unsigned values to produce a 64-bit result.
In ARM instructions, the condition flags can optionally be updated based on the result. Use of this option adversely
affects performance on many processor implementations.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;
if dLo IN {13,15} || dHi IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == ‘1’);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;
if ArchVersion() < 6 && (dHi == n || dLo == n) then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm>
TOKENUMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>
1 1 1 1 0 1 1 1 0 1 0 Rn RdLo RdHi 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 0 0 1 0 0 S RdHi RdLo Rm 1 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-779
ID051414 Non-Confidential
Assembler syntax
UMULL{S}{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>
where:
S If S is present, the instruction updates the flags. Otherwise, the flags are not updated.
S can be specified only for the ARM instruction set.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<RdLo> Stores the lower 32 bits of the result.
<RdHi> Stores the upper 32 bits of the result.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax UMULL<c>S is equivalent to UMULLS<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
result = UInt(R[n]) * UInt(R[m]);
R[dHi] = result<63:32>;
R[dLo] = result<31:0>;
if setflags then
APSR.N = result<63>;
APSR.Z = IsZeroBit(result<63:0>);
if ArchVersion() == 4 then
APSR.C = bit UNKNOWN;
APSR.V = bit UNKNOWN;
// else APSR.C, APSR.V unchanged
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-780 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.258 UQADD16
Unsigned Saturating Add 16 performs two unsigned 16-bit integer additions, saturates the results to the 16-bit
unsigned integer range 0 ≤ x ≤ 216 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UQADD16<c> <Rd>, <Rn>, <Rm>
TOKENUQADD16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 1 Rn 1 1 1 1 Rd 0 1 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 0 Rn Rd (1) (1) (1) (1) 0 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-781
ID051414 Non-Confidential
Assembler syntax
UQADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);
sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);
R[d]<15:0> = UnsignedSat(sum1, 16);
R[d]<31:16> = UnsignedSat(sum2, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-782 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.259 UQADD8
Unsigned Saturating Add 8 performs four unsigned 8-bit integer additions, saturates the results to the 8-bit unsigned
integer range 0 ≤ x ≤ 28 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UQADD8<c> <Rd>, <Rn>, <Rm>
TOKENUQADD8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 0 0 Rn 1 1 1 1 Rd 0 1 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 0 Rn Rd (1) (1) (1) (1) 1 0 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-783
ID051414 Non-Confidential
Assembler syntax
UQADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);
sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);
sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);
sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);
R[d]<7:0> = UnsignedSat(sum1, 8);
R[d]<15:8> = UnsignedSat(sum2, 8);
R[d]<23:16> = UnsignedSat(sum3, 8);
R[d]<31:24> = UnsignedSat(sum4, 8);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-784 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.260 UQASX
Unsigned Saturating Add and Subtract with Exchange exchanges the two halfwords of the second operand,
performs one unsigned 16-bit integer addition and one unsigned 16-bit subtraction, saturates the results to the 16-bit
unsigned integer range 0 ≤ x ≤ 216 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UQASX<c> <Rd>, <Rn>, <Rm>
TOKENUQASX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 0 1 0 Rn 1 1 1 1 Rd 0 1 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 0 Rn Rd (1) (1) (1) (1) 0 0 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-785
ID051414 Non-Confidential
Assembler syntax
UQASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax UQADDSUBX<c> is equivalent to UQASX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);
sum = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);
R[d]<15:0> = UnsignedSat(diff, 16);
R[d]<31:16> = UnsignedSat(sum, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-786 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.261 UQSAX
Unsigned Saturating Subtract and Add with Exchange exchanges the two halfwords of the second operand,
performs one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, saturates the results to the 16-bit
unsigned integer range 0 ≤ x ≤ 216 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UQSAX<c> <Rd>, <Rn>, <Rm>
TOKENUQSAX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 1 0 Rn 1 1 1 1 Rd 0 1 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 0 Rn Rd (1) (1) (1) (1) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-787
ID051414 Non-Confidential
Assembler syntax
UQSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax UQSUBADDX<c> is equivalent to UQSAX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
R[d]<15:0> = UnsignedSat(sum, 16);
R[d]<31:16> = UnsignedSat(diff, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-788 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.262 UQSUB16
Unsigned Saturating Subtract 16 performs two unsigned 16-bit integer subtractions, saturates the results to the
16-bit unsigned integer range 0 ≤ x ≤ 216 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UQSUB16<c> <Rd>, <Rn>, <Rm>
TOKENUQSUB16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 1 Rn 1 1 1 1 Rd 0 1 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 0 Rn Rd (1) (1) (1) (1) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-789
ID051414 Non-Confidential
Assembler syntax
UQSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
R[d]<15:0> = UnsignedSat(diff1, 16);
R[d]<31:16> = UnsignedSat(diff2, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-790 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.263 UQSUB8
Unsigned Saturating Subtract 8 performs four unsigned 8-bit integer subtractions, saturates the results to the 8-bit
unsigned integer range 0 ≤ x ≤ 28 – 1, and writes the results to the destination register.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UQSUB8<c> <Rd>, <Rn>, <Rm>
TOKENUQSUB8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 0 Rn 1 1 1 1 Rd 0 1 0 1 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 1 0 Rn Rd (1) (1) (1) (1) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-791
ID051414 Non-Confidential
Assembler syntax
UQSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
R[d]<7:0> = UnsignedSat(diff1, 8);
R[d]<15:8> = UnsignedSat(diff2, 8);
R[d]<23:16> = UnsignedSat(diff3, 8);
R[d]<31:24> = UnsignedSat(diff4, 8);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-792 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.264 USAD8
Unsigned Sum of Absolute Differences performs four unsigned 8-bit subtractions, and adds the absolute values of
the differences together.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
USAD8<c> <Rd>, <Rn>, <Rm>
TOKENUSAD8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 1 0 1 1 1 Rn 1 1 1 1 Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 1 0 0 0 Rd 1 1 1 1 Rm 0 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-793
ID051414 Non-Confidential
Assembler syntax
USAD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
absdiff1 = Abs(UInt(R[n]<7:0>) - UInt(R[m]<7:0>));
absdiff2 = Abs(UInt(R[n]<15:8>) - UInt(R[m]<15:8>));
absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));
absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));
result = absdiff1 + absdiff2 + absdiff3 + absdiff4;
R[d] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-794 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.265 USADA8
Unsigned Sum of Absolute Differences and Accumulate performs four unsigned 8-bit subtractions, and adds the
absolute values of the differences to a 32-bit accumulate operand.
if Ra == ‘1111’ then SEE USAD8;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
if d IN {13,15} || n IN {13,15} || m IN {13,15} || a == 13 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Ra == ‘1111’ then SEE USAD8;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
USADA8<c> <Rd>, <Rn>, <Rm>, <Ra>
TOKENUSADA8<c> <Rd>, <Rn>, <Rm>, <Ra>
1 1 1 1 0 1 1 0 1 1 1 Rn Ra Rd 0 0 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 1 1 0 0 0 Rd Ra Rm 0 0 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-795
ID051414 Non-Confidential
Assembler syntax
USADA8{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<Ra> The register that contains the accumulation value.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
absdiff1 = Abs(UInt(R[n]<7:0>) - UInt(R[m]<7:0>));
absdiff2 = Abs(UInt(R[n]<15:8>) - UInt(R[m]<15:8>));
absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));
absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));
result = UInt(R[a]) + absdiff1 + absdiff2 + absdiff3 + absdiff4;
R[d] = result<31:0>;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-796 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.266 USAT
Unsigned Saturate saturates an optionally-shifted signed value to a selected unsigned range.
The Q flag is set if the operation saturates.
if sh == ‘1’ && (imm3:imm2) == ‘00000’ then SEE USAT16;
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);
(shift_t, shift_n) = DecodeImmShift(sh:’0’, imm3:imm2);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);
(shift_t, shift_n) = DecodeImmShift(sh:’0’, imm5);
if d == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
USAT<c> <Rd>, #<imm5>, <Rn>{, <shift>}
TOKENUSAT<c> <Rd>, #<imm5>, <Rn>{, <shift>}
1 1 1 0 (0) 1 1 1 0 sh 0 Rn 0 imm3 Rd imm2 (0) sat_imm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 1 sat_imm Rd imm5 sh 0 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-797
ID051414 Non-Confidential
Assembler syntax
USAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, <shift>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<imm> The bit position for saturation, in the range 0 to 31. This is encoded directly in the sat_imm field of
the instruction, meaning sat_imm takes the value of <imm>.
<Rn> The register that contains the value to be saturated.
<shift> The optional shift, encoded in the sh bit and the immsh field, where immsh is:
• imm3:imm2 for encoding T1
• imm5 for encoding A1.
<shift> must be one of:
omitted No shift. Encoded as sh = 0, immsh = 0b00000.
LSL #<n> Left shift by <n> bits, with <n> in the range 1-31.
Encoded as sh = 0, immsh = <n>.
ASR #<n> Arithmetic right shift by <n> bits, with <n> in the range 1-31.
Encoded as sh = 1, immsh = <n>.
ASR #32 Arithmetic right shift by 32 bits, permitted only for encoding A1.
Encoded as sh = 1, immsh = 0b00000.
Note
An assembler can permit ASR #0 or LSL #0 to mean the same thing as omitting the shift, but this is
not standard UAL and must not be used for disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
operand = Shift(R[n], shift_t, shift_n, APSR.C); // APSR.C ignored
(result, sat) = UnsignedSatQ(SInt(operand), saturate_to);
R[d] = ZeroExtend(result, 32);
if sat then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-798 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.267 USAT16
Unsigned Saturate 16 saturates two signed 16-bit values to a selected unsigned range.
The Q flag is set if the operation saturates.
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);
if d IN {13,15} || n IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);
if d == 15 || n == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
USAT16<c> <Rd>, #<imm4>, <Rn>
TOKENUSAT16<c> <Rd>, #<imm4>, <Rn>
1 1 1 0 (0) 1 1 1 0 1 0 Rn 0 0 0 0 Rd 0 0 (0) (0) sat_imm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 1 0 sat_imm Rd (1) (1) (1) (1) 0 0 1 1 Rn
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-799
ID051414 Non-Confidential
Assembler syntax
USAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<imm> The bit position for saturation, in the range 0 to 15. This is encoded directly in the sat_imm field of
the instruction, meaning sat_imm takes the value of <imm>.
<Rn> The register that contains the values to be saturated.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
(result1, sat1) = UnsignedSatQ(SInt(R[n]<15:0>), saturate_to);
(result2, sat2) = UnsignedSatQ(SInt(R[n]<31:16>), saturate_to);
R[d]<15:0> = ZeroExtend(result1, 16);
R[d]<31:16> = ZeroExtend(result2, 16);
if sat1 || sat2 then
APSR.Q = ‘1’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-800 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.268 USAX
Unsigned Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one
unsigned 16-bit integer subtraction and one unsigned 16-bit addition, and writes the results to the destination
register. It sets the APSR.GE bits according to the results.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
USAX<c> <Rd>, <Rn>, <Rm>
TOKENUSAX<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 1 0 Rn 1 1 1 1 Rd 0 1 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 0 1 Rn Rd (1) (1) (1) (1) 0 1 0 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-801
ID051414 Non-Confidential
Assembler syntax
USAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
The pre-UAL syntax USUBADDX<c> is equivalent to USAX<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
sum = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);
diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);
R[d]<15:0> = sum<15:0>;
R[d]<31:16> = diff<15:0>;
APSR.GE<1:0> = if sum >= 0x10000 then ‘11’ else ‘00’;
APSR.GE<3:2> = if diff >= 0 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-802 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.269 USUB16
Unsigned Subtract 16 performs two 16-bit unsigned integer subtractions, and writes the results to the destination
register. It sets the APSR.GE bits according to the results of the subtractions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
USUB16<c> <Rd>, <Rn>, <Rm>
TOKENUSUB16<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 1 Rn 1 1 1 1 Rd 0 1 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 0 1 Rn Rd (1) (1) (1) (1) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-803
ID051414 Non-Confidential
Assembler syntax
USUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);
diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);
R[d]<15:0> = diff1<15:0>;
R[d]<31:16> = diff2<15:0>;
APSR.GE<1:0> = if diff1 >= 0 then ‘11’ else ‘00’;
APSR.GE<3:2> = if diff2 >= 0 then ‘11’ else ‘00’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-804 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.270 USUB8
Unsigned Subtract 8 performs four 8-bit unsigned integer subtractions, and writes the results to the destination
register. It sets the APSR.GE bits according to the results of the subtractions.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d IN {13,15} || n IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
USUB8<c> <Rd>, <Rn>, <Rm>
TOKENUSUB8<c> <Rd>, <Rn>, <Rm>
1 1 1 1 0 1 0 1 1 0 0 Rn 1 1 1 1 Rd 0 1 0 0 Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 0 1 0 1 Rn Rd (1) (1) (1) (1) 1 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-805
ID051414 Non-Confidential
Assembler syntax
USUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);
diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);
diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);
diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);
R[d]<7:0> = diff1<7:0>;
R[d]<15:8> = diff2<7:0>;
R[d]<23:16> = diff3<7:0>;
R[d]<31:24> = diff4<7:0>;
APSR.GE<0> = if diff1 >= 0 then ‘1’ else ‘0’;
APSR.GE<1> = if diff2 >= 0 then ‘1’ else ‘0’;
APSR.GE<2> = if diff3 >= 0 then ‘1’ else ‘0’;
APSR.GE<3> = if diff4 >= 0 then ‘1’ else ‘0’;
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-806 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.271 UXTAB
Unsigned Extend and Add Byte extracts an 8-bit value from a register, zero-extends it to 32 bits, adds the result to
the value in another register, and writes the final result to the destination register. The instruction can specify a
rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.
if Rn == ‘1111’ then SEE UXTB;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE UXTB;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UXTAB<c> <Rd>, <Rn>, <Rm>{, <rotation>}
TOKENUXTAB<c> <Rd>, <Rn>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 1 0 1 Rn 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 1 0 Rn Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-807
ID051414 Non-Confidential
Assembler syntax
UXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = R[n] + ZeroExtend(rotated<7:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-808 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.272 UXTAB16
Unsigned Extend and Add Byte 16 extracts two 8-bit values from a register, zero-extends them to 16 bits each, adds
the results to two 16-bit values from another register, and writes the final results to the destination register. The
instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values.
if Rn == ‘1111’ then SEE UXTB16;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE UXTB16;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UXTAB16<c> <Rd>, <Rn>, <Rm>{, <rotation>}
TOKENUXTAB16<c> <Rd>, <Rn>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 0 1 1 Rn 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 0 0 Rn Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-809
ID051414 Non-Confidential
Assembler syntax
UXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d]<15:0> = R[n]<15:0> + ZeroExtend(rotated<7:0>, 16);
R[d]<31:16> = R[n]<31:16> + ZeroExtend(rotated<23:16>, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-810 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.273 UXTAH
Unsigned Extend and Add Halfword extracts a 16-bit value from a register, zero-extends it to 32 bits, adds the result
to a value from another register, and writes the final result to the destination register. The instruction can specify a
rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.
if Rn == ‘1111’ then SEE UXTH;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || n == 13 || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Rn == ‘1111’ then SEE UXTH;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UXTAH<c> <Rd>, <Rn>, <Rm>{, <rotation>}
TOKENUXTAH<c> <Rd>, <Rn>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 0 0 1 Rn 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 1 1 Rn Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-811
ID051414 Non-Confidential
Assembler syntax
UXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rn> The first operand register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = R[n] + ZeroExtend(rotated<15:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-812 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.274 UXTB
Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to 32 bits, and writes the result to the
destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.
d = UInt(Rd); m = UInt(Rm); rotation = 0;
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7
UXTB<c> <Rd>, <Rm>
Encoding T2 ARMv6T2, ARMv7
UXTB<c>.W <Rd>, <Rm>{, <rotation>}
TOKENUXTB<c> <Rd>, <Rm>{, <rotation>}
1 0 1 1 0 0 1 0 1 1 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 Rd 1 (0) Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
rotate
cond 0 1 1 0 1 1 1 0 1 1 1 1 Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-813
ID051414 Non-Confidential
Assembler syntax
UXTB{<c>}{<q>} {<Rd>,} <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted any encoding, encoded as rotate = 0b00 in encoding T2 or A1
ROR #8 encoding T2 or A1, encoded as rotate = 0b01
ROR #16 encoding T2 or A1, encoded as rotate = 0b10
ROR #24 encoding T2 or A1, encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
The pre-UAL syntax UEXT8<c> is equivalent to UXTB<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = ZeroExtend(rotated<7:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-814 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.275 UXTB16
Unsigned Extend Byte 16 extracts two 8-bit values from a register, zero-extends them to 16 bits each, and writes
the results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting
the 8-bit values.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6T2, ARMv7
UXTB16<c> <Rd>, <Rm>{, <rotation>}
TOKENUXTB16<c> <Rd>, <Rm>{, <rotation>}
1 1 1 1 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 0 0 1 1 1 1 Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-815
ID051414 Non-Confidential
Assembler syntax
UXTB16{<c>}{<q>} {<Rd>,} <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted encoded as rotate = 0b00
ROR #8 encoded as rotate = 0b01
ROR #16 encoded as rotate = 0b10
ROR #24 encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d]<15:0> = ZeroExtend(rotated<7:0>, 16);
R[d]<31:16> = ZeroExtend(rotated<23:16>, 16);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-816 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.276 UXTH
Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to 32 bits, and writes the result to
the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit
value.
d = UInt(Rd); m = UInt(Rm); rotation = 0;
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d IN {13,15} || m IN {13,15} then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:’000’);
if d == 15 || m == 15 then UNPREDICTABLE;
Encoding T1 ARMv6*, ARMv7
UXTH<c> <Rd>, <Rm>
Encoding T2 ARMv6T2, ARMv7
UXTH<c>.W <Rd>, <Rm>{, <rotation>}
TOKENUXTH<c> <Rd>, <Rm>{, <rotation>}
1 0 1 1 0 0 1 0 1 0 Rm Rd
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 1 0 0 0 0 1 1 1 1 1 1 1 1 1 Rd 1 (0) rotate Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 1 1 0 1 1 1 1 1 1 1 1 Rd rotate (0) (0) 0 1 1 1 Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-817
ID051414 Non-Confidential
Assembler syntax
UXTH{<c>}{<q>} {<Rd>,} <Rm> {, <rotation>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rd> The destination register.
<Rm> The second operand register.
<rotation> This can be any one of:
omitted any encoding, encoded as rotate = 0b00 in encoding T2 or A1
ROR #8 encoding T2 or A1, encoded as rotate = 0b01
ROR #16 encoding T2 or A1, encoded as rotate = 0b10
ROR #24 encoding T2 or A1, encoded as rotate = 0b11.
Note
An assembler can permit ROR #0 to mean the same thing as omitting the rotation, possibly with
restrictions on the permitted encodings, but this is not standard UAL and must not be used for
disassembly.
The pre-UAL syntax UEXT16<c> is equivalent to UXTH<c>.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
rotated = ROR(R[m], rotation);
R[d] = ZeroExtend(rotated<15:0>, 32);
Exceptions
None.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-818 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.277 VABA, VABAL
Vector Absolute Difference and Accumulate {Long} subtracts the elements of one vector from the corresponding
elements of another vector, and accumulates the absolute values of the results into the elements of the destination
vector.
Operand and result elements are either all integers of the same length, or optionally the results can be double the
length of the operands.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction that is not also available as a VFP
instruction, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’); long_destination = FALSE;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if size == ‘11’ then SEE “Related encodings”;
if Vd<0> == ‘1’ then UNDEFINED;
unsigned = (U == ‘1’); long_destination = TRUE;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;
Encoding T1/A1 Advanced SIMD
VABA<c>.<dt> <Qd>, <Qn>, <Qm>
VABA<c>.<dt> <Dd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
VABAL<c>.<dt> <Qd>, <Dn>, <Dm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 U 1 1 1 1 0 D size Vn Vd 0 1 1 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 1 1 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 U 1 1 1 1 1 D size Vn Vd 0 1 0 1 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D size Vn Vd 0 1 0 1 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-819
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VABA or VABAL instruction
must be unconditional. ARM strongly recommends that a Thumb VABA or VABAL instruction
is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
S8 encoded as size = 0b00, U = 0.
S16 encoded as size = 0b01, U = 0.
S32 encoded as size = 0b10, U = 0.
U8 encoded as size = 0b00, U = 1.
U16 encoded as size = 0b01, U = 1.
U32 encoded as size = 0b10, U = 1.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Qd>, <Dn>, <Dm> The destination vector and the operand vectors, for a long operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[Din[n+r],e,esize];
op2 = Elem[Din[m+r],e,esize];
absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
if long_destination then
Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;
else
Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;
Exceptions
Undefined Instruction, Hyp Trap.
VABA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm> Encoding T1/A1, Q = 1
VABA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm> Encoding T1/A1, Q = 0
VABAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm> Encoding T2/A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-820 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.278 VABD, VABDL (integer)
Vector Absolute Difference {Long} (integer) subtracts the elements of one vector from the corresponding elements
of another vector, and places the absolute values of the results in the elements of the destination vector.
Operand and result elements are either all integers of the same length, or optionally the results can be double the
length of the operands.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction that is not also available as a VFP
instruction, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’); long_destination = FALSE;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if size == ‘11’ then SEE “Related encodings”;
if Vd<0> == ‘1’ then UNDEFINED;
unsigned = (U == ‘1’); long_destination = TRUE;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;
Encoding T1/A1 Advanced SIMD
VABD<c>.<dt> <Qd>, <Qn>, <Qm>
VABD<c>.<dt> <Dd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
VABDL<c>.<dt> <Qd>, <Dn>, <Dm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 U 1 1 1 1 0 D size Vn Vd 0 1 1 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 1 1 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 U 1 1 1 1 1 D size Vn Vd 0 1 1 1 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D size Vn Vd 0 1 1 1 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-821
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VABD or VABDL instruction
must be unconditional. ARM strongly recommends that a Thumb VABD or VABDL instruction
is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
S8 encoded as size = 0b00, U = 0.
S16 encoded as size = 0b01, U = 0.
S32 encoded as size = 0b10, U = 0.
U8 encoded as size = 0b00, U = 1.
U16 encoded as size = 0b01, U = 1.
U32 encoded as size = 0b10, U = 1.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Qd>, <Dn>, <Dm> The destination vector and the operand vectors, for a long operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[Din[n+r],e,esize];
op2 = Elem[Din[m+r],e,esize];
absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
if long_destination then
Elem[Q[d>>1],e,2*esize] = absdiff<2*esize-1:0>;
else
Elem[D[d+r],e,esize] = absdiff<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm> Encoding T1/A1, Q = 1
VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm> Encoding T1/A1, Q = 0
VABDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm> Encoding T2/A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-822 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.279 VABD (floating-point)
Vector Absolute Difference (floating-point) subtracts the elements of one vector from the corresponding elements
of another vector, and places the absolute values of the results in the elements of the destination vector.
Operand and result elements are all single-precision floating-point numbers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction that is not also available as a VFP
instruction, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VABD<c>.F32 <Qd>, <Qn>, <Qm>
VABD<c>.F32 <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D 1 sz Vn Vd 1 1 0 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D 1 sz Vn Vd 1 1 0 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-823
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VABD instruction must be
unconditional. ARM strongly recommends that a Thumb VABD instruction is unconditional,
see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[D[n+r],e,esize]; op2 = Elem[D[m+r],e,esize];
Elem[D[d+r],e,esize] = FPAbs(FPSub(op1,op2,FALSE));
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
VABD{<c>}{<q>}.F32 {<Qd>, }<Qn>, <Qm> Encoded as Q = 1, sz = 0
VABD{<c>}{<q>}.F32 {<Dd>, }<Dn>, <Dm> Encoded as Q = 0, sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-824 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.280 VABS
Vector Absolute takes the absolute value of each element in a vector, and places the results in a second vector. The
floating-point version only clears the sign bit.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction that is not also available as a VFP
instruction, see Conditional execution on page A8-288.
if size == ‘11’ || (F == ‘1’ && size != ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
advsimd = TRUE; floating_point = (F == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
advsimd = FALSE; dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VABS<c>.<dt> <Qd>, <Qm>
VABS<c>.<dt> <Dd>, <Dm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VABS<c>.F64 <Dd>, <Dm>
VABS<c>.F32 <Sd>, <Sm>
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride}
fields. For details see Appendix D11 VFP Vector Operation Support.
1 1 1 1 1 1 1 1 D 1 1 size 0 1 Vd 0 F 1 1 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 1 Vd 0 F 1 1 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 1 D 1 1 0 0 0 0 Vd 1 0 1 sz 1 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 0 0 0 Vd 1 0 1 sz 1 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-825
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VABS instruction
must be unconditional. ARM strongly recommends that a Thumb Advanced SIMD VABS instruction
is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoded as size = 0b00, F = 0.
S16 Encoded as size = 0b01, F = 0.
S32 Encoded as size = 0b10, F = 0.
F32 Encoded as size = 0b10, F = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
<Sd>, <Sm> The destination vector and the operand vector, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
Elem[D[d+r],e,esize] = FPAbs(Elem[D[m+r],e,esize]);
else
result = Abs(SInt(Elem[D[m+r],e,esize]));
Elem[D[d+r],e,esize] = result<esize-1:0>;
else // VFP instruction
if dp_operation then
D[d] = FPAbs(D[m]);
else
S[d] = FPAbs(S[m]);
Exceptions
Undefined Instruction, Hyp Trap.
VABS{<c>}{<q>}.<dt> <Qd>, <Qm> Encoding T1/A1
VABS{<c>}{<q>}.<dt> <Dd>, <Dm> Encoding T1/A1
VABS{<c>}{<q>}.F32 <Sd>, <Sm> Floating-point only, encoding T2/A2, encoded as sz = 0
VABS{<c>}{<q>}.F64 <Dd>, <Dm> Encoding T2/A2, encoded as sz = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-826 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.281 VACGE, VACGT, VACLE, VACLT
VACGE (Vector Absolute Compare Greater Than or Equal) and VACGT (Vector Absolute Compare Greater Than) take
the absolute value of each element in a vector, and compare it with the absolute value of the corresponding element
of a second vector. If the condition is true, the corresponding element in the destination vector is set to all ones.
Otherwise, it is set to all zeros.
VACLE (Vector Absolute Compare Less Than or Equal) is a pseudo-instruction, equivalent to a VACGE instruction with
the operands reversed. Disassembly produces the VACGE instruction.
VACLT (Vector Absolute Compare Less Than) is a pseudo-instruction, equivalent to a VACGT instruction with the
operands reversed. Disassembly produces the VACGT instruction.
The operands and result can be quadword or doubleword vectors. They must all be the same size.
The operand vector elements must be 32-bit floating-point numbers.
The result vector elements are 32-bit fields.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction that is not also available as a VFP
instruction, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
or_equal = (op == ‘0’); esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
V<op><c>.F32 <Qd>, <Qn>, <Qm>
V<op><c>.F32 <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D op sz Vn Vd 1 1 1 0 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D op sz Vn Vd 1 1 1 0 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-827
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
ACGE Absolute Compare Greater than or Equal, encoded as op = 0.
ACGT Absolute Compare Greater Than, encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VACGE, VACGT, VACLE, or
VACLT instruction must be unconditional.ARM strongly recommends that a Thumb VACGE,
VACGT, VACLE, or VACLT instruction is unconditional, see Conditional execution on
page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = FPAbs(Elem[D[n+r],e,esize]); op2 = FPAbs(Elem[D[m+r],e,esize]);
if or_equal then
test_passed = FPCompareGE(op1, op2, FALSE);
else
test_passed = FPCompareGT(op1, op2, FALSE);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
V<op>{<c>}{<q>}.F32 {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
V<op>{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-828 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.282 VADD (integer)
Vector Add adds corresponding elements in two vectors, and places the results in the destination vector.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VADD<c>.<dt> <Qd>, <Qn>, <Qm>
VADD<c>.<dt> <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D size Vn Vd 1 0 0 0 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D size Vn Vd 1 0 0 0 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-829
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VADD
instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VADD instruction is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
I8 size = 0b00.
I16 size = 0b01.
I32 size = 0b10.
I64 size = 0b11.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] + Elem[D[m+r],e,esize];
Exceptions
Undefined Instruction, Hyp Trap.
VADD{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>
VADD{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-830 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.283 VADD (floating-point)
Vector Add adds corresponding elements in two vectors, and places the results in the destination vector.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
advsimd = TRUE; esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
advsimd = FALSE; dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VADD<c>.F32 <Qd>, <Qn>, <Qm>
VADD<c>.F32 <Dd>, <Dn>, <Dm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VADD<c>.F64 <Dd>, <Dn>, <Dm>
VADD<c>.F32 <Sd>, <Sn>, <Sm>
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride}
fields. For details see Appendix D11 VFP Vector Operation Support.
1 1 0 1 1 1 1 0 D 0 sz Vn Vd 1 1 0 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 0 sz Vn Vd 1 1 0 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 0 D 1 1 Vn Vd 1 0 1 sz N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 D 1 1 Vn Vd 1 0 1 sz N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-831
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VADD
instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VADD instruction is unconditional, see Conditional execution on page A8-288
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Sd>, <Sn>, <Sm> The destination vector and the operand vectors, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = FPAdd(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], FALSE);
else // VFP instruction
if dp_operation then
D[d] = FPAdd(D[n], D[m], TRUE);
else
S[d] = FPAdd(S[n], S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
VADD{<c>}{<q>}.F32 {<Qd>,} <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1, sz = 0
VADD{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0, sz = 0
VADD{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm> Encoding T2/A2, encoded as sz = 0
VADD{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm> Encoding T2/A2, encoded as sz = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-832 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.284 VADDHN
Vector Add and Narrow, returning High Half adds corresponding elements in two quadword vectors, and places the
most significant half of each result in a doubleword vector. The results are truncated. (For rounded results, see
VRADDHN on page A8-1022).
The operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no distinction between signed and unsigned
integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if Vn<0> == ‘1’ || Vm<0> == ‘1’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VADDHN<c>.<dt> <Dd>, <Qn>, <Qm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 0 1 1 1 1 1 D size Vn Vd 0 1 0 0 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D size Vn Vd 0 1 0 0 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-833
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VADDHN instruction must be
unconditional.ARM strongly recommends that a Thumb VADDHN instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
I16 size = 0b00.
I32 size = 0b01.
I64 size = 0b10.
<Dd>, <Qn>, <Qm> The destination vector, the first operand vector, and the second operand vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize];
Elem[D[d],e,esize] = result<2*esize-1:esize>;
Exceptions
Undefined Instruction, Hyp Trap.
VADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-834 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.285 VADDL, VADDW
VADDL (Vector Add Long) adds corresponding elements in two doubleword vectors, and places the results in a
quadword vector. Before adding, it sign-extends or zero-extends the elements of both operands.
VADDW (Vector Add Wide) adds corresponding elements in one quadword and one doubleword vector, and places the
results in a quadword vector. Before adding, it sign-extends or zero-extends the elements of the doubleword
operand.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if Vd<0> == ‘1’ || (op == ‘1’ && Vn<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize; is_vaddw = (op == ‘1’);
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VADDL<c>.<dt> <Qd>, <Dn>, <Dm>
VADDW<c>.<dt> <Qd>, <Qn>, <Dm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 U 1 1 1 1 1 D size Vn Vd 0 0 0 op N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D size Vn Vd 0 0 0 op N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-835
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VADDL or VADDW instruction must be
unconditional. ARM strongly recommends that a Thumb VADDL or VADDW instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data type for the elements of the second operand vector. It must be one of:
S8 encoded as size = 0b00, U = 0.
S16 encoded as size = 0b01, U = 0.
S32 encoded as size = 0b10, U = 0.
U8 encoded as size = 0b00, U = 1.
U16 encoded as size = 0b01, U = 1.
U32 encoded as size = 0b10, U = 1.
<Qd> The destination register. If this register is omitted in a VADDW instruction, it is the same register as
<Qn>.
<Qn>, <Dm> The first and second operand registers for a VADDW instruction.
<Dn>, <Dm> The first and second operand registers for a VADDL instruction.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
if is_vaddw then
op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
else
op1 = Int(Elem[Din[n],e,esize], unsigned);
result = op1 + Int(Elem[Din[m],e,esize],unsigned);
Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VADDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm> Encoded as op = 0
VADDW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm> Encoded as op = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-836 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.286 VAND (immediate)
This is a pseudo-instruction, equivalent to a VBIC (immediate) instruction with the immediate value bitwise inverted.
For details see VBIC (immediate) on page A8-838.
A8.8.287 VAND (register)
This instruction performs a bitwise AND operation between two registers, and places the result in the destination
register.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VAND<c> <Qd>, <Qn>, <Qm>
VAND<c> <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D 0 0 Vn Vd 0 0 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 0 0 Vn Vd 0 0 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-837
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VAND instruction must be
unconditional. ARM strongly recommends that a Thumb VAND instruction is unconditional,
see Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = D[n+r] AND D[m+r];
Exceptions
Undefined Instruction, Hyp Trap.
VAND{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VAND{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-838 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.288 VBIC (immediate)
Vector Bitwise Bit Clear (immediate) performs a bitwise AND between a register value and the complement of an
immediate value, and returns the result into the destination vector. For the range of constants available, see One
register and a modified immediate value on page A7-269.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if cmode<0> == ‘0’ || cmode<3:2> == ‘11’ then SEE “Related encodings”;
if Q == ‘1’ && Vd<0> == ‘1’ then UNDEFINED;
imm64 = AdvSIMDExpandImm(‘1’, cmode, i:imm3:imm4);
d = UInt(D:Vd); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VBIC<c>.<dt> <Qd>, #<imm>
VBIC<c>.<dt> <Dd>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 i 1 1 1 1 1 D 0 0 0 imm3 Vd cmode 0 Q 1 1 imm4
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 i 1 D 0 0 0 imm3 Vd cmode 0 Q 1 1 imm4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-839
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VBIC instruction must be
unconditional. ARM strongly recommends that a Thumb VBIC instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type used for <imm>. It can be either I16 or I32.
I8, I64, and F32 are also permitted, but the resulting syntax is a pseudo-instruction.
<Qd> The destination vector for a quadword operation.
<Dd> The destination vector for a doubleword operation.
<imm> A constant of the type specified by <dt>. This constant is replicated enough times to fill the
destination register. For example, VBIC.I32 D0, #10 ANDs the complement of 0x0000000A0000000A
with D0, and puts the result into D0.
For details of the range of constants available and the encoding of <dt> and <imm>, see One register and a modified
immediate value on page A7-269.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = D[d+r] AND NOT(imm64);
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
VAND can be used with a range of constants that are the bitwise inverse of the available constants for VBIC. This is
assembled as the equivalent VBIC instruction. Disassembly produces the VBIC form.
One register and a modified immediate value on page A7-269 describes pseudo-instructions with a combination of
<dt> and <imm> that is not supported by hardware, but that generates the same destination register value as a different
combination that is supported by hardware.
VBIC{<c>}{<q>}.<dt> {<Qd>,} <Qd>, #<imm> Encoded as Q = 1
VBIC{<c>}{<q>}.<dt> {<Dd>,} <Dd>, #<imm>> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-840 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.289 VBIC (register)
Vector Bitwise Bit Clear (register) performs a bitwise AND between a register value and the complement of a
register value, and places the result in the destination register.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VBIC<c> <Qd>, <Qn>, <Qm>
VBIC<c> <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D 0 1 Vn Vd 0 0 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 0 1 Vn Vd 0 0 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-841
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VBIC instruction must be
unconditional. ARM strongly recommends that a Thumb VBIC instruction is unconditional,
see Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = D[n+r] AND NOT(D[m+r]);
Exceptions
Undefined Instruction, Hyp Trap.
VBIC{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VBIC{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-842 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.290 VBIF, VBIT, VBSL
VBIF (Vector Bitwise Insert if False), VBIT (Vector Bitwise Insert if True), and VBSL (Vector Bitwise Select) perform
bitwise selection under the control of a mask, and place the results in the destination register. The registers can be
either quadword or doubleword, and must all be the same size.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if op == ‘00’ then SEE VEOR;
if op == ‘01’ then operation = VBitOps_VBSL;
if op == ‘10’ then operation = VBitOps_VBIT;
if op == ‘11’ then operation = VBitOps_VBIF;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
V<op><c> <Qd>, <Qn>, <Qm>
V<op><c> <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D op Vn Vd 0 0 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D op Vn Vd 0 0 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-843
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
BIF Bitwise Insert if False, encoded as op = 0b11. Inserts each bit from Vn into Vd
if the corresponding bit of Vm is 0, otherwise leaves the Vd bit unchanged.
BIT Bitwise Insert if True, encoded as op = 0b10. Inserts each bit from Vn into Vd if
the corresponding bit of Vm is 1, otherwise leaves the Vd bit unchanged.
BSL Bitwise Select, encoded as op = 0b01. Selects each bit from Vn into Vd if the
corresponding bit of Vd is 1, otherwise selects the bit from Vm.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VBIF, VBIT, or VBSL
instruction must be unconditional. ARM strongly recommends that a Thumb VBIF, VBIT, or
VBSL instruction is unconditional, see Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
case operation of
when VBitOps_VBIF D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
when VBitOps_VBIT D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
when VBitOps_VBSL D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));
Exceptions
Undefined Instruction, Hyp Trap.
V<op>{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
V<op>{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-844 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.291 VCEQ (register)
VCEQ (Vector Compare Equal) takes each element in a vector, and compares it with the corresponding element of a
second vector. If they are equal, the corresponding element in the destination vector is set to all ones. Otherwise, it
is set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit integers. There is no distinction between signed and unsigned integers.
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘11’ then UNDEFINED;
int_operation = TRUE; esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
int_operation = FALSE; esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VCEQ<c>.<dt> <Qd>, <Qn>, <Qm> <dt> an integer type
VCEQ<c>.<dt> <Dd>, <Dn>, <Dm> <dt> an integer type
Encoding T2/A2 Advanced SIMD (UNDEFINED in integer-only variant)
VCEQ<c>.F32 <Qd>, <Qn>, <Qm>
VCEQ<c>.F32 <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D size Vn Vd 1 0 0 0 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D size Vn Vd 1 0 0 0 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 1 0 D 0 sz Vn Vd 1 1 1 0 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 0 sz Vn Vd 1 1 1 0 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-845
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCEQ instruction must be
unconditional. ARM strongly recommends that a Thumb VCEQ instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
I8 encoding T1/A1, size = 0b00.
I16 encoding T1/A1, size = 0b01.
I32 encoding T1/A1, size = 0b10.
F32 encoding T2/A2, sz = 0.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[D[n+r],e,esize]; op2 = Elem[D[m+r],e,esize];
if int_operation then
test_passed = (op1 == op2);
else
test_passed = FPCompareEQ(op1, op2, FALSE);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCEQ{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VCEQ{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-846 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.292 VCEQ (immediate #0)
VCEQ #0 (Vector Compare Equal to zero) takes each element in a vector, and compares it with zero. If it is equal to
zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit integers. There is no distinction between signed and unsigned integers.
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (F == ‘1’ && size != ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
floating_point = (F == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VCEQ<c>.<dt> <Qd>, <Qm>, #0
VCEQ<c>.<dt> <Dd>, <Dm>, #0
1 1 1 1 1 1 1 1 D 1 1 size 0 1 Vd 0 F 0 1 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 1 Vd 0 F 0 1 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-847
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCEQ instruction must be
unconditional. ARM strongly recommends that a Thumb VCEQ instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
I8 encoded as size = 0b00, F = 0.
I16 encoded as size = 0b01, F = 0.
I32 encoded as size = 0b10, F = 0.
F32 encoded as size = 0b10, F = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
test_passed = FPCompareEQ(Elem[D[m+r],e,esize], FPZero(‘0’,esize), FALSE);
else
test_passed = (Elem[D[m+r],e,esize] == Zeros(esize));
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCEQ{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0 Encoded as Q = 1
VCEQ{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0 Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-848 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.293 VCGE (register)
VCGE (Vector Compare Greater Than or Equal) takes each element in a vector, and compares it with the
corresponding element of a second vector. If the first is greater than or equal to the second, the corresponding
element in the destination vector is set to all ones. Otherwise, it is set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 8-bit, 16-bit, or 32-bit unsigned integers
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘11’ then UNDEFINED;
type = if U == ‘1’ then VCGEtype_unsigned else VCGEtype_signed;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
type = VCGEtype_fp; esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VCGE<c>.<dt> <Qd>, <Qn>, <Qm> <dt> an integer type
VCGE<c>.<dt> <Dd>, <Dn>, <Dm> <dt> an integer type
Encoding T2/A2 Advanced SIMD (UNDEFINED in integer-only variant)
VCGE<c>.F32 <Qd>, <Qn>, <Qm>
VCGE<c>.F32 <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 0 0 1 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 0 1 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 1 1 1 1 1 0 D 0 sz Vn Vd 1 1 1 0 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D 0 sz Vn Vd 1 1 1 0 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-849
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCGE instruction must be
unconditional. ARM strongly recommends that a Thumb VCGE instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
S8 encoding T1/A1, encoded as size = 0b00, U = 0.
S16 encoding T1/A1, encoded as size = 0b01, U = 0.
S32 encoding T1/A1, encoded as size = 0b10, U = 0.
U8 encoding T1/A1, encoded as size = 0b00, U = 1.
U16 encoding T1/A1, encoded as size = 0b01, U = 1.
U32 encoding T1/A1, encoded as size = 0b10, U = 1.
F32 encoding T2/A2, encoded as sz = 0.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
enumeration VCGEtype {VCGEtype_signed, VCGEtype_unsigned, VCGEtype_fp};
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[D[n+r],e,esize]; op2 = Elem[D[m+r],e,esize];
case type of
when VCGEtype_signed test_passed = (SInt(op1) >= SInt(op2));
when VCGEtype_unsigned test_passed = (UInt(op1) >= UInt(op2));
when VCGEtype_fp test_passed = FPCompareGE(op1, op2, FALSE);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCGE{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VCGE{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-850 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.294 VCGE (immediate #0)
VCGE #0 (Vector Compare Greater Than or Equal to Zero) take each element in a vector, and compares it with zero.
If it is greater than or equal to zero, the corresponding element in the destination vector is set to all ones. Otherwise,
it is set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (F == ‘1’ && size != ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
floating_point = (F == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VCGE<c>.<dt> <Qd>, <Qm>, #0
VCGE<c>.<dt> <Dd>, <Dm>, #0
1 1 1 1 1 1 1 1 D 1 1 size 0 1 Vd 0 F 0 0 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 1 Vd 0 F 0 0 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-851
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCGE instruction must be
unconditional. ARM strongly recommends that a Thumb VCGE instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
S8 encoded as size = 0b00, F = 0.
S16 encoded as size = 0b01, F = 0.
S32 encoded as size = 0b10, F = 0.
F32 encoded as size = 0b10, F = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
test_passed = FPCompareGE(Elem[D[m+r],e,esize], FPZero(‘0’,esize), FALSE);
else
test_passed = (SInt(Elem[D[m+r],e,esize]) >= 0);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCGE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0 Encoded as Q = 1
VCGE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0 Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-852 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.295 VCGT (register)
VCGT (Vector Compare Greater Than) takes each element in a vector, and compares it with the corresponding element
of a second vector. If the first is greater than the second, the corresponding element in the destination vector is set
to all ones. Otherwise, it is set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 8-bit, 16-bit, or 32-bit unsigned integers
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘11’ then UNDEFINED;
type = if U == ‘1’ then VCGTtype_unsigned else VCGTtype_signed;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
type = VCGTtype_fp; esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VCGT<c>.<dt> <Qd>, <Qn>, <Qm> <dt> an integer type
VCGT<c>.<dt> <Dd>, <Dn>, <Dm> <dt> an integer type
Encoding T2/A2 Advanced SIMD (UNDEFINED in integer-only variant)
VCGT<c>.F32 <Qd>, <Qn>, <Qm>
VCGT<c>.F32 <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 0 0 1 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 0 1 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 1 1 1 1 1 0 D 1 sz Vn Vd 1 1 1 0 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D 1 sz Vn Vd 1 1 1 0 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-853
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCGT instruction must be
unconditional. ARM strongly recommends that a Thumb VCGT instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
S8 encoding T1/A1, encoded as size = 0b00, U = 0.
S16 encoding T1/A1, encoded as size = 0b01, U = 0.
S32 encoding T1/A1, encoded as size = 0b10, U = 0.
U8 encoding T1/A1, encoded as size = 0b00, U = 1.
U16 encoding T1/A1, encoded as size = 0b01, U = 1.
U32 encoding T1/A1, encoded as size = 0b10, U = 1.
F32 encoding T2/A2, encoded as sz = 0.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
enumeration VCGTtype {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp};
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[D[n+r],e,esize]; op2 = Elem[D[m+r],e,esize];
case type of
when VCGTtype_signed test_passed = (SInt(op1) > SInt(op2));
when VCGTtype_unsigned test_passed = (UInt(op1) > UInt(op2));
when VCGTtype_fp test_passed = FPCompareGT(op1, op2, FALSE);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCGT{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VCGT{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-854 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.296 VCGT (immediate #0)
VCGT #0 (Vector Compare Greater Than Zero) take each element in a vector, and compares it with zero. If it is greater
than zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (F == ‘1’ && size != ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
floating_point = (F == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VCGT<c>.<dt> <Qd>, <Qm>, #0
VCGT<c>.<dt> <Dd>, <Dm>, #0
1 1 1 1 1 1 1 1 D 1 1 size 0 1 Vd 0 F 0 0 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 1 Vd 0 F 0 0 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-855
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCGT instruction must be
unconditional. ARM strongly recommends that a Thumb VCGT instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
S8 encoded as size = 0b00, F = 0.
S16 encoded as size = 0b01, F = 0.
S32 encoded as size = 0b10, F = 0.
F32 encoded as size = 0b10, F = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
test_passed = FPCompareGT(Elem[D[m+r],e,esize], FPZero(‘0’,esize), FALSE);
else
test_passed = (SInt(Elem[D[m+r],e,esize]) > 0);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCGT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0 Encoded as Q = 1
VCGT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0 Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-856 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.297 VCLE (register)
VCLE is a pseudo-instruction, equivalent to a VCGE instruction with the operands reversed. For details see VCGE
(register) on page A8-848.
A8.8.298 VCLE (immediate #0)
VCLE #0 (Vector Compare Less Than or Equal to Zero) take each element in a vector, and compares it with zero. If
it is less than or equal to zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is
set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (F == ‘1’ && size != ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
floating_point = (F == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VCLE<c>.<dt> <Qd>, <Qm>, #0
VCLE<c>.<dt> <Dd>, <Dm>, #0
1 1 1 1 1 1 1 1 D 1 1 size 0 1 Vd 0 F 0 1 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 1 Vd 0 F 0 1 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-857
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCLE instruction must be
unconditional. ARM strongly recommends that a Thumb VCLE instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
S8 encoded as size = 0b00, F = 0.
S16 encoded as size = 0b01, F = 0.
S32 encoded as size = 0b10, F = 0.
F32 encoded as size = 0b10, F = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
test_passed = FPCompareGE(FPZero(‘0’,esize), Elem[D[m+r],e,esize], FALSE);
else
test_passed = (SInt(Elem[D[m+r],e,esize]) <= 0);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCLE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0 Encoded as Q = 1
VCLE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0 Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-858 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.299 VCLS
Vector Count Leading Sign Bits counts the number of consecutive bits following the topmost bit, that are the same
as the topmost bit, in each element in a vector, and places the results in a second vector. The count does not include
the topmost bit itself.
The operand vector elements can be any one of 8-bit, 16-bit, or 32-bit signed integers.
The result vector elements are the same data type as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VCLS<c>.<dt> <Qd>, <Qm>
VCLS<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 1 0 0 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 1 0 0 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-859
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCLS instruction must be
unconditional. ARM strongly recommends that a Thumb VCLS instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data size for the elements of the operands. It must be one of:
S8 encoded as size = 0b00.
S16 encoded as size = 0b01.
S32 encoded as size = 0b10.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = CountLeadingSignBits(Elem[D[m+r],e,esize])<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VCLS{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VCLS{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-860 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.300 VCLT (register)
VCLT is a pseudo-instruction, equivalent to a VCGT instruction with the operands reversed. For details see VCGT
(register) on page A8-852.
A8.8.301 VCLT (immediate #0)
VCLT #0 (Vector Compare Less Than Zero) take each element in a vector, and compares it with zero. If it is less than
zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 32-bit floating-point numbers.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (F == ‘1’ && size != ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
floating_point = (F == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VCLT<c>.<dt> <Qd>, <Qm>, #0
VCLT<c>.<dt> <Dd>, <Dm>, #0
1 1 1 1 1 1 1 1 D 1 1 size 0 1 Vd 0 F 1 0 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 1 Vd 0 F 1 0 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-861
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCLT instruction must be
unconditional. ARM strongly recommends that a Thumb VCLT instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data types for the elements of the operands. It must be one of:
S8 encoded as size = 0b00, F = 0.
S16 encoded as size = 0b01, F = 0.
S32 encoded as size = 0b10, F = 0.
F32 encoded as size = 0b10, F = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
test_passed = FPCompareGT(FPZero(‘0’,esize), Elem[D[m+r],e,esize], FALSE);
else
test_passed = (SInt(Elem[D[m+r],e,esize]) < 0);
Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation.
VCLT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0 Encoded as Q = 1
VCLT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0 Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-862 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.302 VCLZ
Vector Count Leading Zeros counts the number of consecutive zeros, starting from the most significant bit, in each
element in a vector, and places the results in a second vector.
The operand vector elements can be any one of 8-bit, 16-bit, or 32-bit integers. There is no distinction between
signed and unsigned integers.
The result vector elements are the same data type as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VCLZ<c>.<dt> <Qd>, <Qm>
VCLZ<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 1 0 0 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 1 0 0 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-863
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCLZ instruction must be
unconditional. ARM strongly recommends that a Thumb VCLZ instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data size for the elements of the operands. It must be one of:
I8 encoded as size = 0b00.
I16 encoded as size = 0b01.
I32 encoded as size = 0b10.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = CountLeadingZeroBits(Elem[D[m+r],e,esize])<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VCLZ{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VCLZ{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-864 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.303 VCMP, VCMPE
This instruction compares two floating-point registers, or one floating-point register and zero. It writes the result to
the FPSCR flags. These are normally transferred to the ARM flags by a subsequent VMRS instruction.
It can optionally raise an Invalid Operation exception if either operand is any type of NaN. It always raises an Invalid
Operation exception if either operand is a signaling NaN.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dp_operation = (sz == ‘1’); quiet_nan_exc = (E == ‘1’); with_zero = FALSE;
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
dp_operation = (sz == ‘1’); quiet_nan_exc = (E == ‘1’); with_zero = TRUE;
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
Encoding T1/A1 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VCMP{E}<c>.F64 <Dd>, <Dm>
VCMP{E}<c>.F32 <Sd>, <Sm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VCMP{E}<c>.F64 <Dd>, #0.0
VCMP{E}<c>.F32 <Sd>, #0.0
1 1 0 1 1 1 0 1 D 1 1 0 1 0 0 Vd 1 0 1 sz E 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 1 0 0 Vd 1 0 1 sz E 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
1 1 0 1 1 1 0 1 D 1 1 0 1 0 1 Vd 1 0 1 sz E 1 (0) 0 (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 1 0 1 Vd 1 0 1 sz E 1 (0) 0 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-865
ID051414 Non-Confidential
Assembler syntax
where:
E If present, any NaN operand causes an Invalid Operation exception. Encoded as E = 1.
Otherwise, only a signaling NaN causes the exception. Encoded as E = 0.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Dd>, <Dm> The operand vectors, for a doubleword operation.
<Sd>, <Sm> The operand vectors, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if dp_operation then
op64 = if with_zero then FPZero(‘0’,64) else D[m];
(FPSCR.N, FPSCR.Z, FPSCR.C, FPSCR.V) = FPCompare(D[d], op64, quiet_nan_exc, TRUE);
else
op32 = if with_zero then FPZero(‘0’,32) else S[m];
(FPSCR.N, FPSCR.Z, FPSCR.C, FPSCR.V) = FPCompare(S[d], op32, quiet_nan_exc, TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Input Denormal.
NaNs
The IEEE 754 standard specifies that the result of a comparison is precisely one of <, ==, > or unordered. If either
or both of the operands are NaNs, they are unordered, and all three of (Operand1 < Operand2),
(Operand1 == Operand2) and (Operand1 > Operand2) are false. This results in the FPSCR flags being set as N=0,
Z=0, C=1 and V=1.
VCMPE raises an Invalid Operation exception if either operand is any type of NaN, and is suitable for testing for <, <=,
>, >=, and other predicates that raise an exception when the operands are unordered.
VCMP{E}{<c>}{<q>}.F64 <Dd>, <Dm> Encoding T1/A1, encoded as sz = 1
VCMP{E}{<c>}{<q>}.F32 <Sd>, <Sm> Encoding T1/A1, encoded as sz = 0
VCMP{E}{<c>}{<q>}.F64 <Dd>, #0.0 Encoding T2/A2, encoded as sz = 1
VCMP{E}{<c>}{<q>}.F32 <Sd>, #0.0 Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-866 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.304 VCNT
This instruction counts the number of bits that are one in each element in a vector, and places the results in a second
vector.
The operand vector elements must be 8-bit fields.
The result vector elements are 8-bit integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size != ‘00’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8; elements = 8;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VCNT<c>.8 <Qd>, <Qm>
VCNT<c>.8 <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 1 0 1 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 1 0 1 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-867
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCNT instruction must be
unconditional. ARM strongly recommends that a Thumb VCNT instruction is unconditional,
see Conditional execution on page A8-288.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = BitCount(Elem[D[m+r],e,esize])<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VCNT{<c>}{<q>}.8 <Qd>, <Qm> Encoded as Q = 1
VCNT{<c>}{<q>}.8 <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-868 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.305 VCVT (between floating-point and integer, Advanced SIMD)
This instruction converts each element in a vector from floating-point to integer, or from integer to floating-point,
and places the results in a second vector.
The vector elements must be 32-bit floating-point numbers, or 32-bit integers. Signed and unsigned integers are
distinct.
The floating-point to integer operation uses the Round towards Zero rounding mode. The integer to floating-point
operation uses the Round to Nearest rounding mode.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size != ‘10’ then UNDEFINED;
to_integer = (op<1> == ‘1’); unsigned = (op<0> == ‘1’); esize = 32; elements = 2;
if to_integer then
round_zero = TRUE; // Variable name indicates purpose of FPToFixed() argument
else
round_nearest = TRUE; // Variable name indicates purpose of FixedToFP() argument
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VCVT<c>.<Td>.<Tm> <Qd>, <Qm>
VCVT<c>.<Td>.<Tm> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 1 1 Vd 0 1 1 op Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 1 1 Vd 0 1 1 op Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-869
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VCVT instruction
must be unconditional. ARM strongly recommends that a Thumb Advanced SIMD VCVT instruction
is unconditional, see Conditional execution on page A8-288.
.<Td>.<Tm> The data types for the elements of the vectors. They must be one of:
.S32.F32 encoded as op = 0b10, size = 0b10.
.U32.F32 encoded as op = 0b11, size = 0b10.
.F32.S32 encoded as op = 0b00, size = 0b10.
.F32.U32 encoded as op = 0b01, size = 0b10.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op = Elem[D[m+r],e,esize];
if to_integer then
result = FPToFixed(op, esize, 0, unsigned, round_zero, FALSE);
else
result = FixedToFP(op, esize, 0, unsigned, round_nearest, FALSE);
Elem[D[d+r],e,esize] = result;
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Inexact.
VCVT{<c>}{<q>}.<Td>.<Tm> <Qd>, <Qm> Encoded as Q = 1
VCVT{<c>}{<q>}.<Td>.<Tm> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-870 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.306 VCVT, VCVTR (between floating-point and integer, Floating-point)
These instructions convert a value in a register from floating-point to a 32-bit integer, or from a 32-bit integer to
floating-point, and place the result in a second register.
The floating-point to integer operation normally uses the Round towards Zero rounding mode, but can optionally
use the rounding mode specified by the FPSCR. The integer to floating-point operation uses the rounding mode
specified by the FPSCR.
VCVT (between floating-point and fixed-point, Floating-point) on page A8-874 describes conversions between
floating-point and 16-bit integers.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if opc2 != ‘000’ && !(opc2 IN “10x”) then SEE “Related encodings”;
to_integer = (opc2<2> == ‘1’); dp_operation = (sz == 1);
if to_integer then
unsigned = (opc2<0> == ‘0’); round_zero = (op == ‘1’);
d = UInt(Vd:D); m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
else
unsigned = (op == ‘0’); round_nearest = FALSE; // FALSE selects FPSCR rounding
m = UInt(Vm:M); d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
Encoding T1/A1 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VCVT{R}<c>.S32.F64 <Sd>, <Dm>
VCVT{R}<c>.S32.F32 <Sd>, <Sm>
VCVT{R}<c>.U32.F64 <Sd>, <Dm>
VCVT{R}<c>.U32.F32 <Sd>, <Sm>
VCVT<c>.F64.<Tm> <Dd>, <Sm>
VCVT<c>.F32.<Tm> <Sd>, <Sm>
Related encodings See Floating-point data-processing instructions on page A7-272.
1 1 0 1 1 1 0 1 D 1 1 1 opc2 Vd 1 0 1 sz op 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 1 0 1 D 1 1 1 opc2 Vd 1 0 1 sz op 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-871
ID051414 Non-Confidential
Assembler syntax
where:
R If R is specified, the operation uses the rounding mode specified by the FPSCR. Encoded as op = 0.
If R is omitted. the operation uses the Round towards Zero rounding mode. For syntaxes in which R
is optional, op is encoded as 1 if R is omitted.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Tm> The data type for the operand. It must be one of:
S32 encoded as op = 1
U32 encoded as op = 0.
<Sd>, <Dm> The destination register and the operand register, for a double-precision operand.
<Dd>, <Sm> The destination register and the operand register, for a double-precision result.
<Sd>, <Sm> The destination register and the operand register, for a single-precision operand or result.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if to_integer then
if dp_operation then
S[d] = FPToFixed(D[m], 32, 0, unsigned, round_zero, TRUE);
else
S[d] = FPToFixed(S[m], 32, 0, unsigned, round_zero, TRUE);
else
if dp_operation then
D[d] = FixedToFP(S[m], 64, 0, unsigned, round_nearest, TRUE);
else
S[d] = FixedToFP(S[m], 32, 0, unsigned, round_nearest, TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Inexact.
VCVT{R}{<c>}{<q>}.S32.F64 <Sd>, <Dm> Encoded as opc2 = 0b101, sz = 1
VCVT{R}{<c>}{<q>}.S32.F32 <Sd>, <Sm> Encoded as opc2 = 0b101, sz = 0
VCVT{R}{<c>}{<q>}.U32.F64 <Sd>, <Dm> Encoded as opc2 = 0b100, sz = 1
VCVT{R}{<c>}{<q>}.U32.F32 <Sd>, <Sm> Encoded as opc2 = 0b100, sz = 0
VCVT{<c>}{<q>}.F64.<Tm> <Dd>, <Sm> Encoded as opc2 = 0b000, sz = 1
VCVT{<c>}{<q>}.F32.<Tm> <Sd>, <Sm> Encoded as opc2 = 0b000, sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-872 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.307 VCVT (between floating-point and fixed-point, Advanced SIMD)
This instruction converts each element in a vector from floating-point to fixed-point, or from fixed-point to
floating-point, and places the results in a second vector.
The vector elements must be 32-bit floating-point numbers, or 32-bit integers. Signed and unsigned integers are
distinct.
The floating-point to fixed-point operation uses the Round towards Zero rounding mode. The fixed-point to
floating-point operation uses the Round to Nearest rounding mode.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm6 IN “000xxx” then SEE “Related encodings”;
if imm6 IN “0xxxxx” then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
to_fixed = (op == ‘1’); unsigned = (U == ‘1’);
if to_fixed then
round_zero = TRUE; // Variable name indicates purpose of FPToFixed() argument
else
round_nearest = TRUE; // Variable name indicates purpose of FixedToFP() argument
esize = 32; frac_bits = 64 - UInt(imm6); elements = 2;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VCVT<c>.<Td>.<Tm> <Qd>, <Qm>, #<fbits>
VCVT<c>.<Td>.<Tm> <Dd>, <Dm>, #<fbits>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 1 1 1 op 0 Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 1 1 1 op 0 Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-873
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VCVT instruction
must be unconditional. ARM strongly recommends that a Thumb Advanced SIMD VCVT instruction
is unconditional, see Conditional execution on page A8-288.
.<Td>.<Tm> The data types for the elements of the vectors. They must be one of:
.S32.F32 encoded as op = 1, U = 0
.U32.F32 encoded as op = 1, U = 1
.F32.S32 encoded as op = 0, U = 0
.F32.U32 encoded as op = 0, U = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
<fbits> The number of fraction bits in the fixed point number, in the range 1 to 32:
• (64 - <fbits>) is encoded in imm6.
An assembler can permit an <fbits> value of 0. This is encoded as floating-point to integer or integer
to floating-point instruction, see VCVT (between floating-point and integer, Advanced SIMD) on
page A8-868.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op = Elem[D[m+r],e,esize];
if to_fixed then
result = FPToFixed(op, esize, frac_bits, unsigned, round_zero, FALSE);
else
result = FixedToFP(op, esize, frac_bits, unsigned, round_nearest, FALSE);
Elem[D[d+r],e,esize] = result;
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Inexact.
VCVT{<c>}{<q>}.<Td>.<Tm> <Qd>, <Qm>, #<fbits> Encoded as Q = 1
VCVT{<c>}{<q>}.<Td>.<Tm> <Dd>, <Dm>, #<fbits> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-874 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.308 VCVT (between floating-point and fixed-point, Floating-point)
This instruction converts a value in a register from floating-point to fixed-point, or from fixed-point to
floating-point. Software can specify the fixed-point value as either signed or unsigned.
The floating-point value can be single-precision or double-precision.
The fixed-point value can be 16-bit or 32-bit. Conversions from fixed-point values take their operand from the
low-order bits of the source register and ignore any remaining bits. Signed conversions to fixed-point values
sign-extend the result value to the destination register width. Unsigned conversions to fixed-point values
zero-extend the result value to the destination register width.
The floating-point to fixed-point operation uses the Round towards Zero rounding mode. The fixed-point to
floating-point operation uses the Round to Nearest rounding mode.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
to_fixed = (op == ‘1’); dp_operation = (sf == ‘1’); unsigned = (U == ‘1’);
size = if sx == ‘0’ then 16 else 32;
frac_bits = size - UInt(imm4:i);
if to_fixed then
round_zero = TRUE;
else
round_nearest = TRUE;
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
if frac_bits < 0 then UNPREDICTABLE;
Encoding T1/A1 VFPv3, VFPv4 (sf = 1 UNDEFINED in single-precision only variants)
VCVT<c>.<Td>.F64 <Dd>, <Dd>, #<fbits>
VCVT<c>.<Td>.F32 <Sd>, <Sd>, #<fbits>
VCVT<c>.F64.<Td> <Dd>, <Dd>, #<fbits>
VCVT<c>.F32.<Td> <Sd>, <Sd>, #<fbits>
1 1 0 1 1 1 0 1 D 1 1 1 op 1 U Vd 1 0 1 sf sx 1 i 0 imm4
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 1 op 1 U Vd 1 0 1 sf sx 1 i 0 imm4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-875
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Td> The data type for the fixed-point number. It must be one of:
S16 encoded as U = 0, sx = 0
U16 encoded as U = 1, sx = 0
S32 encoded as U = 0, sx = 1
U32 encoded as U = 1, sx = 1.
<Dd> The destination and operand register, for a double-precision operand.
<Sd> The destination and operand register, for a single-precision operand.
<fbits> The number of fraction bits in the fixed-point number:
• If <Td> is S16 or U16, <fbits> must be in the range 0-16. (16 - <fbits>) is encoded in [imm4, i]
• I f <Td> is S32 or U32, <fbits> must be in the range 1-32. (32 - <fbits>) is encoded in [imm4, i].
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if to_fixed then
if dp_operation then
result = FPToFixed(D[d], size, frac_bits, unsigned, round_zero, TRUE);
D[d] = if unsigned then ZeroExtend(result, 64) else SignExtend(result, 64);
else
result = FPToFixed(S[d], size, frac_bits, unsigned, round_zero, TRUE);
S[d] = if unsigned then ZeroExtend(result, 32) else SignExtend(result, 32);
else
if dp_operation then
D[d] = FixedToFP(D[d]<size-1:0>, 64, frac_bits, unsigned, round_nearest, TRUE);
else
S[d] = FixedToFP(S[d]<size-1:0>, 32, frac_bits, unsigned, round_nearest, TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Inexact.
VCVT{<c>}{<q>}.<Td>.F64 <Dd>, <Dd>, #<fbits> Encoded as op = 1, sf = 1
VCVT{<c>}{<q>}.<Td>.F32 <Sd>, <Sd>, #<fbits> Encoded as op = 1, sf = 0
VCVT{<c>}{<q>}.F64.<Td> <Dd>, <Dd>, #<fbits> Encoded as op = 0, sf = 1
VCVT{<c>}{<q>}.F32.<Td> <Sd>, <Sd>, #<fbits> Encoded as op = 0, sf = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-876 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.309 VCVT (between double-precision and single-precision)
This instruction does one of the following:
• converts the value in a double-precision register to single-precision and writes the result to a single-precision
register
• converts the value in a single-precision register to double-precision and writes the result to a double-precision
register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
double_to_single = (sz == ‘1’);
d = if double_to_single then UInt(Vd:D) else UInt(D:Vd);
m = if double_to_single then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 VFPv2, VFPv3, VFPv4 (UNDEFINED in single-precision only variants)
VCVT<c>.F64.F32 <Dd>, <Sm>
VCVT<c>.F32.F64 <Sd>, <Dm>
1 1 0 1 1 1 0 1 D 1 1 0 1 1 1 Vd 1 0 1 sz 1 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 1 1 1 Vd 1 0 1 sz 1 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-877
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Dd>, <Sm> The destination register and the operand register, for a single-precision operand.
<Sd>, <Dm> The destination register and the operand register, for a double-precision operand.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if double_to_single then
S[d] = FPDoubleToSingle(D[m], TRUE);
else
D[d] = FPSingleToDouble(S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Input Denormal, Overflow, Underflow, Inexact.
VCVT{<c>}{<q>}.F64.F32 <Dd>, <Sm> Encoded as sz = 0
VCVT{<c>}{<q>}.F32.F64 <Sd>, <Dm> Encoded as sz = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-878 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.310 VCVT (between half-precision and single-precision, Advanced SIMD)
This instruction converts each element in a vector from single-precision to half-precision floating-point or from
half-precision to single-precision, and places the results in a second vector.
The vector elements must be 32-bit floating-point numbers, or 16-bit floating-point numbers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
half_to_single = (op == ‘1’);
if size != ‘01’ then UNDEFINED;
if half_to_single && Vd<0> == ‘1’ then UNDEFINED;
if !half_to_single && Vm<0> == ‘1’ then UNDEFINED;
esize = 16; elements = 4;
m = UInt(M:Vm); d = UInt(D:Vd);
Encoding T1/A1 Advanced SIMD with Half-precision Extension (UNDEFINED in integer-only variant)
VCVT<c>.F32.F16 <Qd>, <Dm>
VCVT<c>.F16.F32 <Dd>, <Qm>
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 1 1 op 0 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 1 0 Vd 0 1 1 op 0 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-879
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VCVT instruction must be
unconditional. ARM strongly recommends that a Thumb VCVT instruction is unconditional, see
Conditional execution on page A8-288.
<Qd>, <Dm> The destination vector and the operand vector for a half-precision to single-precision operation.
<Dd>, <Qm> The destination vector and the operand vectors for a single-precision to half-precision operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
if half_to_single then
Elem[Q[d>>1],e,2*esize] = FPHalfToSingle(Elem[Din[m],e,esize], FALSE);
else
Elem[D[d],e,esize] = FPSingleToHalf(Elem[Qin[m>>1],e,2*esize], FALSE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Input Denormal, Overflow, Underflow, Inexact.
VCVT{<c>}{<q>}.F32.F16 <Qd>, <Dm> Encoded as op = 1
VCVT{<c>}{<q>}.F16.F32 <Dd>, <Qm> Encoded as op = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-880 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.311 VCVTB, VCVTT
Vector Convert Bottom and Vector Convert Top do one of the following:
• convert the half-precision value in the top or bottom half of a single-precision register to single-precision and
write the result to a single-precision register
• convert the value in a single-precision register to half-precision and write the result into the top or bottom
half of a single-precision register, preserving the other half of the target register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
half_to_single = (op == ‘0’);
lowbit = if T == ‘1’ then 16 else 0;
m = UInt(Vm:M); d = UInt(Vd:D);
Encoding T1/A1 VFPv3 Half-precision Extension, VFPv4
VCVT<y><c>.F32.F16 <Sd>, <Sm>
VCVT<y><c>.F16.F32 <Sd>, <Sm>
1 1 0 1 1 1 0 1 D 1 1 0 0 1 op Vd 1 0 1 (0) T 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 0 1 op Vd 1 0 1 (0) T 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-881
ID051414 Non-Confidential
Assembler syntax
where:
<y> Specifies which half of the operand register <Sm> or destination register <Sd> is used for the operand
or destination. One of:
B Encoded as T = 0.
Instruction uses the bottom half of the register, bits[15:0].
T Encoded as T = 1.
Instruction uses the top half of the register, bits[31:16].
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Sd> The destination register.
<Sm> The operand register.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if half_to_single then
S[d] = FPHalfToSingle(S[m]<lowbit+15:lowbit>, TRUE);
else
S[d]<lowbit+15:lowbit> = FPSingleToHalf(S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Input Denormal, Overflow, Underflow, Inexact.
VCVT<y>{<c>}{<q>}.F32.F16 <Sd>, <Sm> Encoded as op = 0
VCVT<y>{<c>}{<q>}.F16.F32 <Sd>, <Sm> Encoded as op = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-882 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.312 VDIV
This instruction divides one floating-point value by another floating-point value and writes the result to a third
floating-point register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VDIV<c>.F64 <Dd>, <Dn>, <Dm>
VDIV<c>.F32 <Sd>, <Sn>, <Sm>
VFP vectors This instruction can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
1 1 0 1 1 1 0 1 D 0 0 Vn Vd 1 0 1 sz N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 0 0 Vn Vd 1 0 1 sz N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-883
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Dd>, <Dn>, <Dm> The destination register and the operand registers, for a double-precision operation.
<Sd>, <Sn>, <Sm> The destination register and the operand registers, for a single-precision operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if dp_operation then
D[d] = FPDiv(D[n], D[m], TRUE);
else
S[d] = FPDiv(S[n], S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Division by Zero, Overflow, Underflow, Inexact, Input Denormal.
VDIV{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm> Encoded as sz = 1
VDIV{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm> Encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-884 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.313 VDUP (scalar)
Vector Duplicate duplicates a scalar into every element of the destination vector.
The scalar, and the destination vector elements, can be any one of 8-bit, 16-bit, or 32-bit fields. There is no
distinction between data types.
For more information about scalars see Advanced SIMD scalars on page A7-260.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm4 IN “x000” then UNDEFINED;
if Q == ‘1’ && Vd<0> == ‘1’ then UNDEFINED;
case imm4 of
when “xxx1” esize = 8; elements = 8; index = UInt(imm4<3:1>);
when “xx10” esize = 16; elements = 4; index = UInt(imm4<3:2>);
when “x100” esize = 32; elements = 2; index = UInt(imm4<3>);
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VDUP<c>.<size> <Qd>, <Dm[x]>
VDUP<c>.<size> <Dd>, <Dm[x]>
1 1 1 1 1 1 1 1 D 1 1 imm4 Vd 1 1 0 0 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 imm4 Vd 1 1 0 0 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-885
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VDUP instruction must be
unconditional. ARM strongly recommends that a Thumb VDUP instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as imm4<0> = '1'. imm4<3:1> encodes the index [x] of the scalar.
16 Encoded as imm4<1:0> = '10'. imm4<3:2> encodes the index [x] of the scalar.
32 Encoded as imm4<2:0> = '100'. imm4<3> encodes the index [x] of the scalar.
<Qd> The destination vector for a quadword operation.
<Dd> The destination vector for a doubleword operation.
<Dm[x]> The scalar. For details of how [x] is encoded, see the description of <size>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
scalar = Elem[D[m],index,esize];
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = scalar;
Exceptions
Undefined Instruction, Hyp Trap.
VDUP{<c>}{<q>}.<size> <Qd>, <Dm[x]> Encoded as Q = 1
VDUP{<c>}{<q>}.<size> <Dd>, <Dm[x]> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-886 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.314 VDUP (ARM core register)
This instruction duplicates an element from an ARM core register into every element of the destination vector.
The destination vector elements can be 8-bit, 16-bit, or 32-bit fields. The source element is the least significant 8,
16, or 32 bits of the ARM core register. There is no distinction between data types.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if Q == ‘1’ && Vd<0> == ‘1’ then UNDEFINED;
d = UInt(D:Vd); t = UInt(Rt); regs = if Q == ‘0’ then 1 else 2;
case B:E of
when ‘00’ esize = 32; elements = 2;
when ‘01’ esize = 16; elements = 4;
when ‘10’ esize = 8; elements = 8;
when ‘11’ UNDEFINED;
if t == 15 || (CurrentInstrSet() != InstrSet_ARM && t == 13) then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VDUP<c>.<size> <Qd>, <Rt>
VDUP<c>.<size> <Dd>, <Rt>
1 1 0 1 1 1 0 1 B Q 0 Vd Rt 1 0 1 1 D 0 E 1 (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 B Q 0 Vd Rt 1 0 1 1 D 0 E 1 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-887
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. ARM strongly recommends that any VDUP
instruction is unconditional, see Conditional execution on page A8-288.
<size> The data size for the elements of the destination vector. It must be one of:
8 encoded as [b, e] = 0b10.
16 encoded as [b, e] = 0b01.
32 encoded as [b, e] = 0b00.
<Qd> The destination vector for a quadword operation.
<Dd> The destination vector for a doubleword operation.
<Rt> The ARM source register.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
scalar = R[t]<esize-1:0>;
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = scalar;
Exceptions
Undefined Instruction, Hyp Trap.
VDUP{<c>}{<q>}.<size> <Qd>, <Rt> Encoded as Q = 1
VDUP{<c>}{<q>}.<size> <Dd>, <Rt> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-888 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.315 VEOR
Vector Bitwise Exclusive OR performs a bitwise Exclusive OR operation between two registers, and places the
result in the destination register. The operand and result registers can be quadword or doubleword. They must all be
the same size.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VEOR<c> <Qd>, <Qn>, <Qm>
VEOR<c> <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D 0 0 Vn Vd 0 0 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D 0 0 Vn Vd 0 0 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-889
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VEOR instruction must be
unconditional. ARM strongly recommends that a Thumb VEOR instruction is unconditional,
see Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = D[n+r] EOR D[m+r];
Exceptions
Undefined Instruction, Hyp Trap.
VEOR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VEOR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-890 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.316 VEXT
Vector Extract extracts elements from the bottom end of the second operand vector and the top end of the first,
concatenates them and places the result in the destination vector. See Figure A8-1 for an example.
The elements of the vectors are treated as being 8-bit fields. There is no distinction between data types.
Figure A8-1 VEXT doubleword operation for imm = 3
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if Q == ‘0’ && imm4<3> == ‘1’ then UNDEFINED;
quadword_operation = (Q == ‘1’); position = 8 * UInt(imm4);
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
Vm Vn
Vd
Encoding T1/A1 Advanced SIMD
VEXT<c>.8 <Qd>, <Qn>, <Qm>, #<imm>
VEXT<c>.8 <Dd>, <Dn>, <Dm>, #<imm>
1 1 0 1 1 1 1 1 D 1 1 Vn Vd imm4 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D 1 1 Vn Vd imm4 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-891
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VEXT instruction must be
unconditional. ARM strongly recommends that a Thumb VEXT instruction is unconditional,
see Conditional execution on page A8-288.
<size> Size of the operation. The value can be:
• 8, 16, or 32 for doubleword operations
• 8, 16, 32, or 64 for quadword operations.
If the value is 16, 32, or 64, the syntax is a pseudo-instruction for a VEXT instruction
specifying the equivalent number of bytes. The following examples show how an assembler
treats values greater than 8:
VEXT.16 D0, D1, #x is treated as VEXT.8 D0, D1, #(x*2)
VEXT.32 D0, D1, #x is treated as VEXT.8 D0, D1, #(x*4)
VEXT.64 Q0, Q1, #x is treated as VEXT.8 Q0, Q1, #(x*8).
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<imm> The location of the extracted result in the concatenation of the operands, as a number of
bytes from the least significant end, in the range 0-7 for a doubleword operation or 0-15 for
a quadword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
if quadword_operation then
Q[d>>1] = (Q[m>>1]:Q[n>>1])<position+127:position>;
else
D[d] = (D[m]:D[n])<position+63:position>;
Exceptions
Undefined Instruction, Hyp Trap.
VEXT{<c>}{<q>}.<size> {<Qd>,} <Qn>, <Qm>, #<imm> Encoded as Q = 1
VEXT{<c>}{<q>}.<size> {<Dd>,} <Dn>, <Dm>, #<imm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-892 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.317 VFMA, VFMS
Vector Fused Multiply Accumulate multiplies corresponding elements of two vectors, and accumulates the results
into the elements of the destination vector. The instruction does not round the result of the multiply before the
accumulation.
Vector Fused Multiply Subtract negates the elements of one vector and multiplies them with the corresponding
elements of another vector, adds the products to the corresponding elements of the destination vector, and places the
results in the destination vector. The instruction does not round the result of the multiply before the addition.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
advsimd = TRUE; op1_neg = (op == ‘1’); esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then UNPREDICTABLE;
advsimd = FALSE; dp_operation = (sz == ‘1’); op1_neg = (op == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 Advanced SIMDv2 (UNDEFINED in integer-only variant)
VFM<y><c>.F32 <Qd>, <Qn>, <Qm>
VFM<y><c>.F32 <Dd>, <Dn>, <Dm>
Encoding T2/A2 VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VFM<y><c>.F64 <Dd>, <Dn>, <Dm>
VFM<y><c>.F32 <Sd>, <Sn>, <Sm>
1 1 0 1 1 1 1 0 D op sz Vn Vd 1 1 0 0 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D op sz Vn Vd 1 1 0 0 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 1 D 1 0 Vn Vd 1 0 1 sz N op M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 0 Vn Vd 1 0 1 sz N op M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-893
ID051414 Non-Confidential
Assembler syntax
where:
<y> One of:
A Specifies VFMA, encoded as op = 0.
S Specifies VFMS, encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VFMA or
VMFS instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VFMA or VMFS instruction is unconditional, see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Sd>, <Sn>, <Sm> The destination vector and the operand vectors, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[D[n+r],e,esize];
if op1_neg then op1 = FPNeg(op1);
Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],
op1, Elem[D[m+r],e,esize], FALSE);
else // VFP instruction
if dp_operation then
op64 = if op1_neg then FPNeg(D[n]) else D[n];
D[d] = FPMulAdd(D[d], op64, D[m], TRUE);
else
op32 = if op1_neg then FPNeg(S[n]) else S[n];
S[d] = FPMulAdd(S[d], op32, S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
The operation (QNaN + (0 × infinity)) causes an Invalid Operation floating-point exception.
VFM<y><c><q>.F32 <Qd>, <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1, sz = 0
VFM<y><c><q>.F32 <Dd>, <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0, sz = 0
VFM<y><c><q>.F64 <Dd>, <Dn>, <Dm> Encoding T2/A2, encoded as sz = 1
VFM<y><c><q>.F32 <Sd>, <Sn>, <Sm> Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-894 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.318 VFNMA, VFNMS
Vector Fused Negate Multiply Accumulate negates one floating-point register value and multiplies it by another
floating-point register value, adds the negation of the floating-point value in the destination register to the product,
and writes the result back to the destination register. The instruction does not round the result of the multiply before
the addition.
Vector Fused Negate Multiply Subtract multiplies together two floating-point register values, adds the negation of
the floating-point value in the destination register to the product, and writes the result back to the destination
register. The instruction does not round the result of the multiply before the addition.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then UNPREDICTABLE;
op1_neg = (op == ‘1’);
dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VFNM<y><c>.F64 <Dd>, <Dn>, <Dm>
VFNM<y><c>.F32 <Sd>, <Sn>, <Sm>
1 1 0 1 1 1 0 1 D 0 1 Vn Vd 1 0 1 sz N op M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 0 1 Vn Vd 1 0 1 sz N op M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-895
ID051414 Non-Confidential
Assembler syntax
where:
<y> One of:
A Specifies VFNMA, encoded as op = 1.
S Specifies VFNMS, encoded as op = 0.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Sd>, <Sn>, <Sm> The destination vector and the operand vectors, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if dp_operation then
op64 = if op1_neg then FPNeg(D[n]) else D[n];
D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], TRUE);
else
op32 = if op1_neg then FPNeg(S[n]) else S[n];
S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
The operation (QNaN + (0 × infinity)) causes an Invalid Operation floating-point exception.
VFNM<y><c><q>.F64 <Dd>, <Dn>, <Dm> Encoding T1/A1, encoded as sz = 1
VFNM<y><c><q>.F32 <Sd>, <Sn>, <Sm> Encoding T1/A1, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-896 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.319 VHADD, VHSUB
Vector Halving Add adds corresponding elements in two vectors of integers, shifts each result right one bit, and
places the final results in the destination vector. The results of the halving operations are truncated (for rounded
results see VRHADD on page A8-1030).
Vector Halving Subtract subtracts the elements of the second operand from the corresponding elements of the first
operand, shifts each result right one bit, and places the final results in the destination vector. The results of the
halving operations are truncated (there is no rounding version).
The operand and result elements are all the same type, and can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 8-bit, 16-bit, or 32-bit unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘11’ then UNDEFINED;
add = (op == ‘0’); unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VH<op><c> <Qd>, <Qn>, <Qm>
VH<op><c> <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 0 0 op 0 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 0 op 0 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-897
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation, It must be one of:
ADD encoded as op = 0.
SUB encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VHADD or VHSUB instruction
must be unconditional. ARM strongly recommends that a Thumb VHADD or VHSUB instruction
is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 encoded as size = 0b00, U = 0.
S16 encoded as size = 0b01, U = 0.
S32 encoded as size = 0b10, U = 0.
U8 encoded as size = 0b00, U = 1.
U16 encoded as size = 0b01, U = 1.
U32 encoded as size = 0b10, U = 1.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Int(Elem[D[n+r],e,esize], unsigned);
op2 = Int(Elem[D[m+r],e,esize], unsigned);
result = if add then op1+op2 else op1-op2;
Elem[D[d+r],e,esize] = result<esize:1>;
Exceptions
Undefined Instruction, Hyp Trap.
VH<op>{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VH<op>{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-898 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.320 VLD1 (multiple single elements)
This instruction loads elements from memory into one, two, three, or four registers, without de-interleaving. Every
element of each register is loaded. For details of the addressing mode see Advanced SIMD addressing mode on
page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
case type of
when ‘0111’
regs = 1; if align<1> == ‘1’ then UNDEFINED;
when ‘1010’
regs = 2; if align == ‘11’ then UNDEFINED;
when ‘0110’
regs = 3; if align<1> == ‘1’ then UNDEFINED;
when ‘0010’
regs = 4;
otherwise
SEE “Related encodings”;
alignment = if align == ‘00’ then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD1 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD1 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
64 encoded as size = 0b11.
Encoding T1/A1 Advanced SIMD
VLD1<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD1<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
1 1 1 1 0 0 1 0 D 1 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 1 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-899
ID051414 Non-Confidential
<list> The list of registers to load. It must be one of:
{<Dd>} encoded as D:Vd = <Dd>, type = 0b0111.
{<Dd>, <Dd+1>} encoded as D:Vd = <Dd>, type = 0b1010.
{<Dd>, <Dd+1>, <Dd+2>} encoded as D:Vd = <Dd>, type = 0b0110.
{<Dd>, <Dd+1>, <Dd+2>, <Dd+3>}
encoded as D:Vd = <Dd>, type = 0b0010.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
64 8-byte alignment, encoded as align = 0b01.
128 16-byte alignment, available only if <list> contains two or four registers, encoded as
align = 0b10.
256 32-byte alignment, available only if <list> contains four registers, encoded as
align = 0b11.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
for r = 0 to regs-1
for e = 0 to elements-1
if ebytes != 8 then
data<esize-1:0> = MemU[address,ebytes];
else
if SCTLR.A == ‘1’ && address != Align(address, 8) then AlignmentFault(address, FALSE);
data<31:0> = if BigEndian() then MemU[address+4,4] else MemU[address,4];
data<63:32> = if BigEndian() then MemU[address,4] else MemU[address+4,4];
Elem[D[d+r],e, esize] = data<esize-1:0>;
address = address + ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 8*regs);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-900 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.321 VLD1 (single element to one lane)
This instruction loads one element from memory into one element of a register. Elements of the register that are not
loaded are unchanged. For details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE VLD1 (single element to all lanes);
case size of
when ‘00’
if index_align<0> != ‘0’ then UNDEFINED;
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); alignment = 1;
when ‘01’
if index_align<1> != ‘0’ then UNDEFINED;
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
alignment = if index_align<0> == ‘0’ then 1 else 2;
when ‘10’
if index_align<2> != ‘0’ then UNDEFINED;
if index_align<1:0> != ‘00’ && index_align<1:0> != ‘11’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
alignment = if index_align<1:0> == ‘00’ then 1 else 4;
d = UInt(D:Vd); n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD1<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD1<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
1 1 1 1 0 0 1 1 D 1 0 Rn Vd size 0 0 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd size 0 0 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-901
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD1 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD1 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The register containing the element to load. It must be {<Dd[x]>}. The register <Dd> is encoded in
D:Vd.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
16 2-byte alignment, available only if <size> is 16
32 4-byte alignment, available only if <size> is 32
omitted Standard alignment, see Unaligned data access on page A3-108.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Table A8-4 shows the encoding of index and alignment for the different <size> values.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
Elem[D[d], index, esize] = MemU[address, ebytes];
if wback then R[n] = R[n] + (if register_index then R[m] else ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
Table A8-4 Encoding of index and alignment
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
<align> omitted index_align[0] = 0 index_align[1:0] = '00' index_align[2:0] = '000'
<align> == 16 - index_align[1:0] = '01' -
<align> == 32 - - index_align[2:0] = '011'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-902 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.322 VLD1 (single element to all lanes)
This instruction loads one element from memory into every element of one or two vectors. For details of the
addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (size == ‘00’ && a == ‘1’) then UNDEFINED;
ebytes = 1 << UInt(size); elements = 8 DIV ebytes; regs = if T == ‘0’ then 1 else 2;
alignment = if a == ‘0’ then 1 else ebytes;
d = UInt(D:Vd); n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD1<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD1<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
1 1 1 1 1 0 0 1 1 D 1 0 Rn Vd 1 1 0 0 size T a Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd 1 1 0 0 size T a Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-903
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD1 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD1 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The list of registers to load. It must be one of:
{<Dd[]>} encoded as D:Vd = <Dd>, T = 0.
{<Dd[]>, <Dd+1[]>} encoded as D:Vd = <Dd>, T = 1.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
16 2-byte alignment, available only if <size> is 16, encoded as a = 1.
32 4-byte alignment, available only if <size> is 32, encoded as a = 1.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as a = 0.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
replicated_element = Replicate(MemU[address,ebytes], elements);
if wback then R[n] = R[n] + (if register_index then R[m] else ebytes);
for r = 0 to regs-1
D[d+r] = replicated_element;
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-904 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.323 VLD2 (multiple 2-element structures)
This instruction loads multiple 2-element structures from memory into two or four registers, with de-interleaving.
For more information, see Element and structure load/store instructions on page A4-181. Every element of each
register is loaded. For details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case type of
when ‘1000’
regs = 1; inc = 1; if align == ‘11’ then UNDEFINED;
when ‘1001’
regs = 1; inc = 2; if align == ‘11’ then UNDEFINED;
when ‘0011’
regs = 2; inc = 2;
otherwise
SEE “Related encodings”;
alignment = if align == ‘00’ then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); d2 = d + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d2+regs > 32 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD2<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD2<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
1 1 1 1 0 0 1 0 D 1 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 1 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-905
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD2 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD2 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The list of registers to load. It must be one of:
{<Dd>, <Dd+1>} Single-spaced registers, encoded as D:Vd = <Dd>, type = 0b1000.
{<Dd>, <Dd+2>} Double-spaced registers, encoded as D:Vd = <Dd>, type = 0b1001.
{<Dd>, <Dd+1>, <Dd+2>, <Dd+3>}
Single-spaced registers, encoded as D:Vd = <Dd>, type = 0b0011.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
64 8-byte alignment, encoded as align = 0b01.
128 16-byte alignment, encoded as align = 0b10.
256 32-byte alignment, available only if <list> contains four registers. Encoded as align
= 0b11.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r], e, esize] = MemU[address, ebytes];
Elem[D[d2+r], e, esize] = MemU[address+ebytes, ebytes];
address = address + 2*ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 16*regs);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-906 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.324 VLD2 (single 2-element structure to one lane)
This instruction loads one 2-element structure from memory into corresponding elements of two registers. Elements
of the registers that are not loaded are unchanged. For details of the addressing mode see Advanced SIMD
addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE VLD2 (single 2-element structure to all lanes);
case size of
when ‘00’
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); inc = 1;
alignment = if index_align<0> == ‘0’ then 1 else 2;
when ‘01’
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
inc = if index_align<1> == ‘0’ then 1 else 2;
alignment = if index_align<0> == ‘0’ then 1 else 4;
when ‘10’
if index_align<1> != ‘0’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
inc = if index_align<2> == ‘0’ then 1 else 2;
alignment = if index_align<0> == ‘0’ then 1 else 8;
d = UInt(D:Vd); d2 = d + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD2 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD2 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
Encoding T1/A1 Advanced SIMD
VLD2<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD2<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
1 1 1 1 0 0 1 1 D 1 0 Rn Vd size 0 1 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd size 0 1 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-907
ID051414 Non-Confidential
<list> The registers containing the structure. Encoded with D:Vd = <Dd>. It must be one of:
{<Dd[x]>, <Dd+1[x]>} Single-spaced registers, see Table A8-5.
{<Dd[x]>, <Dd+2[x]>} Double-spaced registers, see Table A8-5.
This is not available if <size> == 8.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
16 2-byte alignment, available only if <size> is 8
32 4-byte alignment, available only if <size> is 16
64 8-byte alignment, available only if <size> is 32
omitted Standard alignment, see Unaligned data access on page A3-108.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm> see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
Elem[D[d], index, esize] = MemU[address, ebytes];
Elem[D[d2], index, esize] = MemU[address+ebytes, ebytes];
if wback then R[n] = R[n] + (if register_index then R[m] else 2*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
Table A8-5 Encoding of index, alignment, and register spacing
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
Single-spacing - index_align[1] = 0 index_align[2] = 0
Double-spacing - index_align[1] = 1 index_align[2] = 1
<align> omitted index_align[0] = 0 index_align[0] = 0 index_align[1:0] = '00'
<align> == 16 index_align[0] = 1 - -
<align> == 32 - index_align[0] = 1 -
<align> == 64 - - index_align[1:0] = '01'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-908 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.325 VLD2 (single 2-element structure to all lanes)
This instruction loads one 2-element structure from memory into all lanes of two registers. For details of the
addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
ebytes = 1 << UInt(size); elements = 8 DIV ebytes;
alignment = if a == ‘0’ then 1 else 2*ebytes;
inc = if T == ‘0’ then 1 else 2;
d = UInt(D:Vd); d2 = d + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD2<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD2<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
1 1 1 1 0 0 1 1 D 1 0 Rn Vd 1 1 0 1 size T a Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd 1 1 0 1 size T a Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-909
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD2 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD2 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The registers containing the structure. It must be one of:
{<Dd[]>, <Dd+1[]>} Single-spaced registers, encoded as D:Vd = <Dd>, T = 0.
{<Dd[]>, <Dd+2[]>} Double-spaced registers, encoded as D:Vd = <Dd>, T = 1.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
16 2-byte alignment, available only if <size> is 8, encoded as a = 1.
32 4-byte alignment, available only if <size> is 16, encoded as a = 1.
64 8-byte alignment, available only if <size> is 32, encoded as a = 1.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as a = 0.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
D[d] = Replicate(MemU[address, ebytes], elements);
D[d2] = Replicate(MemU[address+ebytes, ebytes], elements);
if wback then R[n] = R[n] + (if register_index then R[m] else 2*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-910 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.326 VLD3 (multiple 3-element structures)
This instruction loads multiple 3-element structures from memory into three registers, with de-interleaving. For
more information, see Element and structure load/store instructions on page A4-181. Every element of each register
is loaded. For details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || align<1> == ‘1’ then UNDEFINED;
case type of
when ‘0100’
inc = 1;
when ‘0101’
inc = 2;
otherwise
SEE “Related encodings”;
alignment = if align<0> == ‘0’ then 1 else 8;
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD3<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD3<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
1 1 1 1 0 0 1 0 D 1 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 1 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-911
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD3 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD3 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The list of registers to load. It must be one of:
{<Dd>, <Dd+1>, <Dd+2>}
Single-spaced registers, encoded as D:Vd = <Dd>, type = 0b0100.
{<Dd>, <Dd+2>, <Dd+4>}
Double-spaced registers, encoded as D:Vd = <Dd>, type = 0b0101.
<Rn> Contains the base address for the access.
<align> The alignment. It can be:
64 8-byte alignment, encoded as align = 0b01.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
for e = 0 to elements-1
Elem[D[d], e, esize] = MemU[address, ebytes];
Elem[D[d2], e, esize] = MemU[address+ebytes, ebytes];
Elem[D[d3], e, esize] = MemU[address+2*ebytes, ebytes];
address = address + 3*ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 24);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-912 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.327 VLD3 (single 3-element structure to one lane)
This instruction loads one 3-element structure from memory into corresponding elements of three registers.
Elements of the registers that are not loaded are unchanged. For details of the addressing mode see Advanced SIMD
addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE VLD3 (single 3-element structure to all lanes);
case size of
when ‘00’
if index_align<0> != ‘0’ then UNDEFINED;
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); inc = 1;
when ‘01’
if index_align<0> != ‘0’ then UNDEFINED;
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
inc = if index_align<1> == ‘0’ then 1 else 2;
when ‘10’
if index_align<1:0> != ‘00’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
inc = if index_align<2> == ‘0’ then 1 else 2;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD3<c>.<size> <list>, [<Rn>]{!}
VLD3<c>.<size> <list>, [<Rn>], <Rm>
1 1 1 1 0 0 1 1 D 1 0 Rn Vd size 1 0 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd size 1 0 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-913
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD3 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD3 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The registers containing the structure. Encoded with D:Vd = <Dd>. It must be one of:
{<Dd[x]>, <Dd+1[x]>, <Dd+2[x]>}
Single-spaced registers, see Table A8-6.
{<Dd[x]>, <Dd+2[x]>, <Dd+4[x]>}
Double-spaced registers, see Table A8-6.
This is not available if <size> == 8.
<Rn> Contains the base address for the access.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Alignment
Standard alignment rules apply, see Unaligned data access on page A3-108.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n];
Elem[D[d], index, esize] = MemU[address, ebytes];
Elem[D[d2], index, esize] = MemU[address+ebytes, ebytes];
Elem[D[d3], index, esize] = MemU[address+2*ebytes, ebytes];
if wback then R[n] = R[n] + (if register_index then R[m] else 3*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD3{<c>}{<q>}.<size> <list>, [<Rn>] Encoded as Rm = 0b1111
VLD3{<c>}{<q>}.<size> <list>, [<Rn>]! Encoded as Rm = 0b1101
VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm> Rm cannot be 0b11x1
Table A8-6 Encoding of index and register spacing
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
Single-spacing index_align[0] = 0 index_align[1:0] = '00' index_align[2:0] = '000'
Double-spacing - index_align[1:0] = '10' index_align[2:0] = '100'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-914 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.328 VLD3 (single 3-element structure to all lanes)
This instruction loads one 3-element structure from memory into all lanes of three registers. For details of the
addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || a == ‘1’ then UNDEFINED;
ebytes = 1 << UInt(size); elements = 8 DIV ebytes;
inc = if T == ‘0’ then 1 else 2;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD3<c>.<size> <list>, [<Rn>]{!}
VLD3<c>.<size> <list>, [<Rn>], <Rm>
1 1 1 1 0 0 1 1 D 1 0 Rn Vd 1 1 1 0 size T a Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd 1 1 1 0 size T a Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-915
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD3 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD3 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The registers containing the structures. It must be one of:
{<Dd[]>, <Dd+1[]>, <Dd+2[]>}
Single-spaced registers, encoded as D:Vd = <Dd>, T = 0.
{<Dd[]>, <Dd+2[]>, <Dd+4[]>}
Double-spaced registers, encoded as D:Vd = <Dd>, T = 1.
<Rn> Contains the base address for the access.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Alignment
Standard alignment rules apply, see Unaligned data access on page A3-108.
The a bit must be encoded as 0.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n];
D[d] = Replicate(MemU[address, ebytes], elelments);
D[d2] = Replicate(MemU[address+ebytes, ebytes], elements);
D[d3] = Replicate(MemU[address+2*ebytes, ebytes], elements);
if wback then R[n] = R[n] + (if register_index then R[m] else 3*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD3{<c>}{<q>}.<size> <list>, [<Rn>] Encoded as Rm = 0b1111
VLD3{<c>}{<q>}.<size> <list>, [<Rn>]! Encoded as Rm = 0b1101
VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-916 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.329 VLD4 (multiple 4-element structures)
This instruction loads multiple 4-element structures from memory into four registers, with de-interleaving. For more
information, see Element and structure load/store instructions on page A4-181. Every element of each register is
loaded. For details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case type of
when ‘0000’
inc = 1;
when ‘0001’
inc = 2;
otherwise
SEE “Related encodings”;
alignment = if align == ‘00’ then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; d4 = d3 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD4<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD4<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
1 1 1 1 0 0 1 0 D 1 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 1 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-917
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD4 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD4 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
<list> The list of registers to load. It must be one of:
{<Dd>, <Dd+1>, <Dd+2>, <Dd+3>}
Single-spaced registers, encoded as D:Vd = <Dd>, type = 0b0000.
{<Dd>, <Dd+2>, <Dd+4>, <Dd+6>}
Double-spaced registers, encoded as D:Vd = <Dd>, type = 0b0001.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
64 8-byte alignment, encoded as align = 0b01.
128 16-byte alignment, encoded as align = 0b10.
256 32-byte alignment, encoded as align = 0b11.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
for e = 0 to elements-1
Elem[D[d], e, esize] = MemU[address, ebytes];
Elem[D[d2], e, esize] = MemU[address+ebytes, ebytes];
Elem[D[d3], e, esize] = MemU[address+2*ebytes, ebytes];
Elem[D[d4], e, esize] = MemU[address+3*ebytes, ebytes];
address = address + 4*ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 32);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-918 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.330 VLD4 (single 4-element structure to one lane)
This instruction loads one 4-element structure from memory into corresponding elements of four registers. Elements
of the registers that are not loaded are unchanged. For details of the addressing mode see Advanced SIMD
addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE VLD4 (single 4-element structure to all lanes);
case size of
when ‘00’
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); inc = 1;
alignment = if index_align<0> == ‘0’ then 1 else 4;
when ‘01’
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
inc = if index_align<1> == ‘0’ then 1 else 2;
alignment = if index_align<0> == ‘0’ then 1 else 8;
when ‘10’
if index_align<1:0> == ‘11’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
inc = if index_align<2> == ‘0’ then 1 else 2;
alignment = if index_align<1:0> == ‘00’ then 1 else 4 << UInt(index_align<1:0>);
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; d4 = d3 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD4 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD4 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10.
Encoding T1/A1 Advanced SIMD
VLD4<c>.<size> <list>, [<Rn>{:<align>}]{!}
VLD4<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
1 1 1 1 0 0 1 1 D 1 0 Rn Vd size 1 1 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd size 1 1 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-919
ID051414 Non-Confidential
<list> The registers containing the structure. Encoded with D:Vd = <Dd>. It must be one of:
{<Dd[x]>, <Dd+1[x]>, <Dd+2[x]>, <Dd+3[x]>}
Single-spaced registers, see Table A8-7.
{<Dd[x]>, <Dd+2[x]>, <Dd+4[x]>, <Dd+6[x]>}
Double-spaced registers, see Table A8-7.
Not available if <size> == 8.
<Rn> The base address for the access.
<align> The alignment. It can be:
32 4-byte alignment, available only if <size> is 8.
64 8-byte alignment, available only if <size> is 16 or 32.
128 16-byte alignment, available only if <size> is 32.
omitted Standard alignment, see Unaligned data access on page A3-108.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm> see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
Elem[D[d], index, esize] = MemU[address, ebytes];
Elem[D[d2], index, esize] = MemU[address+ebytes, ebytes];
Elem[D[d3], index, esize] = MemU[address+2*ebytes, ebytes];
Elem[D[d4], index, esize] = MemU[address+3*ebytes, ebytes];
if wback then R[n] = R[n] + (if register_index then R[m] else 4*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
Table A8-7 Encoding of index, alignment, and register spacing
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
Single-spacing - index_align[1] = 0 index_align[2] = 0
Double-spacing - index_align[1] = 1 index_align[2] = 1
<align> omitted index_align[0] = 0 index_align[0] = 0 index_align[1:0] = '00'
<align> == 32 index_align[0] = 1 - -
<align> == 64 - index_align[0] = 1 index_align[1:0] = '01'
<align> == 128 - - index_align[1:0] = '10'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-920 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.331 VLD4 (single 4-element structure to all lanes)
This instruction loads one 4-element structure from memory into all lanes of four registers. For details of the
addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ && a == ‘0’ then UNDEFINED;
if size == ‘11’ then
ebytes = 4; elements = 2; alignment = 16;
else
ebytes = 1 << UInt(size); elements = 8 DIV ebytes;
if size == ‘10’ then
alignment = if a == ‘0’ then 1 else 8;
else
alignment = if a == ‘0’ then 1 else 4*ebytes;
inc = if T == ‘0’ then 1 else 2;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; d4 = d3 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VLD4<c>.<size> <list>, [<Rn>{ :<align>}]{!}
VLD4<c>.<size> <list>, [<Rn>{ :<align>}], <Rm>
1 1 1 1 0 0 1 1 D 1 0 Rn Vd 1 1 1 1 size T a Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 1 0 Rn Vd 1 1 1 1 size T a Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-921
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VLD4 instruction must be
unconditional. ARM strongly recommends that a Thumb VLD4 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 encoded as size = 0b00.
16 encoded as size = 0b01.
32 encoded as size = 0b10, or 0b11 for 16-byte alignment.
<list> The registers containing the structures. It must be one of:
{<Dd[]>, <Dd+1[]>, <Dd+2[]>, <Dd+3[]>}
Single-spaced registers, encoded as D:Vd = <Dd>, T = 0
{<Dd[]>, <Dd+2[]>, <Dd+4[]>, <Dd+6[]>}
Double-spaced registers, encoded as D:Vd = <Dd>, T = 1.
<Rn> The base address for the access.
<align> The alignment. It can be one of:
32 4-byte alignment, available only if <size> is 8, encoded as a = 1.
64 8-byte alignment, available only if <size> is 16 or 32, encoded as a = 1.
128 16-byte alignment, available only if <size> is 32, encoded as a = 1, size = 0b11.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as a = 0.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, FALSE);
D[d] = Replicate(MemU[address, ebytes], elements);
D[d2] = Replicate(MemU[address+ebytes, ebytes], elements);
D[d3] = Replicate(MemU[address+2*ebytes, ebytes], elements);
D[d4] = Replicate(MemU[address+3*ebytes, ebytes], elements);
if wback then R[n] = R[n] + (if register_index then R[m] else 4*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{ :<align>}] Encoded as Rm = 0b1111
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{ :<align>}]! Encoded as Rm = 0b1101
VLD4{<c>}{<q>}.<size> <list>, [<Rn>{ :<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-922 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.332 VLDM
Vector Load Multiple loads multiple extension registers from consecutive memory locations using an address from
an ARM core register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && U == ‘0’ && W == ‘0’ then SEE “Related encodings”;
if P == ‘0’ && U == ‘1’ && W == ‘1’ && Rn == ‘1101’ then SEE VPOP;
if P == ‘1’ && W == ‘0’ then SEE VLDR;
if P == U && W == ‘1’ then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = FALSE; add = (U == ‘1’); wback = (W == ‘1’);
d = UInt(D:Vd); n = UInt(Rn); imm32 = ZeroExtend(imm8:’00’, 32);
regs = UInt(imm8) DIV 2; // If UInt(imm8) is odd, see “FLDMX”.
if n == 15 && (wback || CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
if VFPSmallRegisterBank() && (d+regs) > 16 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && U == ‘0’ && W == ‘0’ then SEE “Related encodings”;
if P == ‘0’ && U == ‘1’ && W == ‘1’ && Rn == ‘1101’ then SEE VPOP;
if P == ‘1’ && W == ‘0’ then SEE VLDR;
if P == U && W == ‘1’ then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = TRUE; add = (U == ‘1’); wback = (W == ‘1’); d = UInt(Vd:D); n = UInt(Rn);
imm32 = ZeroExtend(imm8:’00’, 32); regs = UInt(imm8);
if n == 15 && (wback || CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VLDM{mode}<c> <Rn>{!}, <list> <list> is consecutive 64-bit registers
Encoding T2/A2 VFPv2, VFPv3, VFPv4
VLDM{mode}<c> <Rn>{!}, <list> <list> is consecutive 32-bit registers
Related encodings See 64-bit transfers between ARM core and extension registers on page A7-279.
FLDMX Encoding T1/A1 behaves as described by the pseudocode if imm8 is odd. However,
there is no UAL syntax for such encodings and ARM deprecates their use. For more
information, see FLDMX, FSTMX on page A8-388.
1 1 0 1 1 0 P U D W 1 Rn Vd 1 0 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 P U D W 1 Rn Vd 1 0 1 1 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
1 1 0 1 1 0 P U D W 1 Rn Vd 1 0 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 P U D W 1 Rn Vd 1 0 1 0 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-923
ID051414 Non-Confidential
Assembler syntax
VLDM{<mode>}{<c>}{<q>}{.<size>} <Rn>{!}, <list>
where:
<mode> The addressing mode:
IA Increment After. The consecutive addresses start at the address specified in <Rn>. This
is the default and can be omitted. Encoded as P = 0, U = 1.
DB Decrement Before. The consecutive addresses end just before the address specified in
<Rn>. Encoded as P = 1, U = 0.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<size> An optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers
in <list>.
<Rn> The base register. The SP can be used. In the ARM instruction set, if ! is not specified the PC can
be used, but ARM deprecates this use of the PC.
! Causes the instruction to write a modified value back to <Rn>. This is required if <mode> == DB, and
is optional if <mode> == IA. Encoded as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<list> The extension registers to be loaded, as a list of consecutively numbered doubleword (encoding
T1/A1) or singleword (encoding T2/A2) registers, separated by commas and surrounded by
brackets. It is encoded in the instruction by setting D and Vd to specify the first register in the list,
and imm8 to twice the number of registers in the list (encoding T1/A1) or the number of registers
in the list (encoding T2/A2). <list> must contain at least one register. If it contains doubleword
registers it must not contain more than 16 registers.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE); NullCheckIfThumbEE(n);
address = if add then R[n] else R[n]-imm32;
for r = 0 to regs-1
if single_regs then
S[d+r] = MemA[address,4]; address = address+4;
else
word1 = MemA[address,4]; word2 = MemA[address+4,4]; address = address+8;
// Combine the word-aligned words in the correct order for current endianness.
D[d+r] = if BigEndian() then word1:word2 else word2:word1;
if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-924 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.333 VLDR
This instruction loads a single extension register from memory, using an address from an ARM core register, with
an optional offset.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_reg = FALSE; add = (U == ‘1’); imm32 = ZeroExtend(imm8:’00’, 32);
d = UInt(D:Vd); n = UInt(Rn);
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_reg = TRUE; add = (U == ‘1’); imm32 = ZeroExtend(imm8:’00’, 32);
d = UInt(Vd:D); n = UInt(Rn);
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VLDR<c> <Dd>, [<Rn>{, #+/-<imm>}]
VLDR<c> <Dd>, <label>
VLDR<c> <Dd>, [PC, #-0] Special case
Encoding T2/A2 VFPv2, VFPv3, VFPv4
VLDR<c> <Sd>, [<Rn>{, #+/-<imm>}]
VLDR<c> <Sd>, <label>
VLDR<c> <Sd>, [PC, #-0] Special case
1 1 0 1 1 0 1 U D 0 1 Rn Vd 1 0 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 U D 0 1 Rn Vd 1 0 1 1 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
1 1 0 1 1 0 1 U D 0 1 Rn Vd 1 0 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 1 U D 0 1 Rn Vd 1 0 1 0 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-925
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
.32, .64 Optional data size specifiers.
<Dd> The destination register for a doubleword load.
<Sd> The destination register for a singleword load.
<Rn> The base register. The SP can be used.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. For the immediate forms of the syntax, <imm>
can be omitted, in which case the #0 form of the instruction is assembled. Permitted values are
multiples of 4 in the range 0 to 1020.
<label> The label of the literal data item to be loaded. The assembler calculates the required value of the
offset from the Align(PC, 4) value of the instruction to this label. Permitted values are multiples of
4 in the range -1020 to 1020.
If the offset is zero or positive, imm32 is equal to the offset and add == TRUE.
If the offset is negative, imm32 is equal to minus the offset and add == FALSE.
For the literal forms of the instruction, the base register is encoded as 0b1111 to indicate that the PC is the base
register.
The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified
separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more
information, see Use of labels in UAL instruction syntax on page A4-162.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE); NullCheckIfThumbEE(n);
base = if n == 15 then Align(PC,4) else R[n];
address = if add then (base + imm32) else (base - imm32);
if single_reg then
S[d] = MemA[address,4];
else
word1 = MemA[address,4]; word2 = MemA[address+4,4];
// Combine the word-aligned words in the correct order for current endianness.
D[d] = if BigEndian() then word1:word2 else word2:word1;
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VLDR{<c>}{<q>}{.64} <Dd>, [<Rn> {, #+/-<imm>}] Encoding T1/A1, immediate form
VLDR{<c>}{<q>}{.64} <Dd>, <label> Encoding T1/A1, normal literal form
VLDR{<c>}{<q>}{.64} <Dd>, [PC, #+/-<imm>] Encoding T1/A1, alternative literal form
VLDR{<c>}{<q>}{.32} <Sd>, [<Rn> {, #+/-<imm>}] Encoding T2/A2, immediate form
VLDR{<c>}{<q>}{.32} <Sd>, <label> Encoding T2/A2, normal literal form
VLDR{<c>}{<q>}{.32} <Sd>, [PC, #+/-<imm>] Encoding T2/A2, alternative literal form
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-926 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.334 VMAX, VMIN (integer)
Vector Maximum compares corresponding elements in two vectors, and copies the larger of each pair into the
corresponding element in the destination vector.
Vector Minimum compares corresponding elements in two vectors, and copies the smaller of each pair into the
corresponding element in the destination vector.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 8-bit, 16-bit, or 32-bit unsigned integers.
The result vector elements are the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘11’ then UNDEFINED;
maximum = (op == ‘0’); unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
V<op><c>.<dt> <Qd>, <Qn>, <Qm>
V<op><c>.<dt> <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 0 1 1 0 N Q M op Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 1 1 0 N Q M op Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-927
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MAX encoded as op = 0.
MIN encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VMAX or VMIN instruction
must be unconditional. ARM strongly recommends that a Thumb VMAX or VMIN instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data types for the elements of the vectors. It must be one of:
S8 encoded as size = 0b00, U = 0.
S16 encoded as size = 0b01, U = 0.
S32 encoded as size = 0b10, U = 0.
U8 encoded as size = 0b00, U = 1.
U16 encoded as size = 0b01, U = 1.
U32 encoded as size = 0b10, U = 1.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Int(Elem[D[n+r],e,esize], unsigned);
op2 = Int(Elem[D[m+r],e,esize], unsigned);
result = if maximum then Max(op1,op2) else Min(op1,op2);
Elem[D[d+r],e,esize] = result<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
V<op>{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
V<op>{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-928 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.335 VMAX, VMIN (floating-point)
Vector Maximum compares corresponding elements in two vectors, and copies the larger of each pair into the
corresponding element in the destination vector.
Vector Minimum compares corresponding elements in two vectors, and copies the smaller of each pair into the
corresponding element in the destination vector.
The operand vector elements are 32-bit floating-point numbers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
maximum = (op == ‘0’); esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
V<op><c>.F32 <Qd>, <Qn>, <Qm>
V<op><c>.F32 <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D op sz Vn Vd 1 1 1 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D op sz Vn Vd 1 1 1 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-929
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MAX Encoded as op = 0.
MIN Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VMAX or VMIN instruction
must be unconditional. ARM strongly recommends that a Thumb VMAX or VMIN instruction is
unconditional, see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[D[n+r],e,esize]; op2 = Elem[D[m+r],e,esize];
Elem[D[d+r],e,esize] = if maximum then FPMax(op1,op2,FALSE) else FPMin(op1,op2,FALSE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Input Denormal.
Floating-point maximum and minimum
• max(+0.0, –0.0) = +0.0
• min(+0.0, –0.0) = –0.0
• If any input is a NaN, the corresponding result element is the default NaN.
V<op>{<c>}{<q>}.F32 {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
V<op>{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-930 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.336 VMLA, VMLAL, VMLS, VMLSL (integer)
Vector Multiply Accumulate and Vector Multiply Subtract multiply corresponding elements in two vectors, and
either add the products to, or subtract them from, the corresponding elements of the destination vector. Vector
Multiply Accumulate Long and Vector Multiply Subtract Long do the same thing, but with destination vector
elements that are twice as long as the elements that are multiplied.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
add = (op == ‘0’); long_destination = FALSE;
unsigned = FALSE; // “Don’t care” value: TRUE produces same functionality
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if size == ‘11’ then SEE “Related encodings”;
if Vd<0> == ‘1’ then UNDEFINED;
add = (op == ‘0’); long_destination = TRUE; unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;
Encoding T1/A1 Advanced SIMD
V<op><c>.<dt> <Qd>, <Qn>, <Qm>
V<op><c>.<dt> <Dd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
V<op>L<c>.<dt> <Qd>, <Dn>, <Dm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 op 1 1 1 1 0 D size Vn Vd 1 0 0 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 op 0 D size Vn Vd 1 0 0 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 U 1 1 1 1 1 D size Vn Vd 1 0 op 0 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D size Vn Vd 1 0 op 0 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-931
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MLA Vector Multiply Accumulate. Encoded as op = 0.
MLS Vector Multiply Subtract. Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMLA,
VMLAL, VMLS, or VMLSL instruction must be unconditional. ARM strongly recommends that a
Thumb Advanced SIMD VMLA, VMLAL, VMLS, or VMLSL instruction is unconditional, see
Conditional execution on page A8-288.
<type> The data type for the elements of the operands. It must be one of:
S Optional in encoding T1/A1. Encoded as U = 0 in encoding T2/A2.
U Optional in encoding T1/A1. Encoded as U = 1 in encoding T2/A2.
I Available only in encoding T1/A1.
<size> The data size for the elements of the operands. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Qd>, <Dn>, <Dm> The destination vector and the operand vectors, for a long operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
addend = if add then product else -product;
if long_destination then
Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
else
Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;
Exceptions
Undefined Instruction, Hyp Trap.
V<op>{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1
V<op>{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0
V<op>L{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm> Encoding T2/A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-932 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.337 VMLA, VMLS (floating-point)
Vector Multiply Accumulate multiplies corresponding elements in two vectors, and accumulates the results into the
elements of the destination vector.
Vector Multiply Subtract multiplies corresponding elements in two vectors, subtracts the products from
corresponding elements of the destination vector, and places the results in the destination vector.
Note
ARM recommends that software does not use the VMLS instruction in the Round towards Plus Infinity and Round
towards Minus Infinity rounding modes, because the rounding of the product and of the sum can change the result
of the instruction in opposite directions, defeating the purpose of these rounding modes.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
advsimd = TRUE; add = (op == ‘0’); esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
advsimd = FALSE; dp_operation = (sz == ‘1’); add = (op == ‘0’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
V<op><c>.F32 <Qd>, <Qn>, <Qm>
V<op><c>.F32 <Dd>, <Dn>, <Dm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
V<op><c>.F64 <Dd>, <Dn>, <Dm>
V<op><c>.F32 <Sd>, <Sn>, <Sm>
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
1 1 0 1 1 1 1 0 D op sz Vn Vd 1 1 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D op sz Vn Vd 1 1 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 0 D 0 0 Vn Vd 1 0 1 sz N op M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 D 0 0 Vn Vd 1 0 1 sz N op M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-933
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MLA Vector Multiply Accumulate. Encoded as op = 0.
MLS Vector Multiply Subtract. Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMLA or
VMLS instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VMLA or VMLS instruction is unconditional, see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Sd>, <Sn>, <Sm> The destination vector and the operand vectors, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
for r = 0 to regs-1
for e = 0 to elements-1
product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], FALSE);
addend = if add then product else FPNeg(product);
Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, FALSE);
else // VFP instruction
if dp_operation then
addend64 = if add then FPMul(D[n], D[m], TRUE) else FPNeg(FPMul(D[n], D[m], TRUE));
D[d] = FPAdd(D[d], addend64, TRUE);
else
addend32 = if add then FPMul(S[n], S[m], TRUE) else FPNeg(FPMul(S[n], S[m], TRUE));
S[d] = FPAdd(S[d], addend32, TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
V<op>{<c>}{<q>}.F32 <Qd>, <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1, sz = 0
V<op>{<c>}{<q>}.F32 <Dd>, <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0, sz = 0
V<op>{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm> Encoding T2/A2, encoded as sz = 1
V<op>{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm> Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-934 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.338 VMLA, VMLAL, VMLS, VMLSL (by scalar)
Vector Multiply Accumulate and Vector Multiply Subtract multiply elements of a vector by a scalar, and either add
the products to, or subtract them from, corresponding elements of the destination vector. Vector Multiply
Accumulate Long and Vector Multiply Subtract Long do the same thing, but with destination vector elements that
are twice as long as the elements that are multiplied.
For more information about scalars see Advanced SIMD scalars on page A7-260.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || (F == ‘1’ && size == ‘01’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
unsigned = FALSE; // “Don’t care” value: TRUE produces same functionality
add = (op == ‘0’); floating_point = (F == ‘1’); long_destination = FALSE;
d = UInt(D:Vd); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || Vd<0> == ‘1’ then UNDEFINED;
unsigned = (U == ‘1’); add = (op == ‘0’); floating_point = FALSE; long_destination = TRUE;
d = UInt(D:Vd); n = UInt(N:Vn); regs = 1;
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
V<op><c>.<dt> <Qd>, <Qn>, <Dm[x]>
V<op><c>.<dt> <Dd>, <Dn>, <Dm[x]>
Encoding T2/A2 Advanced SIMD
V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 Q 1 1 1 1 1 D size Vn Vd 0 op 0 F N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 Q 1 D size Vn Vd 0 op 0 F N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 U 1 1 1 1 1 D size Vn Vd 0 op 1 0 N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D size Vn Vd 0 op 1 0 N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-935
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MLA Vector Multiply Accumulate. Encoded as op = 0.
MLS Vector Multiply Subtract. Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMLA, VMLAL, VMLS,
or VMLSL instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VMLA, VMLAL, VMLS, or VMLSL instruction is unconditional, see Conditional execution on
page A8-288.
<type> The data type for the elements of the operands. It must be one of:
S Encoding T2/A2, encoded as U = 0.
U Encoding T2/A2, encoded as U = 1.
I Encoding T1/A1, encoded as F = 0.
F Encoding T1/A1, encoded as F = 1. <size> must be 32.
<size> The operand element data size. It can be:
16 Encoded as size = 01.
32 Encoded as size = 10.
<Qd>, <Qn> The accumulate vector, and the operand vector, for a quadword operation.
<Dd>, <Dn> The accumulate vector, and the operand vector, for a doubleword operation.
<Qd>, <Dn> The accumulate vector, and the operand vector, for a long operation.
<Dm[x]> The scalar. Dm is restricted to D0-D7 if <size> is 16, or D0-D15 otherwise.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
op2 = Elem[Din[m],index,esize]; op2val = Int(op2, unsigned);
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[Din[n+r],e,esize]; op1val = Int(op1, unsigned);
if floating_point then
fp_addend = if add then FPMul(op1,op2,FALSE) else FPNeg(FPMul(op1,op2,FALSE));
Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, FALSE);
else
addend = if add then op1val*op2val else -op1val*op2val;
if long_destination then
Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
else
Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
V<op>{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Dm[x]> Encoding T1/A1, encoded as Q = 1
V<op>{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm[x]> Encoding T1/A1, encoded as Q = 0
V<op>L{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm[x]> Encoding T2/A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-936 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.339 VMOV (immediate)
This instruction places an immediate constant into every element of the destination register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if op == ‘0’ && cmode<0> == ‘1’ && cmode<3:2> != ‘11’ then SEE VORR (immediate);
if op == ‘1’ && cmode != ‘1110’ then SEE “Related encodings”;
if Q == ‘1’ && Vd<0> == ‘1’ then UNDEFINED;
single_register = FALSE; advsimd = TRUE; imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
d = UInt(D:Vd); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
single_register = (sz == ‘0’); advsimd = FALSE;
if single_register then
d = UInt(Vd:D); imm32 = VFPExpandImm(imm4H:imm4L, 32);
else
d = UInt(D:Vd); imm64 = VFPExpandImm(imm4H:imm4L, 64); regs = 1;
Encoding T1/A1 Advanced SIMD
VMOV<c>.<dt> <Qd>, #<imm>
VMOV<c>.<dt> <Dd>, #<imm>
Encoding T2/A2 VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VMOV<c>.F64 <Dd>, #<imm>
VMOV<c>.F32 <Sd>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride}
fields. For details see Appendix D11 VFP Vector Operation Support.
1 1 i 1 1 1 1 1 D 0 0 0 imm3 Vd cmode 0 Q op 1 imm4
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 i 1 D 0 0 0 imm3 Vd cmode 0 Q op 1 imm4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 1 D 1 1 imm4H Vd 1 0 1 sz (0) 0 (0) 0 imm4L
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 imm4H Vd 1 0 1 sz (0) 0 (0) 0 imm4L
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-937
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMOV (immediate)
instruction must be unconditional. ARM strongly recommends that a Thumb Advanced SIMD VMOV
(immediate) instruction is unconditional, see Conditional execution on page A8-288.
<dt> The data type. It must be one of I8, I16, I32, I64, or F32.
<Qd> The destination register for a quadword operation.
<Dd> The destination register for a doubleword operation.
<Sd> The destination register for a singleword operation.
<imm> A constant of the type specified by <dt>. This constant is replicated enough times to fill the
destination register. For example, VMOV.I32 D0, #10 writes 0x0000000A0000000A to D0.
For the range of constants available, and the encoding of <dt> and <imm>, see:
• One register and a modified immediate value on page A7-269 for encoding T1/A1
• Floating-point data-processing instructions on page A7-272 for encoding T2/A2.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if single_register then
S[d] = imm32;
else
for r = 0 to regs-1
D[d+r] = imm64;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
One register and a modified immediate value on page A7-269 describes pseudo-instructions with a combination of
<dt> and <imm> that is not supported by hardware, but that generates the same destination register value as a different
combination that is supported by hardware.
VMOV{<c>}{<q>}.<dt> <Qd>, #<imm> Encoding T1/A1, encoded as Q = 1
VMOV{<c>}{<q>}.<dt> <Dd>, #<imm> Encoding T1/A1, encoded as Q = 0
VMOV{<c>}{<q>}.F64 <Dd>, #<imm> Encoding T2/A2, encoded as sz = 1
VMOV{<c>}{<q>}.F32 <Sd>, #<imm> Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-938 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.340 VMOV (register)
This instruction copies the contents of one register to another.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if !Consistent(M) || !Consistent(Vm) then SEE VORR (register);
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
single_register = FALSE; advsimd = TRUE;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
single_register = (sz == ‘0’); advsimd = FALSE;
if single_register then
d = UInt(Vd:D); m = UInt(Vm:M);
else
d = UInt(D:Vd); m = UInt(M:Vm); regs = 1;
Encoding T1/A1 Advanced SIMD
VMOV<c> <Qd>, <Qm>
VMOV<c> <Dd>, <Dm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VMOV<c>.F64 <Dd>, <Dm>
VMOV<c>.F32 <Sd>, <Sm>
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
1 1 0 1 1 1 1 0 D 1 0 Vm Vd 0 0 0 1 M Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 1 0 Vm Vd 0 0 0 1 M Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 1 D 1 1 0 0 0 0 Vd 1 0 1 sz 0 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 0 0 0 Vd 1 0 1 sz 0 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-939
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMOV
(register) instruction must be unconditional. ARM strongly recommends that a Thumb
Advanced SIMD VMOV (register) instruction is unconditional, see Conditional execution on
page A8-288.
<dt> An optional data type. <dt> must not be F64, but it is otherwise ignored.
<Qd>, <Qm> The destination register and the source register, for a quadword operation.
<Dd>, <Dm> The destination register and the source register, for a doubleword operation.
<Sd>, <Sm> The destination register and the source register, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if single_register then
S[d] = S[m];
else
for r = 0 to regs-1
D[d+r] = D[m+r];
Exceptions
Undefined Instruction, Hyp Trap.
VMOV{<c>}{<q>}{.<dt>} <Qd>, <Qm> Encoding T1/A1, encoded as Q = 1
VMOV{<c>}{<q>}{.<dt>} <Dd>, <Dm> Encoding T1/A1, encoded as Q = 0
VMOV{<c>}{<q>}.F64 <Dd>, <Dm> Encoding T2/A2, encoded as sz = 1
VMOV{<c>}{<q>}.F32 <Sd>, <Sm> Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-940 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.341 VMOV (ARM core register to scalar)
This instruction copies a byte, halfword, or word from an ARM core register into an Advanced SIMD scalar.
On a Floating-point-only system, this instruction transfers one word to the upper or lower half of a double-precision
floating-point register from an ARM core register. This is an identical operation to the Advanced SIMD single word
transfer.
For more information about scalars see Advanced SIMD scalars on page A7-260.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
case opc1:opc2 of
when “1xxx” advsimd = TRUE; esize = 8; index = UInt(opc1<0>:opc2);
when “0xx1” advsimd = TRUE; esize = 16; index = UInt(opc1<0>:opc2<1>);
when “0x00” advsimd = FALSE; esize = 32; index = UInt(opc1<0>);
when “0x10” UNDEFINED;
d = UInt(D:Vd); t = UInt(Rt);
if t == 15 || (CurrentInstrSet() != InstrSet_ARM && t == 13) then UNPREDICTABLE;
Encoding T1/A1 Word version (opc1:opc2 == '0x00'): VFPv2, VFPv3, VFPv4, Advanced SIMD
Advanced SIMD otherwise
VMOV<c>.<size> <Dd[x]>, <Rt>
1 1 0 1 1 1 0 0 opc1 0 Vd Rt 1 0 1 1 D opc2 1 (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 opc1 0 Vd Rt 1 0 1 1 D opc2 1 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-941
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<size> The data size. It must be one of:
8 Encoded as opc1<1> = 1. [x] is encoded in opc1<0>, opc2.
16 Encoded as opc1<1> = 0, opc2<0> = 1. [x] is encoded in opc1<0>, opc2<1>.
32 Encoded as opc1<1> = 0, opc2 = 0b00. [x] is encoded in opc1<0>.
omitted Equivalent to 32.
<Dd[x]> The scalar. The register <Dd> is encoded in D:Vd. For details of how [x] is encoded, see the
description of <size>.
<Rt> The source ARM core register.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
Elem[D[d],index,esize] = R[t]<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VMOV{<c>}{<q>}{.<size>} <Dd[x]>, <Rt>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-942 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.342 VMOV (scalar to ARM core register)
This instruction copies a byte, halfword, or word from an Advanced SIMD scalar to an ARM core register. Bytes
and halfwords can be either zero-extended or sign-extended.
On a Floating-point-only system, this instruction transfers one word from the upper or lower half of a
double-precision floating-point register to an ARM core register. This is an identical operation to the Advanced
SIMD single word transfer.
For more information about scalars see Advanced SIMD scalars on page A7-260.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
case U:opc1:opc2 of
when “x1xxx” advsimd = TRUE; esize = 8; index = UInt(opc1<0>:opc2);
when “x0xx1” advsimd = TRUE; esize = 16; index = UInt(opc1<0>:opc2<1>);
when “00x00” advsimd = FALSE; esize = 32; index = UInt(opc1<0>);
when “10x00” UNDEFINED;
when “x0x10” UNDEFINED;
t = UInt(Rt); n = UInt(N:Vn); unsigned = (U == ‘1’);
if t == 15 || (CurrentInstrSet() != InstrSet_ARM && t == 13) then UNPREDICTABLE;
Encoding T1/A1 Word version (U:opc1:opc2 == '00x00'): VFPv2, VFPv3, VFPv4, Advanced SIMD
Advanced SIMD otherwise
VMOV<c>.<dt> <Rt>, <Dn[x]>
1 1 0 1 1 1 0 U opc1 1 Vn Rt 1 0 1 1 N opc2 1 (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 U opc1 1 Vn Rt 1 0 1 1 N opc2 1 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-943
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<dt> The data type. It must be one of:
S8 Encoded as U = 0, opc1<1> = 1. [x] is encoded in opc1<0>, opc2.
S16 Encoded as U = 0, opc1<1> = 0, opc2<0> = 1. [x] is encoded in opc1<0>, opc2<1>.
U8 Encoded as U = 1, opc1<1> = 1. [x] is encoded in opc1<0>, opc2.
U16 Encoded as U = 1, opc1<1> = 0, opc2<0> = 1. [x] is encoded in opc1<0>, opc2<1>.
32 Encoded as U = 0, opc1<1> = 0, opc2 = 0b00. [x] is encoded in opc1<0>.
omitted Equivalent to 32.
<Dn[x]> The scalar. For details of how [x] is encoded see the description of <dt>.
<Rt> The destination ARM core register.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if unsigned then
R[t] = ZeroExtend(Elem[D[n],index,esize], 32);
else
R[t] = SignExtend(Elem[D[n],index,esize], 32);
Exceptions
Undefined Instruction, Hyp Trap.
VMOV{<c>}{<q>}{.<dt>} <Rt>, <Dn[x]>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-944 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.343 VMOV (between ARM core register and single-precision register)
This instruction transfers the contents of a single-precision Floating-point register to an ARM core register, or the
contents of an ARM core register to a single-precision Floating-point register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
to_arm_register = (op == ‘1’); t = UInt(Rt); n = UInt(Vn:N);
if t == 15 || (CurrentInstrSet() != InstrSet_ARM && t == 13) then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4
VMOV<c> <Sn>, <Rt>
VMOV<c> <Rt>, <Sn>
1 1 0 1 1 1 0 0 0 0 op Vn Rt 1 0 1 0 N (0) (0) 1 (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 0 0 op Vn Rt 1 0 1 0 N (0) (0) 1 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-945
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Sn> The single-precision VFP register.
<Rt> The ARM core register.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if to_arm_register then
R[t] = S[n];
else
S[n] = R[t];
Exceptions
Undefined Instruction, Hyp Trap.
VMOV{<c>}{<q>} <Sn>, <Rt> Encoded as op = 0
VMOV{<c>}{<q>} <Rt>, <Sn> Encoded as op = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-946 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.344 VMOV (between two ARM core registers and two single-precision registers)
This instruction transfers the contents of two consecutively numbered single-precision Floating-point registers to
two ARM core registers, or the contents of two ARM core registers to a pair of single-precision Floating-point
registers. The ARM core registers do not have to be contiguous.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
to_arm_registers = (op == ‘1’); t = UInt(Rt); t2 = UInt(Rt2); m = UInt(Vm:M);
if t == 15 || t2 == 15 || m == 31 then UNPREDICTABLE;
if CurrentInstrSet() != InstrSet_ARM && (t == 13 || t2 == 13) then UNPREDICTABLE;
if to_arm_registers && t == t2 then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4
VMOV<c> <Sm>, <Sm1>, <Rt>, <Rt2>
VMOV<c> <Rt>, <Rt2>, <Sm>, <Sm1>
1 1 0 1 1 0 0 0 1 0 op Rt2 Rt 1 0 1 0 0 0 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 0 0 1 0 op Rt2 Rt 1 0 1 0 0 0 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-947
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Sm> The first single-precision Floating-point register.
<Sm1> The second single-precision Floating-point register. This is the next single-precision Floating-point
register after <Sm>.
<Rt> The ARM core register that <Sm> is transferred to or from.
<Rt2> The ARM core register that <Sm1> is transferred to or from.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if to_arm_registers then
R[t] = S[m];
R[t2] = S[m+1];
else
S[m] = R[t];
S[m+1] = R[t2];
Exceptions
Undefined Instruction, Hyp Trap.
VMOV{<c>}{<q>} <Sm>, <Sm1>, <Rt>, <Rt2> Encoded as op = 0
VMOV{<c>}{<q>} <Rt>, <Rt2>, <Sm>, <Sm1> Encoded as op = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-948 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.345 VMOV (between two ARM core registers and a doubleword extension register)
This instruction copies two words from two ARM core registers into a doubleword extension register, or from a
doubleword extension register to two ARM core registers.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
to_arm_registers = (op == ‘1’); t = UInt(Rt); t2 = UInt(Rt2); m = UInt(M:Vm);
if t == 15 || t2 == 15 then UNPREDICTABLE;
if CurrentInstrSet() != InstrSet_ARM && (t == 13 || t2 == 13) then UNPREDICTABLE;
if to_arm_registers && t == t2 then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VMOV<c> <Dm>, <Rt>, <Rt2>
VMOV<c> <Rt>, <Rt2>, <Dm>
1 1 0 1 1 0 0 0 1 0 op Rt2 Rt 1 0 1 1 0 0 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 0 0 1 0 op Rt2 Rt 1 0 1 1 0 0 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-949
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Dm> The doubleword extension register.
<Rt>, <Rt2> The two ARM core registers.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if to_arm_registers then
R[t] = D[m]<31:0>;
R[t2] = D[m]<63:32>;
else
D[m]<31:0> = R[t];
D[m]<63:32> = R[t2];
Exceptions
Undefined Instruction, Hyp Trap.
VMOV{<c>}{<q>} <Dm>, <Rt>, <Rt2> Encoded as op = 0
VMOV{<c>}{<q>} <Rt>, <Rt2>, <Dm> Encoded as op = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-950 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.346 VMOVL
Vector Move Long takes each element in a doubleword vector, sign or zero-extends them to twice their original
length, and places the results in a quadword vector.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm3 == ‘000’ then SEE “Related encodings”;
if imm3 != ‘001’ && imm3 != ‘010’ && imm3 != ‘100’ then SEE VSHLL;
if Vd<0> == ‘1’ then UNDEFINED;
esize = 8 * UInt(imm3);
unsigned = (U == ‘1’); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VMOVL<c>.<dt> <Qd>, <Dm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm3 0 0 0 Vd 1 0 1 0 0 0 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm3 0 0 0 Vd 1 0 1 0 0 0 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-951
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VMOVL instruction must be
unconditional. ARM strongly recommends that a Thumb VMOVL instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type for the elements of the operand. It must be one of:
S8 Encoded as U = 0, imm3 = 0b001.
S16 Encoded as U = 0, imm3 = 0b010.
S32 Encoded as U = 0, imm3 = 0b100.
U8 Encoded as U = 1, imm3 = 0b001.
U16 Encoded as U = 1, imm3 = 0b010.
U32 Encoded as U = 1, imm3 = 0b100.
<Qd>, <Dm> The destination vector and the operand vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
result = Int(Elem[Din[m],e,esize], unsigned);
Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VMOVL{<c>}{<q>}.dt> <Qd>, <Dm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-952 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.347 VMOVN
Vector Move and Narrow copies the least significant half of each element of a quadword vector into the
corresponding elements of a doubleword vector.
The operand vector elements can be any one of 16-bit, 32-bit, or 64-bit integers. There is no distinction between
signed and unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Vm<0> == ‘1’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VMOVN<c>.<dt> <Dd>, <Qm>
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 0 1 0 0 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 1 0 Vd 0 0 1 0 0 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-953
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VMOVN instruction must be
unconditional. ARM strongly recommends that a Thumb VMOVN instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type for the elements of the operand. It must be one of:
I16 Encoded as size = 0b00.
I32 Encoded as size = 0b01.
I64 Encoded as size = 0b10.
<Dd>, <Qm> The destination vector and the operand vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
Elem[D[d],e,esize] = Elem[Qin[m>>1],e,2*esize]<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-954 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.348 VMRS
Move to ARM core register from Advanced SIMD and Floating-point Extension System Register moves the value
of the FPSCR to an ARM core register.
For details of system level use of this instruction, see VMRS on page B9-2014.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt);
if t == 13 && CurrentInstrSet() != InstrSet_ARM then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VMRS<c> <Rt>, FPSCR
1 1 0 1 1 1 0 1 1 1 1 0 0 0 1 Rt 1 0 1 0 (0) (0) (0) 1 (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 1 1 1 0 0 0 1 Rt 1 0 1 0 (0) (0) (0) 1 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-955
ID051414 Non-Confidential
Assembler syntax
VMRS{<c>}{<q>} <Rt>, FPSCR
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The destination ARM core register. This register can be R0-R14 or APSR_nzcv. APSR_nzcv is
encoded as Rt = 0b1111, and the instruction transfers the FPSCR.{N, Z, C, V} condition flags to the
APSR.{N, Z, C, V} condition flags.
The pre-UAL instruction FMSTAT is equivalent to VMRS APSR_nzcv, FPSCR.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
SerializeVFP(); VFPExcBarrier();
if t != 15 then
R[t] = FPSCR;
else
APSR.N = FPSCR.N;
APSR.Z = FPSCR.Z;
APSR.C = FPSCR.C;
APSR.V = FPSCR.V;
Exceptions
Undefined Instruction, Hyp Trap.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-956 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.349 VMSR
Move to Advanced SIMD and Floating-point Extension System Register from ARM core register moves the value
of an ARM core register to the FPSCR.
For details of system level use of this instruction, see VMSR on page B9-2016.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
t = UInt(Rt);
if t == 15 || (t == 13 && CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VMSR<c> FPSCR, <Rt>
1 1 0 1 1 1 0 1 1 1 0 0 0 0 1 Rt 1 0 1 0 (0) (0) (0) 1 (0) (0) (0) (0)
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 1 1 0 0 0 0 1 Rt 1 0 1 0 (0) (0) (0) 1 (0) (0) (0) (0)
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-957
ID051414 Non-Confidential
Assembler syntax
VMSR{<c>}{<q>} FPSCR, <Rt>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Rt> The ARM core register to be transferred to the FPSCR.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
SerializeVFP(); VFPExcBarrier();
FPSCR = R[t];
Exceptions
Undefined Instruction, Hyp Trap.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-958 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.350 VMUL, VMULL (integer and polynomial)
Vector Multiply multiplies corresponding elements in two vectors. Vector Multiply Long does the same thing, but
with destination vector elements that are twice as long as the elements that are multiplied.
For information about multiplying polynomials see Polynomial arithmetic over {0, 1} on page A2-93.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (op == ‘1’ && size != ‘00’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
polynomial = (op == ‘1’); long_destination = FALSE;
unsigned = FALSE; // “Don’t care” value: TRUE produces same functionality
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if size == ‘11’ then SEE “Related encodings”;
if op == ‘1’ && (U != ‘0’ || size != ‘00’) then UNDEFINED;
if Vd<0> == ‘1’ then UNDEFINED;
polynomial = (op == ‘1’); long_destination = TRUE; unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;
Encoding T1/A1 Advanced SIMD
VMUL<c>.<dt> <Qd>, <Qn>, <Qm>
VMUL<c>.<dt> <Dd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
VMULL<c>.<dt> <Qd>, <Dn>, <Dm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 op 1 1 1 1 0 D size Vn Vd 1 0 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 op 0 D size Vn Vd 1 0 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 U 1 1 1 1 1 D size Vn Vd 1 1 op 0 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D size Vn Vd 1 1 op 0 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-959
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMUL or
VMULL instruction must be unconditional. ARM strongly recommends that a Thumb
Advanced SIMD VMUL or VMULL instruction is unconditional, see Conditional execution on
page A8-288.
<type> The data type for the elements of the operands. It must be one of:
S Encoded as op = 0 in both encodings, with U = 0 in encoding T2/A2.
U Encoded as op = 0 in both encodings, with U = 1 in encoding T2/A2.
I Encoding T1/A1 only, encoded as op = 0.
P Encoded as op = 1 in both encodings, with U= 0 in encoding T2/A2.
When <type> is P, <size> must be 8.
<size> The data size for the elements of the operands. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Qd>, <Dn>, <Dm> The destination vector and the operand vectors, for a long operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[Din[n+r],e,esize]; op1val = Int(op1, unsigned);
op2 = Elem[Din[m+r],e,esize]; op2val = Int(op2, unsigned);
if polynomial then
product = PolynomialMult(op1,op2);
else
product = (op1val*op2val)<2*esize-1:0>;
if long_destination then
Elem[Q[d>>1],e,2*esize] = product;
else
Elem[D[d+r],e,esize] = product<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VMUL{<c>}{<q>}.<type><size> {<Qd>,} <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1
VMUL{<c>}{<q>}.<type><size> {<Dd>,} <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0
VMULL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm> Encoding T2/A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-960 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.351 VMUL (floating-point)
Vector Multiply multiplies corresponding elements in two vectors, and places the results in the destination vector.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
advsimd = TRUE; esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
advsimd = FALSE; dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VMUL<c>.F32 <Qd>, <Qn>, <Qm>
VMUL<c>.F32 <Dd>, <Dn>, <Dm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VMUL<c>.F64 <Dd>, <Dn>, <Dm>
VMUL<c>.F32 <Sd>, <Sn>, <Sm>
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
1 1 1 1 1 1 1 0 D 0 sz Vn Vd 1 1 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D 0 sz Vn Vd 1 1 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 0 D 1 0 Vn Vd 1 0 1 sz N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 D 1 0 Vn Vd 1 0 1 sz N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-961
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMUL
instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VMUL instruction is unconditional, see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Sd>, <Sn>, <Sm> The destination vector and the operand vectors, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], FALSE);
else // VFP instruction
if dp_operation then
D[d] = FPMul(D[n], D[m], TRUE);
else
S[d] = FPMul(S[n], S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
VMUL{<c>}{<q>}.F32 {<Qd>,} <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1, sz = 0
VMUL{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0, sz = 0
VMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm> Encoding T2/A2, encoded as sz = 1
VMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm> Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-962 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.352 VMUL, VMULL (by scalar)
Vector Multiply multiplies each element in a vector by a scalar, and places the results in a second vector. Vector
Multiply Long does the same thing, but with destination vector elements that are twice as long as the elements that
are multiplied.
For more information about scalars see Advanced SIMD scalars on page A7-260.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || (F == ‘1’ && size == ‘01’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
unsigned = FALSE; // “Don’t care” value: TRUE produces same functionality
floating_point = (F == ‘1’); long_destination = FALSE;
d = UInt(D:Vd); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || Vd<0> == ‘1’ then UNDEFINED;
unsigned = (U == ‘1’); long_destination = TRUE; floating_point = FALSE;
d = UInt(D:Vd); n = UInt(N:Vn); regs = 1;
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VMUL<c>.<dt> <Qd>, <Qn>, <Dm[x]>
VMUL<c>.<dt> <Dd>, <Dn>, <Dm[x]>
Encoding T2/A2 Advanced SIMD
VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 Q 1 1 1 1 1 D size Vn Vd 1 0 0 F N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 Q 1 D size Vn Vd 1 0 0 F N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 U 1 1 1 1 1 D size Vn Vd 1 0 1 0 N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D size Vn Vd 1 0 1 0 N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-963
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VMUL or VMULL
instruction must be unconditional. ARM strongly recommends that a Thumb Advanced SIMD VMUL
or VMULL instruction is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the scalar, and the elements of the operand vector. It must be one of:
I16 Encoding T1/A1, encoded as size = 0b01, F = 0.
I32 Encoding T1/A1, encoded as size = 0b10, F = 0.
F32 Encoding T1/A1, encoded as size = 0b10, F = 1.
S16 Encoding T2/A2, encoded as size = 0b01, U = 0.
S32 Encoding T2/A2, encoded as size = 0b10, U = 0.
U16 Encoding T2/A2, encoded as size = 0b01, U = 1.
U32 Encoding T2/A2, encoded as size = 0b10, U = 1.
<Qd>, <Qn> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dn> The destination vector, and the operand vector, for a doubleword operation.
<Qd>, <Dn> The destination vector, and the operand vector, for a long operation.
<Dm[x]> The scalar. Dm is restricted to D0-D7 if <dt> is I16, S16, or U16, or D0-D15 otherwise.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
op2 = Elem[Din[m],index,esize]; op2val = Int(op2, unsigned);
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Elem[Din[n+r],e,esize]; op1val = Int(op1, unsigned);
if floating_point then
Elem[D[d+r],e,esize] = FPMul(op1, op2, FALSE);
else
if long_destination then
Elem[Q[d>>1],e,2*esize] = (op1val*op2val)<2*esize-1:0>;
else
Elem[D[d+r],e,esize] = (op1val*op2val)<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
VMUL{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]> Encoding T1/A1, encoded as Q = 1
VMUL{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]> Encoding T1/A1, encoded as Q = 0
VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]> Encoding T2/A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-964 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.353 VMVN (immediate)
Vector Bitwise NOT (immediate) places the bitwise inverse of an immediate integer constant into every element of
the destination register. For the range of constants available, see One register and a modified immediate value on
page A7-269.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (cmode<0> == ‘1’ && cmode<3:2> != ‘11’) || cmode<3:1> == ‘111’ then SEE “Related encodings”;
if Q == ‘1’ && Vd<0> == ‘1’ then UNDEFINED;
imm64 = AdvSIMDExpandImm(‘1’, cmode, i:imm3:imm4);
d = UInt(D:Vd); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VMVN<c>.<dt> <Qd>, #<imm>
VMVN<c>.<dt> <Dd>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 i 1 1 1 1 1 D 0 0 0 imm3 Vd cmode 0 Q 1 1 imm4
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 i 1 D 0 0 0 imm3 Vd cmode 0 Q 1 1 imm4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-965
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VMVN instruction must be
unconditional. ARM strongly recommends that a Thumb VMVN instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type. It must be either I16 or I32.
<Qd> The destination register for a quadword operation.
<Dd> The destination register for a doubleword operation.
<imm> A constant of the specified type.
See One register and a modified immediate value on page A7-269 for the range of constants available, and the
encoding of <dt> and <imm>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = NOT(imm64);
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
One register and a modified immediate value on page A7-269 describes pseudo-instructions with a combination of
<dt> and <imm> that is not supported by hardware, but that generates the same destination register value as a different
combination that is supported by hardware.
VMVN{<c>}{<q>}.dt> <Qd>, #<imm> Encoding T1/A1, encoded as Q = 1
VMVN{<c>}{<q>}.dt> <Dd>, #<imm> Encoding T1/A1, encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-966 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.354 VMVN (register)
Vector Bitwise NOT (register) takes a value from a register, inverts the value of each bit, and places the result in the
destination register. The registers can be either doubleword or quadword.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size != ‘00’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VMVN<c> <Qd>, <Qm>
VMVN<c> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 1 0 1 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 1 0 1 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-967
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VMVN instruction must be
unconditional. ARM strongly recommends that a Thumb VMVN instruction is unconditional, see
Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = NOT(D[m+r]);
Exceptions
Undefined Instruction, Hyp Trap.
VMVN{<c>}{<q>}{.<dt>} <Qd>, <Qm>
VMVN{<c>}{<q>}{.<dt>} <Dd>, <Dm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-968 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.355 VNEG
Vector Negate negates each element in a vector, and places the results in a second vector. The floating-point version
only inverts the sign bit.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (F == ‘1’ && size != ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
advsimd = TRUE; floating_point = (F == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
advsimd = FALSE; dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VNEG<c>.<dt> <Qd>, <Qm>
VNEG<c>.<dt> <Dd>, <Dm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VNEG<c>.F64 <Dd>, <Dm>
VNEG<c>.F32 <Sd>, <Sm>
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
1 1 1 1 1 1 1 1 D 1 1 size 0 1 Vd 0 F 1 1 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 1 Vd 0 F 1 1 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 0 1 D 1 1 0 0 0 1 Vd 1 0 1 sz 0 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 0 0 1 Vd 1 0 1 sz 0 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-969
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VNEG instruction
must be unconditional. ARM strongly recommends that a Thumb Advanced SIMD VNEG instruction
is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoded as size = 0b00, F = 0.
S16 Encoded as size = 0b01, F = 0.
S32 Encoded as size = 0b10, F = 0.
F32 Encoded as size = 0b10, F = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
<Sd>, <Sm> The destination vector and the operand vector, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
Elem[D[d+r],e,esize] = FPNeg(Elem[D[m+r],e,esize]);
else
result = -SInt(Elem[D[m+r],e,esize]);
Elem[D[d+r],e,esize] = result<esize-1:0>;
else // VFP instruction
if dp_operation then
D[d] = FPNeg(D[m]);
else
S[d] = FPNeg(S[m]);
Exceptions
Undefined Instruction, Hyp Trap.
VNEG{<c>}{<q>}.<dt> <Qd>, <Qm> Encoding T1/A1
VNEG{<c>}{<q>}.<dt> <Dd>, <Dm> Encoding T1/A1
VNEG{<c>}{<q>}.F32 <Sd>, <Sm> Floating-point only, encoding T2/A2, encoded as sz = 0
VNEG{<c>}{<q>}.F64 <Dd>, <Dm> Encoding T2/A2, encoded as sz = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-970 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.356 VNMLA, VNMLS, VNMUL
VNMLA multiplies together two floating-point register values, adds the negation of the floating-point value in the
destination register to the negation of the product, and writes the result back to the destination register.
VNMLS multiplies together two floating-point register values, adds the negation of the floating-point value in the
destination register to the product, and writes the result back to the destination register.
VNMUL multiplies together two floating-point register values, and writes the negation of the result to the destination
register.
Note
ARM recommends that software does not use the VNMLA instruction in the Round towards Plus Infinity and Round
towards Minus Infinity rounding modes, because the rounding of the product and of the sum can change the result
of the instruction in opposite directions, defeating the purpose of these rounding modes.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
type = if op == ‘1’ then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
type = VFPNegMul_VNMUL;
dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VNMLA<c>.F64 <Dd>, <Dn>, <Dm>
VNMLA<c>.F32 <Sd>, <Sn>, <Sm>
VNMLS<c>.F64 <Dd>, <Dn>, <Dm>
VNMLS<c>.F32 <Sd>, <Sn>, <Sm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VNMUL<c>.F64 <Dd>, <Dn>, <Dm>
VNMUL<c>.F32 <Sd>, <Sn>, <Sm>
1 1 0 1 1 1 0 0 D 0 1 Vn Vd 1 0 1 sz N op M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 D 0 1 Vn Vd 1 0 1 sz N op M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
1 1 0 1 1 1 0 0 D 1 0 Vn Vd 1 0 1 sz N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 D 1 0 Vn Vd 1 0 1 sz N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-971
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MLA Vector Negate Multiply Accumulate. Encoded as op = 0.
MLS Vector Negate Multiply Subtract. Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Dd>, <Dn>, <Dm> The destination register and the operand registers, for a double-precision operation.
<Sd>, <Sn>, <Sm> The destination register and the operand registers, for a single-precision operation.
Operation
enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if dp_operation then
product64 = FPMul(D[n], D[m], TRUE);
case type of
when VFPNegMul_VNMLA D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), TRUE);
when VFPNegMul_VNMLS D[d] = FPAdd(FPNeg(D[d]), product64, TRUE);
when VFPNegMul_VNMUL D[d] = FPNeg(product64);
else
product32 = FPMul(S[n], S[m], TRUE);
case type of
when VFPNegMul_VNMLA S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), TRUE);
when VFPNegMul_VNMLS S[d] = FPAdd(FPNeg(S[d]), product32, TRUE);
when VFPNegMul_VNMUL S[d] = FPNeg(product32);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Overflow, Underflow, Inexact, Input Denormal.
VFP vectors These instructions can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
VN<op>{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm> Encoding T1/A1, encoded as sz = 1
VN<op>{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm> Encoding T1/A1, encoded as sz = 0
VNMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm> Encoding T2/A2, encoded as sz = 1
VNMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm> Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-972 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.357 VORN (immediate)
VORN (immediate) is a pseudo-instruction, equivalent to a VORR (immediate) instruction with the immediate value
bitwise inverted. For details see VORR (immediate) on page A8-974.
A8.8.358 VORN (register)
This instruction performs a bitwise OR NOT operation between two registers, and places the result in the destination
register. The operand and result registers can be quadword or doubleword. They must all be the same size.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VORN<c> <Qd>, <Qn>, <Qm>
VORN<c> <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D 1 1 Vn Vd 0 0 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 1 1 Vn Vd 0 0 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-973
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VORN instruction must be
unconditional. ARM strongly recommends that a Thumb VORN instruction is unconditional,
see Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = D[n+r] OR NOT(D[m+r]);
Exceptions
Undefined Instruction, Hyp Trap.
VORN{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VORN{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-974 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.359 VORR (immediate)
This instruction takes the contents of the destination vector, performs a bitwise OR with an immediate constant, and
returns the result into the destination vector. For the range of constants available, see One register and a modified
immediate value on page A7-269.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if cmode<0> == ‘0’ || cmode<3:2> == ‘11’ then SEE VMOV (immediate);
if Q == ‘1’ && Vd<0> == ‘1’ then UNDEFINED;
imm64 = AdvSIMDExpandImm(‘0’, cmode, i:imm3:imm4);
d = UInt(D:Vd); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VORR<c>.<dt> <Qd>, #<imm>
VORR<c>.<dt> <Dd>, #<imm>
1 1 i 1 1 1 1 1 D 0 0 0 imm3 Vd cmode 0 Q 0 1 imm4
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 i 1 D 0 0 0 imm3 Vd cmode 0 Q 0 1 imm4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-975
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VORR instruction must be
unconditional. ARM strongly recommends that a Thumb VORR instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type used for <imm>. It can be either I16 or I32.
I8, I64, and F32 are also permitted, but the resulting syntax is a pseudo-instruction.
<Qd> The destination vector for a quadword operation.
<Dd> The destination vector for a doubleword operation.
<imm> A constant of the type specified by <dt>. This constant is replicated enough times to fill the
destination register. For example, VORR.I32 D0, #10 ORs 0x0000000A0000000A into D0.
For details of the range of constants available, and the encoding of <dt> and <imm>, see One register and a modified
immediate value on page A7-269.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = D[d+r] OR imm64;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
VORN can be used, with a range of constants that are the bitwise inverse of the available constants for VORR. This is
assembled as the equivalent VORR instruction. Disassembly produces the VORR form.
One register and a modified immediate value on page A7-269 describes pseudo-instructions with a combination of
<dt> and <imm> that is not supported by hardware, but that generates the same destination register value as a different
combination that is supported by hardware.
VORR{<c>}{<q>}.<dt> {<Qd>,} <Qd>, #<imm> Encoded as Q = 1
VORR{<c>}{<q>}.<dt> {<Dd>,} <Dd>, #<imm>> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-976 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.360 VORR (register)
This instruction performs a bitwise OR operation between two registers, and places the result in the destination
register. The operand and result registers can be quadword or doubleword. They must all be the same size.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if N == M && Vn == Vm then SEE VMOV (register);
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VORR<c> <Qd>, <Qn>, <Qm>
VORR<c> <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D 1 0 Vn Vd 0 0 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 1 0 Vn Vd 0 0 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-977
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VORR instruction must be
unconditional. ARM strongly recommends that a Thumb VORR instruction is unconditional,
see Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
D[d+r] = D[n+r] OR D[m+r];
Exceptions
Undefined Instruction, Hyp Trap.
VORR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VORR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-978 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.361 VPADAL
Vector Pairwise Add and Accumulate Long adds adjacent pairs of elements of a vector, and accumulates the results
into the elements of the destination vector.
The vectors can be doubleword or quadword. The operand elements can be 8-bit, 16-bit, or 32-bit integers. The
result elements are twice the length of the operand elements.
Figure A8-2 shows an example of the operation of VPADAL.
Figure A8-2 VPADAL doubleword operation for data type S16
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
unsigned = (op == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Dm
Dd
+ +
Encoding T1/A1 Advanced SIMD
VPADAL<c>.<dt> <Qd>, <Qm>
VPADAL<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 1 1 0 op Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 1 1 0 op Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-979
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VPADAL instruction must be
unconditional. ARM strongly recommends that a Thumb VPADAL instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoded as size = 0b00, op = 0.
S16 Encoded as size = 0b01, op = 0.
S32 Encoded as size = 0b10, op = 0.
U8 Encoded as size = 0b00, op = 1.
U16 Encoded as size = 0b01, op = 1.
U32 Encoded as size = 0b10, op = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
h = elements DIV 2;
for r = 0 to regs-1
for e = 0 to h-1
op1 = Elem[D[m+r],2*e,esize]; op2 = Elem[D[m+r],2*e+1,esize];
result = Int(op1, unsigned) + Int(op2, unsigned);
Elem[D[d+r],e,2*esize] = Elem[D[d+r],e,2*esize] + result;
Exceptions
Undefined Instruction, Hyp Trap.
VPADAL{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VPADAL{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-980 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.362 VPADD (integer)
Vector Pairwise Add (integer) adds adjacent pairs of elements of two vectors, and places the results in the destination
vector.
The operands and result are doubleword vectors.
The operand and result elements must all be the same type, and can be 8-bit, 16-bit, or 32-bit integers. There is no
distinction between signed and unsigned integers.
Figure A8-3 shows an example of the operation of VPADD.
Figure A8-3 VPADD operation for data type I16
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || Q == ‘1’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Dm
Dd
+ +
Dn
+ +
Encoding T1/A1 Advanced SIMD
VPADD<c>.<dt> <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D size Vn Vd 1 0 1 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D size Vn Vd 1 0 1 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-981
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VPADD instruction must be
unconditional. ARM strongly recommends that a Thumb VPADD instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
I8 Encoding T1/A1, encoded as size = 0b00.
I16 Encoding T1/A1, encoded as size = 0b01.
I32 Encoding T1/A1, encoded as size = 0b10.
<Dd>, <Dn>, <Dm> The destination vector, the first operand vector, and the second operand vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;
for e = 0 to h-1
Elem[dest,e,esize] = Elem[D[n],2*e,esize] + Elem[D[n],2*e+1,esize];
Elem[dest,e+h,esize] = Elem[D[m],2*e,esize] + Elem[D[m],2*e+1,esize];
D[d] = dest;
Exceptions
Undefined Instruction, Hyp Trap.
VPADD{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-982 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.363 VPADD (floating-point)
Vector Pairwise Add (floating-point) adds adjacent pairs of elements of two vectors, and places the results in the
destination vector.
The operands and result are doubleword vectors.
The operand and result elements are 32-bit floating-point numbers.
Figure A8-3 on page A8-980 shows an example of the operation of VPADD.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if sz == ‘1’ || Q == ‘1’ then UNDEFINED;
esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VPADD<c>.F32 <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D 0 sz Vn Vd 1 1 0 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D 0 sz Vn Vd 1 1 0 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-983
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VPADD instruction must be
unconditional. ARM strongly recommends that a Thumb VPADD instruction is unconditional,
see Conditional execution on page A8-288.
<Dd>, <Dn>, <Dm> The destination vector, the first operand vector, and the second operand vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;
for e = 0 to h-1
Elem[dest,e,esize] = FPAdd(Elem[D[n],2*e,esize], Elem[D[n],2*e+1,esize], FALSE);
Elem[dest,e+h,esize] = FPAdd(Elem[D[m],2*e,esize], Elem[D[m],2*e+1,esize], FALSE);
D[d] = dest;
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
VPADD{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoded as Q = 0, sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-984 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.364 VPADDL
Vector Pairwise Add Long adds adjacent pairs of elements of two vectors, and places the results in the destination
vector.
The vectors can be doubleword or quadword. The operand elements can be 8-bit, 16-bit, or 32-bit integers. The
result elements are twice the length of the operand elements.
Figure A8-4 shows an example of the operation of VPADDL.
Figure A8-4 VPADDL doubleword operation for data type S16
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
unsigned = (op == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Dm
Dd
+ +
Encoding T1/A1 Advanced SIMD
VPADDL<c>.<dt> <Qd>, <Qm>
VPADDL<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 0 1 0 op Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 0 1 0 op Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-985
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VPADDL instruction must be
unconditional. ARM strongly recommends that a Thumb VPADDL instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoded as size = 0b00, op = 0.
S16 Encoded as size = 0b01, op = 0.
S32 Encoded as size = 0b10, op = 0.
U8 Encoded as size = 0b00, op = 1.
U16 Encoded as size = 0b01, op = 1.
U32 Encoded as size = 0b10, op = 1.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
h = elements DIV 2;
for r = 0 to regs-1
for e = 0 to h-1
op1 = Elem[D[m+r],2*e,esize]; op2 = Elem[D[m+r],2*e+1,esize];
result = Int(op1, unsigned) + Int(op2, unsigned);
Elem[D[d+r],e,2*esize] = result<2*esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VPADDL{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VPADDL{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-986 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.365 VPMAX, VPMIN (integer)
Vector Pairwise Maximum compares adjacent pairs of elements in two doubleword vectors, and copies the larger
of each pair into the corresponding element in the destination doubleword vector.
Vector Pairwise Minimum compares adjacent pairs of elements in two doubleword vectors, and copies the smaller
of each pair into the corresponding element in the destination doubleword vector.
Figure A8-5 shows an example of the operation of VPMAX.
Figure A8-5 VPMAX operation for data type S16 or U16
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || Q == ‘1’ then UNDEFINED;
maximum = (op == ‘0’); unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Dm
Dd
max max
Dn
max max
Encoding T1/A1 Advanced SIMD
VP<op><c>.<dt> <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 1 0 1 0 N Q M op Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 1 0 1 0 N Q M op Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-987
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MAX Encoded as op = 0.
MIN Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VPMAX or VPMIN instruction
must be unconditional. ARM strongly recommends that a Thumb VPMAX or VPMIN instruction
is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoding T1/A1, encoded as size = 0b00, U = 0.
S16 Encoding T1/A1, encoded as size = 0b01, U = 0.
S32 Encoding T1/A1, encoded as size = 0b10, U = 0.
U8 Encoding T1/A1, encoded as size = 0b00, U = 1.
U16 Encoding T1/A1, encoded as size = 0b01, U = 1.
U32 Encoding T1/A1, encoded as size = 0b10, U = 1.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;
for e = 0 to h-1
op1 = Int(Elem[D[n],2*e,esize], unsigned);
op2 = Int(Elem[D[n],2*e+1,esize], unsigned);
result = if maximum then Max(op1,op2) else Min(op1,op2);
Elem[dest,e,esize] = result<esize-1:0>;
op1 = Int(Elem[D[m],2*e,esize], unsigned);
op2 = Int(Elem[D[m],2*e+1,esize], unsigned);
result = if maximum then Max(op1,op2) else Min(op1,op2);
Elem[dest,e+h,esize] = result<esize-1:0>;
D[d] = dest;
Exceptions
Undefined Instruction, Hyp Trap.
VP<op>{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-988 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.366 VPMAX, VPMIN (floating-point)
Vector Pairwise Maximum compares adjacent pairs of elements in two doubleword vectors, and copies the larger
of each pair into the corresponding element in the destination doubleword vector.
Vector Pairwise Minimum compares adjacent pairs of elements in two doubleword vectors, and copies the smaller
of each pair into the corresponding element in the destination doubleword vector.
Figure A8-5 on page A8-986 shows an example of the operation of VPMAX.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if sz == ‘1’ || Q == ‘1’ then UNDEFINED;
maximum = (op == ‘0’); esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VP<op><c>.F32 <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D op sz Vn Vd 1 1 1 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D op sz Vn Vd 1 1 1 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-989
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MAX Encoded as op = 0.
MIN Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VPMAX or VPMIN instruction
must be unconditional. ARM strongly recommends that a Thumb VPMAX or VPMIN instruction
is unconditional, see Conditional execution on page A8-288.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;
for e = 0 to h-1
op1 = Elem[D[n],2*e,esize]; op2 = Elem[D[n],2*e+1,esize];
Elem[dest,e,esize] = if maximum then FPMax(op1,op2,FALSE) else FPMin(op1,op2,FALSE);
op1 = Elem[D[m],2*e,esize]; op2 = Elem[D[m],2*e+1,esize];
Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,FALSE) else FPMin(op1,op2,FALSE);
D[d] = dest;
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Input Denormal.
VP<op>{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoded as Q = 0, sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-990 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.367 VPOP
Vector Pop loads multiple consecutive extension registers from the stack.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_regs = FALSE; d = UInt(D:Vd); imm32 = ZeroExtend(imm8:’00’, 32);
regs = UInt(imm8) DIV 2; // If UInt(imm8) is odd, see “FLDMX”.
if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
if VFPSmallRegisterBank() && (d+regs) > 16 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_regs = TRUE; d = UInt(Vd:D); imm32 = ZeroExtend(imm8:’00’, 32);
regs = UInt(imm8);
if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VPOP <list> <list> is consecutive 64-bit registers
Encoding T2/A2 VFPv2, VFPv3, VFPv4
VPOP <list> <list> is consecutive 32-bit registers
FLDMX Encoding T1/A1 behaves as described by the pseudocode if imm8 is odd. However,
there is no UAL syntax for such encodings and ARM deprecates their use. For more
information, see FLDMX, FSTMX on page A8-388.
1 1 0 1 1 0 0 1 D 1 1 1 1 0 1 Vd 1 0 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 0 1 D 1 1 1 1 0 1 Vd 1 0 1 1 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
1 1 0 1 1 0 0 1 D 1 1 1 1 0 1 Vd 1 0 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 0 1 D 1 1 1 1 0 1 Vd 1 0 1 0 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-991
ID051414 Non-Confidential
Assembler syntax
VPOP{<c>}{<q>}{.<size>} <list>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<size> An optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers
in <list>.
<list> The extension registers to be loaded, as a list of consecutively numbered doubleword (encoding
T1/A1) or singleword (encoding T2/A2) registers, separated by commas and surrounded by
brackets. It is encoded in the instruction by setting D and Vd to specify the first register in the list,
and imm8 to twice the number of registers in the list (encoding T1/A1) or the number of registers
in the list (encoding T2/A2). <list> must contain at least one register, and not more than sixteen.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE); NullCheckIfThumbEE(13);
address = SP;
SP = SP + imm32;
if single_regs then
for r = 0 to regs-1
S[d+r] = MemA[address,4]; address = address+4;
else
for r = 0 to regs-1
word1 = MemA[address,4]; word2 = MemA[address+4,4]; address = address+8;
// Combine the word-aligned words in the correct order for current endianness.
D[d+r] = if BigEndian() then word1:word2 else word2:word1;
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-992 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.368 VPUSH
Vector Push stores multiple consecutive extension registers to the stack.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_regs = FALSE; d = UInt(D:Vd); imm32 = ZeroExtend(imm8:’00’, 32);
regs = UInt(imm8) DIV 2; // If UInt(imm8) is odd, see “FSTMX”.
if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
if VFPSmallRegisterBank() && (d+regs) > 16 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_regs = TRUE; d = UInt(Vd:D);
imm32 = ZeroExtend(imm8:’00’, 32); regs = UInt(imm8);
if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VPUSH<c> <list> <list> is consecutive 64-bit registers
Encoding T2/A2 VFPv2, VFPv3, VFPv4
VPUSH<c> <list> <list> is consecutive 32-bit registers
FSTMX Encoding T1/A1 behaves as described by the pseudocode if imm8 is odd. However,
there is no UAL syntax for such encodings and ARM deprecates their use. For more
information, see FLDMX, FSTMX on page A8-388.
1 1 0 1 1 0 1 0 D 1 0 1 1 0 1 Vd 1 0 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 D 1 0 1 1 0 1 Vd 1 0 1 1 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
1 1 0 1 1 0 1 0 D 1 0 1 1 0 1 Vd 1 0 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 D 1 0 1 1 0 1 Vd 1 0 1 0 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-993
ID051414 Non-Confidential
Assembler syntax
VPUSH{<c>}{<q>}{.<size>} <list>
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<size> An optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers
in <list>.
<list> The extension registers to be stored, as a list of consecutively numbered doubleword (encoding
T1/A1) or singleword (encoding T2/A2) registers, separated by commas and surrounded by
brackets. It is encoded in the instruction by setting D and Vd to specify the first register in the list,
and imm8 to twice the number of registers in the list (encoding T1/A1), or the number of registers
in the list (encoding T2/A2). <list> must contain at least one register, and not more than sixteen.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE); NullCheckIfThumbEE(13);
address = SP - imm32;
SP = SP - imm32;
if single_regs then
for r = 0 to regs-1
MemA[address,4] = S[d+r]; address = address+4;
else
for r = 0 to regs-1
// Store as two word-aligned words in the correct order for current endianness.
MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;
MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;
address = address+8;
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-994 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.369 VQABS
Vector Saturating Absolute takes the absolute value of each element in a vector, and places the results in the
destination vector.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VQABS<c>.<dt> <Qd>, <Qm>
VQABS<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 1 1 1 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 1 1 1 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-995
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQABS instruction must be
unconditional. ARM strongly recommends that a Thumb VQABS instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoded as size = 0b00.
S16 Encoded as size = 0b01.
S32 Encoded as size = 0b10.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
result = Abs(SInt(Elem[D[m+r],e,esize]));
(Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQABS{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VQABS{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-996 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.370 VQADD
Vector Saturating Add adds the values of corresponding elements of two vectors, and places the results in the
destination vector.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VQADD<c>.<dt> <Qd>, <Qn>, <Qm>
VQADD<c>.<dt> <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 0 0 0 0 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 0 0 0 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-997
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQADD instruction must be
unconditional. ARM strongly recommends that a Thumb VQADD instruction is unconditional,
see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
64 Encoded as size = 0b11.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
sum = Int(Elem[D[n+r],e,esize], unsigned) + Int(Elem[D[m+r],e,esize], unsigned);
(Elem[D[d+r],e,esize], sat) = SatQ(sum, esize, unsigned);
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQADD{<c>}{<q>}.<type><size> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VQADD{<c>}{<q>}.<type><size> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-998 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.371 VQDMLAL, VQDMLSL
Vector Saturating Doubling Multiply Accumulate Long multiplies corresponding elements in two doubleword
vectors, doubles the products, and accumulates the results into the elements of a quadword vector.
Vector Saturating Doubling Multiply Subtract Long multiplies corresponding elements in two doubleword vectors,
subtracts double the products from corresponding elements of a quadword vector, and places the results in the same
quadword vector.
In both instructions, the second operand can be a scalar instead of a vector. For more information about scalars see
Advanced SIMD scalars on page A7-260.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || Vd<0> == ‘1’ then UNDEFINED;
add = (op == ‘0’);
scalar_form = FALSE; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
esize = 8 << UInt(size); elements = 64 DIV esize;
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || Vd<0> == ‘1’ then UNDEFINED;
add = (op == ‘0’);
scalar_form = TRUE; d = UInt(D:Vd); n = UInt(N:Vn);
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
Encoding T1/A1 Advanced SIMD
VQD<op><c>.<dt> <Qd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 0 1 1 1 1 1 D size Vn Vd 1 0 op 1 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D size Vn Vd 1 0 op 1 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 1 1 D size Vn Vd 0 op 1 1 N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D size Vn Vd 0 op 1 1 N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-999
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
MLAL Encoded as op = 0.
MLSL Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQDMLAL or VQDMLSL instruction must
be unconditional. ARM strongly recommends that a Thumb VQDMLAL or VQDMLSL instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
S16 Encoded as size = 0b01.
S32 Encoded as size = 0b10.
<Qd>, <Dn> The destination vector and the first operand vector.
<Dm> The second operand vector, for an all vector operation.
<Dm[x]> The scalar for a scalar operation. If <dt> is S16, Dm is restricted to D0-D7. If <dt> is S32, Dm is restricted
to D0-D15.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
for e = 0 to elements-1
if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
op1 = SInt(Elem[Din[n],e,esize]);
// The following only saturates if both op1 and op2 equal -(2^(esize-1))
(product, sat1) = SignedSatQ(2*op1*op2, 2*esize);
if add then
result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);
else
result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);
(Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);
if sat1 || sat2 then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQD<op>{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>
VQD<op>{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1000 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.372 VQDMULH
Vector Saturating Doubling Multiply Returning High Half multiplies corresponding elements in two vectors,
doubles the results, and places the most significant half of the final results in the destination vector. The results are
truncated (for rounded results see VQRDMULH on page A8-1008).
The second operand can be a scalar instead of a vector. For more information about scalars see Advanced SIMD
scalars on page A7-260.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘00’ || size == ‘11’ then UNDEFINED;
scalar_form = FALSE; esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
scalar_form = TRUE; d = UInt(D:Vd); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
Encoding T1/A1 Advanced SIMD
VQDMULH<c>.<dt> <Qd>, <Qn>, <Qm>
VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
VQDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]>
VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 0 1 1 1 1 0 D size Vn Vd 1 0 1 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D size Vn Vd 1 0 1 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 Q 1 1 1 1 1 D size Vn Vd 1 1 0 0 N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 Q 1 D size Vn Vd 1 1 0 0 N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1001
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQDMULH instruction must
be unconditional. ARM strongly recommends that a Thumb VQDMULH instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
S16 Encoded as size = 0b01.
S32 Encoded as size = 0b10.
<Qd>, <Qn> The destination vector and the first operand vector, for a quadword operation.
<Dd>, <Dn> The destination vector and the first operand vector, for a doubleword operation.
<Qm> The second operand vector, for a quadword all vector operation.
<Dm> The second operand vector, for a doubleword all vector operation.
<Dm[x]> The scalar for either a quadword or a doubleword scalar operation. If <dt> is S16, Dm is
restricted to D0-D7. If <dt> is S32, Dm is restricted to D0-D15.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
for r = 0 to regs-1
for e = 0 to elements-1
if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
op1 = SInt(Elem[D[n+r],e,esize]);
// The following only saturates if both op1 and op2 equal -(2^(esize-1))
(result, sat) = SignedSatQ((2*op1*op2) >> esize, esize);
Elem[D[d+r],e,esize] = result;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1
VQDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0
VQDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]> Encoding T2/A2, encoded as Q = 1
VQDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]> Encoding T2/A2, encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1002 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.373 VQDMULL
Vector Saturating Doubling Multiply Long multiplies corresponding elements in two doubleword vectors, doubles
the products, and places the results in a quadword vector.
The second operand can be a scalar instead of a vector. For more information about scalars see Advanced SIMD
scalars on page A7-260.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || Vd<0> == ‘1’ then UNDEFINED;
scalar_form = FALSE; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
esize = 8 << UInt(size); elements = 64 DIV esize;
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ || Vd<0> == ‘1’ then UNDEFINED;
scalar_form = TRUE; d = UInt(D:Vd); n = UInt(N:Vn);
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
Encoding T1/A1 Advanced SIMD
VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 0 1 1 1 1 1 D size Vn Vd 1 1 0 1 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D size Vn Vd 1 1 0 1 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 0 1 1 1 1 1 D size Vn Vd 1 0 1 1 N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D size Vn Vd 1 0 1 1 N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1003
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQDMULL instruction must be
unconditional. ARM strongly recommends that a Thumb VQDMULL instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
S16 Encoded as size = 0b01.
S32 Encoded as size = 0b10.
<Qd>, <Dn> The destination vector and the first operand vector.
<Dm> The second operand vector, for an all vector operation.
<Dm[x]> The scalar for a scalar operation. If <dt> is S16, Dm is restricted to D0-D7. If <dt> is S32, Dm is restricted
to D0-D15.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
for e = 0 to elements-1
if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
op1 = SInt(Elem[Din[n],e,esize]);
// The following only saturates if both op1 and op2 equal -(2^(esize-1))
(product, sat) = SignedSatQ(2*op1*op2, 2*esize);
Elem[Q[d>>1],e,2*esize] = product;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>
VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1004 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.374 VQMOVN, VQMOVUN
Vector Saturating Move and Narrow copies each element of the operand vector to the corresponding element of the
destination vector.
The operand is a quadword vector. The elements can be any one of:
• 16-bit, 32-bit, or 64-bit signed integers
• 16-bit, 32-bit, or 64-bit unsigned integers.
The result is a doubleword vector. The elements are half the length of the operand vector elements. If the operand
is unsigned, the results are unsigned. If the operand is signed, the results can be signed or unsigned.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if op == ‘00’ then SEE VMOVN;
if size == ‘11’ || Vm<0> == ‘1’ then UNDEFINED;
src_unsigned = (op == ‘11’); dest_unsigned = (op<0> == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VQMOV{U}N<c>.<type><size> <Dd>, <Qm>
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 0 1 0 op M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 1 0 Vd 0 0 1 0 op M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1005
ID051414 Non-Confidential
Assembler syntax
where:
U If present, specifies that the operation produces unsigned results, even though the operands are
signed. Encoded as op = 0b01.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQMOVN or VQMOVUN instruction must
be unconditional. ARM strongly recommends that a Thumb VQMOVN or VQMOVUN instruction is
unconditional, see Conditional execution on page A8-288.
<type> The data type for the elements of the operand. It must be one of:
S Encoded as:
• op = 0b10 for VQMOVN.
• op = 0b01 for VQMOVUN.
U Encoded as op = 0b11. Not available for VQMOVUN.
<size> The data size for the elements of the operand. It must be one of:
16 Encoded as size = 0b00.
32 Encoded as size = 0b01.
64 Encoded as size = 0b10.
<Dd>, <Qm> The destination vector and the operand vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
(Elem[D[d],e,esize], sat) = SatQ(operand, esize, dest_unsigned);
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQMOV{U}N{<c>}{<q>}.<type><size> <Dd>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1006 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.375 VQNEG
Vector Saturating Negate negates each element in a vector, and places the results in the destination vector.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VQNEG<c>.<dt> <Qd>, <Qm>
VQNEG<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 1 1 1 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 1 1 1 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1007
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQNEG instruction must be
unconditional. ARM strongly recommends that a Thumb VQNEG instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoded as size = 0b00.
S16 Encoded as size = 0b01.
S32 Encoded as size = 0b10.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
result = -SInt(Elem[D[m+r],e,esize]);
(Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQNEG{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VQNEG{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1008 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.376 VQRDMULH
Vector Saturating Rounding Doubling Multiply Returning High Half multiplies corresponding elements in two
vectors, doubles the results, and places the most significant half of the final results in the destination vector. The
results are rounded (for truncated results see VQDMULH on page A8-1000).
The second operand can be a scalar instead of a vector. For more information about scalars see Advanced SIMD
scalars on page A7-260.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘00’ || size == ‘11’ then UNDEFINED;
scalar_form = FALSE; esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
if size == ‘11’ then SEE “Related encodings”;
if size == ‘00’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
scalar_form = TRUE; d = UInt(D:Vd); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
if size == ‘01’ then esize = 16; elements = 4; m = UInt(Vm<2:0>); index = UInt(M:Vm<3>);
if size == ‘10’ then esize = 32; elements = 2; m = UInt(Vm); index = UInt(M);
Encoding T1/A1 Advanced SIMD
VQRDMULH<c>.<dt> <Qd>, <Qn>, <Qm>
VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm>
Encoding T2/A2 Advanced SIMD
VQRDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]>
VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 1 1 1 1 1 0 D size Vn Vd 1 0 1 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 0 D size Vn Vd 1 0 1 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 Q 1 1 1 1 1 D size Vn Vd 1 1 0 1 N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 Q 1 D size Vn Vd 1 1 0 1 N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1009
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQRDMULH instruction must
be unconditional. ARM strongly recommends that a Thumb VQRDMULH instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
S16 Encoded as size = 0b01.
S32 Encoded as size = 0b10.
<Qd>, <Qn> The destination vector and the first operand vector, for a quadword operation.
<Dd>, <Dn> The destination vector and the first operand vector, for a doubleword operation.
<Qm> The second operand vector, for a quadword all vector operation.
<Dm> The second operand vector, for a doubleword all vector operation.
<Dm[x]> The scalar for either a quadword or a doubleword scalar operation. If <dt> is S16, Dm is
restricted to D0-D7. If <dt> is S32, Dm is restricted to D0-D15.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
for r = 0 to regs-1
for e = 0 to elements-1
op1 = SInt(Elem[D[n+r],e,esize]);
if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
(result, sat) = SignedSatQ((2*op1*op2 + round_const) >> esize, esize);
Elem[D[d+r],e,esize] = result;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQRDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1
VQRDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0
VQRDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]> Encoding T2/A2, encoded as Q = 1
VQRDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]> Encoding T2/A2, encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1010 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.377 VQRSHL
Vector Saturating Rounding Shift Left takes each element in a vector, shifts them by a value from the least
significant byte of the corresponding element of a second vector, and places the results in the destination vector. If
the shift value is positive, the operation is a left shift. Otherwise, it is a right shift.
For truncated results see VQSHL (register) on page A8-1014.
The first operand and result elements are the same data type, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
The second operand is a signed integer of the same size.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VQRSHL<c>.<type><size> <Qd>, <Qm>, <Qn>
VQRSHL<c>.<type><size> <Dd>, <Dm>, <Dn>
1 1 U 1 1 1 1 0 D size Vn Vd 0 1 0 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 1 0 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1011
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQRSHL instruction must be
unconditional. ARM strongly recommends that a Thumb VQRSHL instruction is
unconditional, see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
Together with the <size> field, this indicates the data type and size of the first operand and
the result.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
64 Encoded as size = 0b11.
<Qd>, <Qm>, <Qn> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dm>, <Dn> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
shift = SInt(Elem[D[n+r],e,esize]<7:0>);
round_const = 1 << (-1-shift); // 0 for left shift, 2^(n-1) for right shift
operand = Int(Elem[D[m+r],e,esize], unsigned);
(result, sat) = SatQ((operand + round_const) << shift, esize, unsigned);
Elem[D[d+r],e,esize] = result;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQRSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, <Qn> Encoded as Q = 1
VQRSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, <Dn> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1012 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.378 VQRSHRN, VQRSHRUN
Vector Saturating Rounding Shift Right, Narrow takes each element in a quadword vector of integers, right shifts
them by an immediate value, and places the rounded results in a doubleword vector.
For truncated results, see VQSHRN, VQSHRUN on page A8-1018.
The operand elements must all be the same size, and can be any one of:
• 16-bit, 32-bit, or 64-bit signed integers
• 16-bit, 32-bit, or 64-bit unsigned integers.
The result elements are half the width of the operand elements. If the operand elements are signed, the results can
be either signed or unsigned. If the operand elements are unsigned, the result elements must also be unsigned.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm6 IN “000xxx” then SEE “Related encodings”;
if U == ‘0’ && op == ‘0’ then SEE VRSHRN;
if Vm<0> == ‘1’ then UNDEFINED;
case imm6 of
when “001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “01xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “1xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
src_unsigned = (U == ‘1’ && op == ‘1’); dest_unsigned = (U == ‘1’);
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VQRSHR{U}N<c>.<type><size> <Dd>, <Qm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 1 0 0 op 0 1 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 1 0 0 op 0 1 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1013
ID051414 Non-Confidential
Assembler syntax
where:
U If present, specifies that the results are unsigned, although the operands are signed.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQRSHRN or VQRSHRUN instruction
must be unconditional. ARM strongly recommends that a Thumb VQRSHRN or VQRSHRUN instruction is
unconditional, see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed. Encoded as:
• U = 0, op = 1, for VQRSHRN.
• U = 1, op = 0, for VQRSHRUN.
U Unsigned:
• Encoded as U = 1, op = 1, for VQRSHRN.
• Not available for VQRSHRUN.
<size> The data size for the elements of the vectors. It must be one of:
16 Encoded as imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
32 Encoded as imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
64 Encoded as imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
<Dd>, <Qm> The destination vector and the operand vector.
<imm> The immediate value, in the range 1 to <size>/2. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount - 1);
for e = 0 to elements-1
operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
(result, sat) = SatQ((operand + round_const) >> shift_amount, esize, dest_unsigned);
Elem[D[d],e,esize] = result;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
VQRSHR{U}N{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>
VQRSHRN.I<size> <Dd>, <Qm>, #0 is a synonym for VQMOVN.I<size> <Dd>, <Qm>
VQRSHRUN.I<size> <Dd>, <Qm>, #0 is a synonym for VQMOVUN.I<size> <Dd>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1014 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.379 VQSHL (register)
Vector Saturating Shift Left (register) takes each element in a vector, shifts them by a value from the least significant
byte of the corresponding element of a second vector, and places the results in the destination vector. If the shift
value is positive, the operation is a left shift. Otherwise, it is a right shift.
The results are truncated. For rounded results, see VQRSHL on page A8-1010.
The first operand and result elements are the same data type, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
The second operand is a signed integer of the same size.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VQSHL<c>.<type><size> <Qd>, <Qm>, <Qn>
VQSHL<c>.<type><size> <Dd>, <Dm>, <Dn>
1 1 U 1 1 1 1 0 D size Vn Vd 0 1 0 0 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 1 0 0 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1015
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQSHL instruction must be
unconditional. ARM strongly recommends that a Thumb VQSHL instruction is unconditional,
see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
Together with the <size> field, this indicates the data type and size of the first operand and
the result.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
64 Encoded as size = 0b11.
<Qd>, <Qm>, <Qn> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dm>, <Dn> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
shift = SInt(Elem[D[n+r],e,esize]<7:0>);
operand = Int(Elem[D[m+r],e,esize], unsigned);
(result,sat) = SatQ(operand << shift, esize, unsigned);
Elem[D[d+r],e,esize] = result;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, <Qn> Encoded as Q = 1
VQSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, <Dn> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1016 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.380 VQSHL, VQSHLU (immediate)
Vector Saturating Shift Left (immediate) takes each element in a vector of integers, left shifts them by an immediate
value, and places the results in a second vector.
The operand elements must all be the same size, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
The result elements are the same size as the operand elements. If the operand elements are signed, the results can
be either signed or unsigned. If the operand elements are unsigned, the result elements must also be unsigned.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (L:imm6) IN “0000xxx” then SEE “Related encodings”;
if U == ‘0’ && op == ‘0’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = UInt(imm6) - 8;
when “001xxxx” esize = 16; elements = 4; shift_amount = UInt(imm6) - 16;
when “01xxxxx” esize = 32; elements = 2; shift_amount = UInt(imm6) - 32;
when “1xxxxxx” esize = 64; elements = 1; shift_amount = UInt(imm6);
src_unsigned = (U == ‘1’ && op == ‘1’); dest_unsigned = (U == ‘1’);
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VQSHL{U}<c>.<type><size> <Qd>, <Qm>, #<imm>
VQSHL{U}<c>.<type><size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 0 1 1 op L Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 0 1 1 op L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1017
ID051414 Non-Confidential
Assembler syntax
where:
U If present, specifies that the results are unsigned, although the operands are signed.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQSHL or VQSHLU instruction must be
unconditional. ARM strongly recommends that a Thumb VQSHL or VQSHLU instruction is
unconditional, see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed. Encoded as:
• U = 0, op = 1, for VQSHL.
• U = 1, op = 0, for VQSHLU.
U Unsigned:
• Encoded as U = 1, op = 1, for VQSHL.
• Not available for VQSHLU.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. <imm> is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. <imm> is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. <imm> is encoded in imm6<4:0>.
64 Encoded as L = 1. <imm> is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 0 to <size>-1. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
operand = Int(Elem[D[m+r],e,esize], src_unsigned);
(result, sat) = SatQ(operand << shift_amount, esize, dest_unsigned);
Elem[D[d+r],e,esize] = result;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQSHL{U}{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VQSHL{U}{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1018 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.381 VQSHRN, VQSHRUN
Vector Saturating Shift Right, Narrow takes each element in a quadword vector of integers, right shifts them by an
immediate value, and places the truncated results in a doubleword vector.
For rounded results, see VQRSHRN, VQRSHRUN on page A8-1012.
The operand elements must all be the same size, and can be any one of:
• 16-bit, 32-bit, or 64-bit signed integers
• 16-bit, 32-bit, or 64-bit unsigned integers.
The result elements are half the width of the operand elements. If the operand elements are signed, the results can
be either signed or unsigned. If the operand elements are unsigned, the result elements must also be unsigned.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm6 IN “000xxx” then SEE “Related encodings”;
if U == ‘0’ && op == ‘0’ then SEE VSHRN;
if Vm<0> == ‘1’ then UNDEFINED;
case imm6 of
when “001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “01xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “1xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
src_unsigned = (U == ‘1’ && op == ‘1’); dest_unsigned = (U == ‘1’);
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VQSHR{U}N<c>.<type><size> <Dd>, <Qm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 1 0 0 op 0 0 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 1 0 0 op 0 0 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1019
ID051414 Non-Confidential
Assembler syntax
where:
U If present, specifies that the results are unsigned, although the operands are signed.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQSHRN or VQSHRUN instruction must
be unconditional. ARM strongly recommends that a Thumb VQSHRN or VQSHRUN instruction is
unconditional, see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed. Encoded as:
• U = 0, op = 1, for VQSHRN.
• U = 1, op = 0, for VQSHRUN.
U Unsigned:
• Encoded as U = 1, op = 1, for VQSHRN.
• Not available for VQSHRUN.
<size> The data size for the elements of the vectors. It must be one of:
16 Encoded as imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
32 Encoded as imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
64 Encoded as imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
<Dd>, <Qm> The destination vector, and the operand vector.
<imm> The immediate value, in the range 1 to <size>/2. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
(result, sat) = SatQ(operand >> shift_amount, esize, dest_unsigned);
Elem[D[d],e,esize] = result;
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
VQSHR{U}N{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>
VQSHRN.I<size> <Dd>, <Qm>, #0 is a synonym for VQMOVN.I<size> <Dd>, <Qm>
VQSHRUN.I<size> <Dd>, <Qm>, #0 is a synonym for VQMOVUN.I<size> <Dd>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1020 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.382 VQSUB
Vector Saturating Subtract subtracts the elements of the second operand vector from the corresponding elements of
the first operand vector, and places the results in the destination vector. Signed and unsigned operations are distinct.
The operand and result elements must all be the same type, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSCR.QC, is set if saturation
occurs. For details see Pseudocode details of saturation on page A2-44.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VQSUB<c>.<type><size> <Qd>, <Qn>, <Qm>
VQSUB<c>.<type><size> <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 0 0 1 0 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 0 1 0 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1021
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VQSUB instruction must be
unconditional. ARM strongly recommends that a Thumb VQSUB instruction is unconditional,
see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
64 Encoded as size = 0b11.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
diff = Int(Elem[D[n+r],e,esize], unsigned) - Int(Elem[D[m+r],e,esize], unsigned);
(Elem[D[d+r],e,esize], sat) = SatQ(diff, esize, unsigned);
if sat then FPSCR.QC = ‘1’;
Exceptions
Undefined Instruction, Hyp Trap.
VQSUB{<c>}{<q>}.<type><size> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VQSUB{<c>}{<q>}.<type><size> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1022 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.383 VRADDHN
Vector Rounding Add and Narrow, returning High Half adds corresponding elements in two quadword vectors, and
places the most significant half of each result in a doubleword vector. The results are rounded. (For truncated results,
see VADDHN on page A8-832.)
The operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no distinction between signed and unsigned
integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if Vn<0> == ‘1’ || Vm<0> == ‘1’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 1 1 1 1 1 1 D size Vn Vd 0 1 0 0 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D size Vn Vd 0 1 0 0 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1023
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRADDHN instruction must
be unconditional. ARM strongly recommends that a Thumb VRADDHN instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
I16 Encoded as size = 0b00.
I32 Encoded as size = 0b01.
I64 Encoded as size = 0b10.
<Dd>, <Qn>, <Qm> The destination vector and the operand vectors.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
for e = 0 to elements-1
result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize] + round_const;
Elem[D[d],e,esize] = result<2*esize-1:esize>;
Exceptions
Undefined Instruction, Hyp Trap.
VRADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1024 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.384 VRECPE
Vector Reciprocal Estimate finds an approximate reciprocal of each element in the operand vector, and places the
results in the destination vector.
The operand and result elements are the same type, and can be 32-bit floating-point numbers, or 32-bit unsigned
integers.
For details of the operation performed by this instruction see Floating-point reciprocal estimate and step on
page A2-85.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size != ‘10’ then UNDEFINED;
floating_point = (F == ‘1’); esize = 32; elements = 2;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VRECPE<c>.<dt> <Qd>, <Qm>
VRECPE<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 1 1 Vd 0 1 0 F 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 1 1 Vd 0 1 0 F 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1025
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRECPE instruction must be
unconditional. ARM strongly recommends that a Thumb VRECPE instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data types for the elements of the vectors. It must be one of:
U32 Encoded as F = 0, size = 0b10.
F32 Encoded as F = 1, size = 0b10.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
Elem[D[d+r],e,esize] = FPRecipEstimate(Elem[D[m+r],e,esize]);
else
Elem[D[d+r],e,esize] = UnsignedRecipEstimate(Elem[D[m+r],e,esize]);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Underflow, Division by Zero.
Newton-Raphson iteration
For details of the operation performed and how it can be used in a Newton-Raphson iteration to calculate the
reciprocal of a number, see Floating-point reciprocal estimate and step on page A2-85.
VRECPE{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VRECPE{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1026 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.385 VRECPS
Vector Reciprocal Step multiplies the elements of one vector by the corresponding elements of another vector,
subtracts each of the products from 2.0, and places the results into the elements of the destination vector.
The operand and result elements are 32-bit floating-point numbers.
For details of the operation performed by this instruction see Floating-point reciprocal estimate and step on
page A2-85.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VRECPS<c>.F32 <Qd>, <Qn>, <Qm>
VRECPS<c>.F32 <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D 0 sz Vn Vd 1 1 1 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 0 sz Vn Vd 1 1 1 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1027
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRECPS instruction must be
unconditional. ARM strongly recommends that a Thumb VRECPS instruction is
unconditional, see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = FPRecipStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
Newton-Raphson iteration
For details of the operation performed and how it can be used in a Newton-Raphson iteration to calculate the
reciprocal of a number, see Floating-point reciprocal estimate and step on page A2-85.
VRECPS{<c>}{<q>}.F32 {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VRECPS{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1028 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.386 VREV16, VREV32, VREV64
VREV16 (Vector Reverse in halfwords) reverses the order of 8-bit elements in each halfword of the vector, and places
the result in the corresponding destination vector.
VREV32 (Vector Reverse in words) reverses the order of 8-bit or 16-bit elements in each word of the vector, and places
the result in the corresponding destination vector.
VREV64 (Vector Reverse in doublewords) reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword
of the vector, and places the result in the corresponding destination vector.
There is no distinction between data types, other than size.
Figure A8-6 shows two examples of the operation of VREV.
Figure A8-6 VREV operation examples
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if UInt(op)+UInt(size) >= 3 then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
groupsize = (1 << (3-UInt(op)-UInt(size))); // elements per reversing group: 2, 4 or 8
reverse_mask = (groupsize-1)<esize-1:0>; // EORing mask used for index calculations
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Dm Qm
Dd Qm
VREV64.8, doubleword VREV64.32, quadword
Encoding T1/A1 Advanced SIMD
VREV<n><c>.<size> <Qd>, <Qm>
VREV<n><c>.<size> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 0 0 Vd 0 0 0 op Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 0 0 Vd 0 0 0 op Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1029
ID051414 Non-Confidential
Assembler syntax
where:
<n> The size of the regions in which the vector elements are reversed. It must be one of:
16 Encoded as op = 0b10.
32 Encoded as op = 0b01.
64 Encoded as op = 0b00.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VREV instruction must be
unconditional. ARM strongly recommends that a Thumb VREV instruction is unconditional, see
Conditional execution on page A8-288.
<size> The size of the vector elements. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<size> must specify a smaller size than <n>.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
If op + size >= 3, the instruction is reserved.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
bits(64) dest;
for r = 0 to regs-1
for e = 0 to elements-1
// Calculate destination element index by bitwise EOR on source element index:
e_bits = e<esize-1:0>; d_bits = e_bits EOR reverse_mask; d = UInt(d_bits);
Elem[dest,d,esize] = Elem[D[m+r],e,esize];
D[d+r] = dest;
Exceptions
Undefined Instruction, Hyp Trap.
VREV<n>{<c>}{<q>}.<size> <Qd>, <Qm> Encoded as Q = 1
VREV<n>{<c>}{<q>}.<size> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1030 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.387 VRHADD
Vector Rounding Halving Add adds corresponding elements in two vectors of integers, shifts each result right one
bit, and places the final results in the destination vector.
The operand and result elements are all the same type, and can be any one of:
• 8-bit, 16-bit, or 32-bit signed integers
• 8-bit, 16-bit, or 32-bit unsigned integers.
The results of the halving operations are rounded. For truncated results see VHADD, VHSUB on page A8-896.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘11’ then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VRHADD<c> <Qd>, <Qn>, <Qm>
VRHADD<c> <Dd>, <Dn>, <Dm>
1 1 U 1 1 1 1 0 D size Vn Vd 0 0 0 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 0 0 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1031
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRHADD instruction must be
unconditional. ARM strongly recommends that a Thumb VRHADD instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
S8 Encoded as size = 0b00, U = 0.
S16 Encoded as size = 0b01, U = 0.
S32 Encoded as size = 0b10, U = 0.
U8 Encoded as size = 0b00, U = 1.
U16 Encoded as size = 0b01, U = 1.
U32 Encoded as size = 0b10, U = 1.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
op1 = Int(Elem[D[n+r],e,esize], unsigned);
op2 = Int(Elem[D[m+r],e,esize], unsigned);
result = op1 + op2 + 1;
Elem[D[d+r],e,esize] = result<esize:1>;
Exceptions
Undefined Instruction, Hyp Trap.
VRHADD{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VRHADD{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1032 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.388 VRSHL
Vector Rounding Shift Left takes each element in a vector, shifts them by a value from the least significant byte of
the corresponding element of a second vector, and places the results in the destination vector. If the shift value is
positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. (For a truncating shift,
see VSHL (register) on page A8-1048).
The first operand and result elements are the same data type, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
The second operand is always a signed integer of the same size.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VRSHL<c>.<type><size> <Qd>, <Qm>, <Qn>
VRSHL<c>.<type><size> <Dd>, <Dm>, <Dn>
1 1 U 1 1 1 1 0 D size Vn Vd 0 1 0 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 1 0 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1033
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRSHL instruction must be
unconditional. ARM strongly recommends that a Thumb VRSHL instruction is unconditional,
see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
Together with the <size> field, this indicates the data type and size of the first operand and
the result.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
64 Encoded as size = 0b11.
<Qd>, <Qm>, <Qn> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dm>, <Dn> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
shift = SInt(Elem[D[n+r],e,esize]<7:0>);
round_const = 1 << (-shift-1); // 0 for left shift, 2^(n-1) for right shift
result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) << shift;
Elem[D[d+r],e,esize] = result<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VRSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, <Qn> Encoded as Q = 1
VRSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, <Dn> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1034 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.389 VRSHR
Vector Rounding Shift Right takes each element in a vector, right shifts them by an immediate value, and places the
rounded results in the destination vector. For truncated results, see VSHR on page A8-1052.
The operand and result elements must be the same size, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers.
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (L:imm6) IN “0000xxx” then SEE “Related encodings”;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “001xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “01xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
when “1xxxxxx” esize = 64; elements = 1; shift_amount = 64 - UInt(imm6);
unsigned = (U == ‘1’); d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VRSHR<c>.<type><size> <Qd>, <Qm>, #<imm>
VRSHR<c>.<type><size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 0 0 1 0 L Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 0 0 1 0 L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1035
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRSHR instruction must be
unconditional. ARM strongly recommends that a Thumb VRSHR instruction is unconditional, see
Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0
U Unsigned, encoded as U = 1.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
64 Encoded as L = 1. (64 – <imm>) is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 1 to <size>. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount - 1);
for r = 0 to regs-1
for e = 0 to elements-1
result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
Elem[D[d+r],e,esize] = result<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
For details see VMOV (register) on page A8-938.
VRSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VRSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
VRSHR.<type><size> <Qd>, <Qm>, #0 is a synonym for VMOV <Qd>, <Qm>
VRSHR.<type><size> <Dd>, <Dm>, #0 is a synonym for VMOV <Dd>, <Dm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1036 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.390 VRSHRN
Vector Rounding Shift Right and Narrow takes each element in a vector, right shifts them by an immediate value,
and places the rounded results in the destination vector. For truncated results, see VSHRN on page A8-1054.
The operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no distinction between signed and unsigned
integers. The destination elements are half the size of the source elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm6 IN “000xxx” then SEE “Related encodings”;
if Vm<0> == ‘1’ then UNDEFINED;
case imm6 of
when “001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “01xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “1xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 0 1 1 1 1 1 D imm6 Vd 1 0 0 0 0 1 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D imm6 Vd 1 0 0 0 0 1 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1037
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRSHRN instruction must be
unconditional. ARM strongly recommends that a Thumb VRSHRN instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
16 Encoded as imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
32 Encoded as imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
64 Encoded as imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
<Dd>, <Qm> The destination vector, and the operand vector.
<imm> The immediate value, in the range 1 to <size>/2. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount-1);
for e = 0 to elements-1
result = LSR(Elem[Qin[m>>1],e,2*esize] + round_const, shift_amount);
Elem[D[d],e,esize] = result<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
For details see VMOVN on page A8-952.
VRSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>
VRSHRN.I<size> <Dd>, <Qm>, #0 is a synonym for VMOVN.I<size> <Dd>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1038 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.391 VRSQRTE
Vector Reciprocal Square Root Estimate finds an approximate reciprocal square root of each element in a vector,
and places the results in a second vector.
The operand and result elements are the same type, and can be 32-bit floating-point numbers, or 32-bit unsigned
integers.
For details of the operation performed by this instruction see Floating-point reciprocal square root estimate and
step on page A2-87.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size != ‘10’ then UNDEFINED;
floating_point = (F == ‘1’); esize = 32; elements = 2;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (F = 1 UNDEFINED in integer-only variants)
VRSQRTE<c>.<dt> <Qd>, <Qm>
VRSQRTE<c>.<dt> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 1 1 Vd 0 1 0 F 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 1 1 Vd 0 1 0 F 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1039
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRSQRTE instruction must be
unconditional. ARM strongly recommends that a Thumb VRSQRTE instruction is unconditional, see
Conditional execution on page A8-288.
<dt> The data types for the elements of the vectors. It must be one of:
U32 Encoded as F = 0, size = 0b10.
F32 Encoded as F = 1, size = 0b10.
<Qd>, <Qm> The destination vector and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if floating_point then
Elem[D[d+r],e,esize] = FPRSqrtEstimate(Elem[D[m+r],e,esize]);
else
Elem[D[d+r],e,esize] = UnsignedRSqrtEstimate(Elem[D[m+r],e,esize]);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Division by Zero.
Newton-Raphson iteration
For details of the operation performed and how it can be used in a Newton-Raphson iteration to calculate the
reciprocal of the square root of a number, see Floating-point reciprocal square root estimate and step on
page A2-87.
VRSQRTE{<c>}{<q>}.<dt> <Qd>, <Qm> Encoded as Q = 1
VRSQRTE{<c>}{<q>}.<dt> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1040 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.392 VRSQRTS
Vector Reciprocal Square Root Step multiplies the elements of one vector by the corresponding elements of another
vector, subtracts each of the products from 3.0, divides these results by 2.0, and places the results into the elements
of the destination vector.
The operand and result elements are 32-bit floating-point numbers.
For details of the operation performed by this instruction see Floating-point reciprocal square root estimate and
step on page A2-87.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VRSQRTS<c>.F32 <Qd>, <Qn>, <Qm>
VRSQRTS<c>.F32 <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D 1 sz Vn Vd 1 1 1 1 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 0 D 1 sz Vn Vd 1 1 1 1 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1041
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRSQRTS instruction must
be unconditional. ARM strongly recommends that a Thumb VRSQRTS instruction is
unconditional, see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = FPRSqrtStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
Newton-Raphson iteration
For details of the operation performed and how it can be used in a Newton-Raphson iteration to calculate the
reciprocal of the square root of a number, see Floating-point reciprocal square root estimate and step on
page A2-87.
VRSQRTS{<c>}{<q>}.F32 {<Qd>,} <Qn>, <Qm> Encoded as Q = 1, sz = 0
VRSQRTS{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoded as Q = 0, sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1042 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.393 VRSRA
Vector Rounding Shift Right and Accumulate takes each element in a vector, right shifts them by an immediate
value, and accumulates the rounded results into the destination vector. (For truncated results, see VSRA on
page A8-1060.)
The operand and result elements must all be the same type, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers.
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (L:imm6) IN “0000xxx” then SEE “Related encodings”;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “001xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “01xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
when “1xxxxxx” esize = 64; elements = 1; shift_amount = 64 - UInt(imm6);
unsigned = (U == ‘1’); d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VRSRA<c>.<type><size> <Qd>, <Qm>, #<imm>
VRSRA<c>.<type><size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 0 0 1 1 L Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 0 0 1 1 L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1043
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRSRA instruction must be
unconditional. ARM strongly recommends that a Thumb VRSRA instruction is unconditional, see
Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
64 Encoded as L = 1. (64 – <imm>) is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 1 to <size>. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount - 1);
for r = 0 to regs-1
for e = 0 to elements-1
result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;
Exceptions
Undefined Instruction, Hyp Trap.
VRSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VRSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1044 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.394 VRSUBHN
Vector Rounding Subtract and Narrow, returning High Half subtracts the elements of one quadword vector from the
corresponding elements of another quadword vector takes the most significant half of each result, and places the
final results in a doubleword vector. The results are rounded. (For truncated results, see VSUBHN on
page A8-1088.)
The operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no distinction between signed and unsigned
integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if Vn<0> == ‘1’ || Vm<0> == ‘1’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 1 1 1 1 1 1 D size Vn Vd 0 1 1 0 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D size Vn Vd 0 1 1 0 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1045
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VRSUBHN instruction must
be unconditional. ARM strongly recommends that a Thumb VRSUBHN instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
I16 Encoded as size = 0b00.
I32 Encoded as size = 0b01.
I64 Encoded as size = 0b10.
<Dd>, <Qn>, <Qm> The destination vector and the operand vectors.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
for e = 0 to elements-1
result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize] + round_const;
Elem[D[d],e,esize] = result<2*esize-1:esize>;
Exceptions
Undefined Instruction, Hyp Trap.
VRSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1046 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.395 VSHL (immediate)
Vector Shift Left (immediate) takes each element in a vector of integers, left shifts them by an immediate value, and
places the results in the destination vector.
Bits shifted out of the left of each element are lost.
The elements must all be the same size, and can be 8-bit, 16-bit, 32-bit, or 64-bit integers. There is no distinction
between signed and unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if L:imm6 IN “0000xxx” then SEE “Related encodings”;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = UInt(imm6) - 8;
when “001xxxx” esize = 16; elements = 4; shift_amount = UInt(imm6) - 16;
when “01xxxxx” esize = 32; elements = 2; shift_amount = UInt(imm6) - 32;
when “1xxxxxx” esize = 64; elements = 1; shift_amount = UInt(imm6);
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSHL<c>.I<size> <Qd>, <Qm>, #<imm>
VSHL<c>.I<size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 0 1 1 1 1 1 D imm6 Vd 0 1 0 1 L Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D imm6 Vd 0 1 0 1 L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1047
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSHL instruction must be
unconditional. ARM strongly recommends that a Thumb VSHL instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. <imm> is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. <imm> is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. <imm> is encoded in imm6<4:0>.
64 Encoded as L = 1. <imm> is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 0 to <size>-1. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = LSL(Elem[D[m+r],e,esize], shift_amount);
Exceptions
Undefined Instruction, Hyp Trap.
VSHL{<c>}{<q>}.I<size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VSHL{<c>}{<q>}.I<size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1048 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.396 VSHL (register)
Vector Shift Left (register) takes each element in a vector, shifts them by a value from the least significant byte of
the corresponding element of a second vector, and places the results in the destination vector. If the shift value is
positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift.
Note
For a rounding shift, see VRSHL on page A8-1032.
The first operand and result elements are the same data type, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
The second operand is always a signed integer of the same size.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’ || Vn<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); n = UInt(N:Vn); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSHL<c>.<type><size> <Qd>, <Qm>, <Qn>
VSHL<c>.<type><size> <Dd>, <Dm>, <Dn>
1 1 U 1 1 1 1 0 D size Vn Vd 0 1 0 0 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 0 D size Vn Vd 0 1 0 0 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1049
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSHL instruction must be
unconditional. ARM strongly recommends that a Thumb VSHL instruction is unconditional,
see Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
Together with the <size> field, this indicates the data type and size of the first operand and
the result.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
64 Encoded as size = 0b11.
<Qd>, <Qm>, <Qn> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dm>, <Dn> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
shift = SInt(Elem[D[n+r],e,esize]<7:0>);
result = Int(Elem[D[m+r],e,esize], unsigned) << shift;
Elem[D[d+r],e,esize] = result<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, <Qn> Encoded as Q = 1
VSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, <Dn> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1050 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.397 VSHLL
Vector Shift Left Long takes each element in a doubleword vector, left shifts them by an immediate value, and places
the results in a quadword vector.
The operand elements can be:
• 8-bit, 16-bit, or 32-bit signed integers
• 8-bit, 16-bit, or 32-bit unsigned integers
• 8-bit, 16-bit, or 32-bit untyped integers (maximum shift only).
The result elements are twice the length of the operand elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm6 IN “000xxx” then SEE “Related encodings”;
if Vd<0> == ‘1’ then UNDEFINED;
case imm6 of
when “001xxx” esize = 8; elements = 8; shift_amount = UInt(imm6) - 8;
when “01xxxx” esize = 16; elements = 4; shift_amount = UInt(imm6) - 16;
when “1xxxxx” esize = 32; elements = 2; shift_amount = UInt(imm6) - 32;
if shift_amount == 0 then SEE VMOVL;
unsigned = (U == ‘1’); d = UInt(D:Vd); m = UInt(M:Vm);
if size == ‘11’ || Vd<0> == ‘1’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize; shift_amount = esize;
unsigned = FALSE; // Or TRUE without change of functionality
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> (0 < <imm> < <size>)
Encoding T2/A2 Advanced SIMD
VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> (<imm> == <size>)
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 1 0 1 0 0 0 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 1 0 1 0 0 0 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 0 1 1 0 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D 1 1 size 1 0 Vd 0 0 1 1 0 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1051
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSHLL instruction must be
unconditional. ARM strongly recommends that a Thumb VSHLL instruction is unconditional, see
Conditional execution on page A8-288.
<type> The data type for the elements of the operand. It must be one of:
S Signed. In encoding T1/A1, encoded as U = 0.
U Unsigned. In encoding T1/A1, encoded as U = 1.
I Untyped integer, Available only in encoding T2/A2.
<size> The data size for the elements of the operand. Table A8-8 shows the permitted values and their
encodings:
<Qd>, <Dm> The destination vector and the operand vector.
<imm> The immediate value. <imm> must lie in the range 1 to <size>, and:
• if <size> == <imm>, the encoding is T2/A2
• otherwise, the encoding is T1/A1, and:
— if <size> == 8, <imm> is encoded in imm6<2:0>
— if <size> == 16, <imm> is encoded in imm6<3:0>
— if <size> == 32, <imm> is encoded in imm6<4:0>.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
result = Int(Elem[Din[m],e,esize], unsigned) << shift_amount;
Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>
Table A8-8 VSHLL <size> field encoding
<size> Encoding T1/A1 Encoding T2/A2
8 Encoded as imm6<5:3> = 0b001 Encoded as size = 0b00
16 Encoded as imm6<5:4> = 0b01 Encoded as size = 0b01
32 Encoded as imm6<5> = 1 Encoded as size = 0b10
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1052 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.398 VSHR
Vector Shift Right takes each element in a vector, right shifts them by an immediate value, and places the truncated
results in the destination vector. For rounded results, see VRSHR on page A8-1034.
The operand and result elements must be the same size, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers.
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (L:imm6) IN “0000xxx” then SEE “Related encodings”;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “001xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “01xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
when “1xxxxxx” esize = 64; elements = 1; shift_amount = 64 - UInt(imm6);
unsigned = (U == ‘1’); d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSHR<c>.<type><size> <Qd>, <Qm>, #<imm>
VSHR<c>.<type><size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 0 0 0 0 L Q M 1 Vm
1514131211 10 9 8 7 6 5 4 3 2 1 0 1514131211 10 9 8 7 6 5 4 3 2 1 0
1
1 1 1 0 0 1 U 1 D imm6 Vd 0 0 0 0 L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1053
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSHR instruction must be
unconditional. ARM strongly recommends that a Thumb VSHR instruction is unconditional, see
Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
64 Encoded as L = 1. (64 – <imm>) is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 1 to <size>. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
Elem[D[d+r],e,esize] = result<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
VSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
VSHR.<type><size> <Qd>, <Qm>, #0 is a synonym for VMOV <Qd>, <Qm>
VSHR.<type><size> <Dd>, <Dm>, #0 is a synonym for VMOV <Dd>, <Dm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1054 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.399 VSHRN
Vector Shift Right Narrow takes each element in a vector, right shifts them by an immediate value, and places the
truncated results in the destination vector. For rounded results, see VRSHRN on page A8-1036.
The operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no distinction between signed and unsigned
integers. The destination elements are half the size of the source elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if imm6 IN “000xxx” then SEE “Related encodings”;
if Vm<0> == ‘1’ then UNDEFINED;
case imm6 of
when “001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “01xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “1xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
d = UInt(D:Vd); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VSHRN<c>.I<size> <Dd>, <Qm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 0 1 1 1 1 1 D imm6 Vd 1 0 0 0 0 0 M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 0 1 D imm6 Vd 1 0 0 0 0 0 M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1055
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSHRN instruction must be
unconditional. ARM strongly recommends that a Thumb VSHRN instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
16 Encoded as imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
32 Encoded as imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
64 Encoded as imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
<Dd>, <Qm> The destination vector, and the operand vector.
<imm> The immediate value, in the range 1 to <size>/2. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
result = LSR(Elem[Qin[m>>1],e,2*esize], shift_amount);
Elem[D[d],e,esize] = result<esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
For details see VMOVN on page A8-952.
VSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>
VSHRN.I<size> <Dd>, <Qm>, #0 is a synonym for VMOVN.I<size> <Dd>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1056 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.400 VSLI
Vector Shift Left and Insert takes each element in the operand vector, left shifts them by an immediate value, and
inserts the results in the destination vector. Bits shifted out of the left of each element are lost.
The elements must all be the same size, and can be 8-bit, 16-bit, 32-bit, or 64-bit. There is no distinction between
data types.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (L:imm6) IN “0000xxx” then SEE “Related encodings”;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = UInt(imm6) - 8;
when “001xxxx” esize = 16; elements = 4; shift_amount = UInt(imm6) - 16;
when “01xxxxx” esize = 32; elements = 2; shift_amount = UInt(imm6) - 32;
when “1xxxxxx” esize = 64; elements = 1; shift_amount = UInt(imm6);
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSLI<c>.<size> <Qd>, <Qm>, #<imm>
VSLI<c>.<size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 1 1 1 1 1 1 D imm6 Vd 0 1 0 1 L Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D imm6 Vd 0 1 0 1 L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1057
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSLI instruction must be
unconditional. ARM strongly recommends that a Thumb VSLI instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. <imm> is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. <imm> is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. <imm> is encoded in imm6<4:0>.
64 Encoded as L = 1. <imm> is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 0 to <size>-1. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
mask = LSL(Ones(esize), shift_amount);
for r = 0 to regs-1
for e = 0 to elements-1
shifted_op = LSL(Elem[D[m+r],e,esize], shift_amount);
Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;
Exceptions
Undefined Instruction, Hyp Trap.
VSLI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VSLI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1058 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.401 VSQRT
This instruction calculates the square root of the value in a floating-point register and writes the result to another
floating-point register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 summarizes these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VSQRT<c>.F64 <Dd>, <Dm>
VSQRT<c>.F32 <Sd>, <Sm>
VFP vectors This instruction can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
1 1 0 1 1 1 0 1 D 1 1 0 0 0 1 Vd 1 0 1 sz 1 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 D 1 1 0 0 0 1 Vd 1 0 1 sz 1 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
cond
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1059
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
<Dd>, <Dm> The destination vector and the operand vector, for a double-precision operation.
<Sd>, <Sm> The destination vector and the operand vector, for a single-precision operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE);
if dp_operation then
D[d] = FPSqrt(D[m]);
else
S[d] = FPSqrt(S[m]);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Invalid Operation, Inexact, Input Denormal.
VSQRT{<c>}{<q>}.F64 <Dd>, <Dm> Encoded as sz = 1
VSQRT{<c>}{<q>}.F32 <Sd>, <Sm> Encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1060 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.402 VSRA
Vector Shift Right and Accumulate takes each element in a vector, right shifts them by an immediate value, and
accumulates the truncated results into the destination vector. (For rounded results, see VRSRA on page A8-1042.)
The operand and result elements must all be the same type, and can be any one of:
• 8-bit, 16-bit, 32-bit, or 64-bit signed integers.
• 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (L:imm6) IN “0000xxx” then SEE “Related encodings”;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “001xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “01xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
when “1xxxxxx” esize = 64; elements = 1; shift_amount = 64 - UInt(imm6);
unsigned = (U == ‘1’); d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSRA<c>.<type><size> <Qd>, <Qm>, #<imm>
VSRA<c>.<type><size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 U 1 1 1 1 1 D imm6 Vd 0 0 0 1 L Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 U 1 D imm6 Vd 0 0 0 1 L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1061
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSRA instruction must be
unconditional. ARM strongly recommends that a Thumb VSRA instruction is unconditional, see
Conditional execution on page A8-288.
<type> The data type for the elements of the vectors. It must be one of:
S Signed, encoded as U = 0.
U Unsigned, encoded as U = 1.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
64 Encoded as L = 1. (64 – <imm>) is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 1 to <size>. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;
Exceptions
Undefined Instruction, Hyp Trap.
VSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1062 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.403 VSRI
Vector Shift Right and Insert takes each element in the operand vector, right shifts them by an immediate value, and
inserts the results in the destination vector. Bits shifted out of the right of each element are lost.
The elements must all be the same size, and can be 8-bit, 16-bit, 32-bit, or 64-bit. There is no distinction between
data types.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if (L:imm6) IN “0000xxx” then SEE “Related encodings”;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
case L:imm6 of
when “0001xxx” esize = 8; elements = 8; shift_amount = 16 - UInt(imm6);
when “001xxxx” esize = 16; elements = 4; shift_amount = 32 - UInt(imm6);
when “01xxxxx” esize = 32; elements = 2; shift_amount = 64 - UInt(imm6);
when “1xxxxxx” esize = 64; elements = 1; shift_amount = 64 - UInt(imm6);
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSRI<c>.<size> <Qd>, <Qm>, #<imm>
VSRI<c>.<size> <Dd>, <Dm>, #<imm>
Related encodings See One register and a modified immediate value on page A7-269.
1 1 1 1 1 1 1 1 D imm6 Vd 0 1 0 0 L Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 D imm6 Vd 0 1 0 0 L Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1063
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSRI instruction must be
unconditional. ARM strongly recommends that a Thumb VSRI instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as L = 0, imm6<5:3> = 0b001. (8 – <imm>) is encoded in imm6<2:0>.
16 Encoded as L = 0, imm6<5:4> = 0b01. (16 – <imm>) is encoded in imm6<3:0>.
32 Encoded as L = 0, imm6<5> = 0b1. (32 – <imm>) is encoded in imm6<4:0>.
64 Encoded as L = 1. (64 – <imm>) is encoded in imm6<5:0>.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
<imm> The immediate value, in the range 1 to <size>. See the description of <size> for how <imm> is
encoded.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
mask = LSR(Ones(esize), shift_amount);
for r = 0 to regs-1
for e = 0 to elements-1
shifted_op = LSR(Elem[D[m+r],e,esize], shift_amount);
Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;
Exceptions
Undefined Instruction, Hyp Trap.
VSRI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm> Encoded as Q = 1
VSRI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1064 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.404 VST1 (multiple single elements)
Vector Store (multiple single elements) stores elements to memory from one, two, three, or four registers, without
interleaving. Every element of each register is stored. For details of the addressing mode see Advanced SIMD
addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
case type of
when ‘0111’
regs = 1; if align<1> == ‘1’ then UNDEFINED;
when ‘1010’
regs = 2; if align == ‘11’ then UNDEFINED;
when ‘0110’
regs = 3; if align<1> == ‘1’ then UNDEFINED;
when ‘0010’
regs = 4;
otherwise
SEE “Related encodings”;
alignment = if align == ‘00’ then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST1 instruction must be
unconditional. ARM strongly recommends that a Thumb VST1 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
64 Encoded as size = 0b11.
Encoding T1/A1 Advanced SIMD
VST1<c>.<size> <list>, [<Rn>{:<align>}]{!}
VST1<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
1 1 1 1 0 0 1 0 D 0 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 0 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1065
ID051414 Non-Confidential
<list> The list of registers to store. It must be one of:
{<Dd>} Encoded as D:Vd = <Dd>, type = 0b0111.
{<Dd>, <Dd+1>} Encoded as D:Vd = <Dd>, type = 0b1010.
{<Dd>, <Dd+1>, <Dd+2>}
Encoded as D:Vd = <Dd>, type = 0b0110.
{<Dd>, <Dd+1>, <Dd+2>, <Dd+3>}
Encoded as D:Vd = <Dd>, type = 0b0010.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
64 8-byte alignment, encoded as align = 0b01.
128 16-byte alignment, available only if <list> contains two or four registers, encoded as
align = 0b10.
256 32-byte alignment, available only if <list> contains four registers, encoded as
align = 0b11.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, TRUE);
for r = 0 to regs-1
for e = 0 to elements - 1
if ebytes != 8 then
MemU[address, ebytes] = Elem[D[d+r], e, esize];
else
if SCTLR.A == ‘1’ && address != Align(address, 8) then AlignmentFault(address, FALSE);
data = Elem[D[d+r], e, esize];
MemU[address, 4] = if BigEndian() then data<63:32> else data<31:0>;
MemU[address+4, 4] = if BigEndian() then data<31:0> else data<63:32>;
address = address + ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 8*regs);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1066 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.405 VST1 (single element from one lane)
This instruction stores one element to memory from one element of a register. For details of the addressing mode
see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case size of
when ‘00’
if index_align<0> != ‘0’ then UNDEFINED;
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); alignment = 1;
when ‘01’
if index_align<1> != ‘0’ then UNDEFINED;
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
alignment = if index_align<0> == ‘0’ then 1 else 2;
when ‘10’
if index_align<2> != ‘0’ then UNDEFINED;
if index_align<1:0> != ‘00’ && index_align<1:0> != ‘11’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
alignment = if index_align<1:0> == ‘00’ then 1 else 4;
d = UInt(D:Vd); n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VST1<c>.<size> <list>, [<Rn>{:<align>}]{!}
VST1<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
1 1 1 1 0 0 1 1 D 0 0 Rn Vd size 0 0 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 0 0 Rn Vd size 0 0 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1067
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST1 instruction must be
unconditional. ARM strongly recommends that a Thumb VST1 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<list> The register containing the element to store. It must be {<Dd[x]>}. The register Dd is encoded in D:Vd
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
16 2-byte alignment, available only if <size> is 16.
32 4-byte alignment, available only if <size> is 32.
omitted Standard alignment, see Unaligned data access on page A3-108.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Table A8-9 shows the encoding of index and alignment for different <size> values.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, TRUE);
MemU[address,ebytes] = Elem[D[d], index, esize];
if wback then R[n] = R[n] + (if register_index then R[m] else ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
Table A8-9 Encoding of index and alignment
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
<align> omitted index_align[0] = 0 index_align[1:0] = '00' index_align[2:0] = '000'
<align> == 16 - index_align[1:0] = '01' -
<align> == 32 - - index_align[2:0] = '011'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1068 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.406 VST2 (multiple 2-element structures)
This instruction stores multiple 2-element structures from two or four registers to memory, with interleaving. For
more information, see Element and structure load/store instructions on page A4-181. Every element of each register
is saved. For details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case type of
when ‘1000’
regs = 1; inc = 1; if align == ‘11’ then UNDEFINED;
when ‘1001’
regs = 1; inc = 2; if align == ‘11’ then UNDEFINED;
when ‘0011’
regs = 2; inc = 2;
otherwise
SEE “Related encodings”;
alignment = if align == ‘00’ then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); d2 = d + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d2+regs > 32 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VST2<c>.<size> <list>, [<Rn>{:<align>}]{!}
VST2<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
1 1 1 1 0 0 1 0 D 0 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 0 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1069
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST2 instruction must be
unconditional. ARM strongly recommends that a Thumb VST2 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<list> The list of registers to store. It must be one of:
{<Dd>, <Dd+1>} Encoded as D:Vd = <Dd>, type = 0b1000.
{<Dd>, <Dd+2>} Encoded as D:Vd = <Dd>, type = 0b1001.
{<Dd>, <Dd+1>, <Dd+2>, <Dd+3>}
Encoded as D:Vd = <Dd>, type = 0b0011.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
64 8-byte alignment, encoded as align = 0b01.
128 16-byte alignment, encoded as align = 0b10.
256 32-byte alignment, available only if <list> contains four registers, encoded as
align = 0b11.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, TRUE);
for r = 0 to regs-1
for e = 0 to elements-1
MemU[address, ebytes] = Elem[D[d+r], e, esize];
MemU[address+ebytes, ebytes] = Elem[D[d2+r],e, esize];
address = address + 2*ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 16*regs);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1070 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.407 VST2 (single 2-element structure from one lane)
This instruction stores one 2-element structure to memory from corresponding elements of two registers. For details
of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case size of
when ‘00’
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); inc = 1;
alignment = if index_align<0> == ‘0’ then 1 else 2;
when ‘01’
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
inc = if index_align<1> == ‘0’ then 1 else 2;
alignment = if index_align<0> == ‘0’ then 1 else 4;
when ‘10’
if index_align<1> != ‘0’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
inc = if index_align<2> == ‘0’ then 1 else 2;
alignment = if index_align<0> == ‘0’ then 1 else 8;
d = UInt(D:Vd); d2 = d + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST2 instruction must be
unconditional. ARM strongly recommends that a Thumb VST2 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<list> The registers containing the structure. Encoded with D:Vd = <Dd>. It must be one of:
{<Dd[x]>, <Dd+1[x]>} Single-spaced registers, see Table A8-10 on page A8-1071.
{<Dd[x]>, <Dd+2[x]>} Double-spaced registers, see Table A8-10 on page A8-1071. This is not
available if <size> == 8.
Encoding T1/A1 Advanced SIMD
VST2<c>.<size> <list>, [<Rn>{:<align>}]{!}
VST2<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
1 1 1 1 0 0 1 1 D 0 0 Rn Vd size 0 1 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 0 0 Rn Vd size 0 1 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1071
ID051414 Non-Confidential
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
16 2-byte alignment, available only if <size> is 8
32 4-byte alignment, available only if <size> is 16
64 8-byte alignment, available only if <size> is 32
omitted Standard alignment, see Unaligned data access on page A3-108.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, TRUE);
MemU[address, ebytes] = Elem[D[d], index, esize];
MemU[address+ebytes, ebytes] = Elem[D[d2], index, esize];
if wback then R[n] = R[n] + (if register_index then R[m] else 2*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
Table A8-10 Encoding of index, alignment, and register spacing
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
Single-spacing - index_align[1] = 0 index_align[2] = 0
Double-spacing - index_align[1] = 1 index_align[2] = 1
<align> omitted index_align[0] = 0 index_align[0] = 0 index_align[1:0] = '00'
<align> == 16 index_align[0] = 1 - -
<align> == 32 - index_align[0] = 1 -
<align> == 64 - - index_align[1:0] = '01'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1072 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.408 VST3 (multiple 3-element structures)
This instruction stores multiple 3-element structures to memory from three registers, with interleaving. For more
information, see Element and structure load/store instructions on page A4-181. Every element of each register is
saved. For details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || align<1> == ‘1’ then UNDEFINED;
case type of
when ‘0100’
inc = 1;
when ‘0101’
inc = 2;
otherwise
SEE “Related encodings”;
alignment = if align<0> == ‘0’ then 1 else 8;
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VST3<c>.<size> <list>, [<Rn>{:<align>}]{!}
VST3<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
1 1 1 1 0 0 1 0 D 0 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 0 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1073
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST3 instruction must be
unconditional. ARM strongly recommends that a Thumb VST3 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<list> The list of registers to store. It must be one of:
{<Dd>, <Dd+1>, <Dd+2>}
Encoded as D:Vd = <Dd>, type = 0b0100.
{<Dd>, <Dd+2>, <Dd+4>}
Encoded as D:Vd = <Dd>, type = 0b0101.
<Rn> Contains the base address for the access.
<align> The alignment. It can be:
64 8-byte alignment, encoded as align = 0b01.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, TRUE);
for e = 0 to elements-1
MemU[address, ebytes] = Elem[D[d], e, esize];
MemU[address+ebytes, ebytes] = Elem[D[d2], e, esize];
MemU[address+2*ebytes, ebytes] = Elem[D[d3], e, esize];
address = address + 3*ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 24);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1074 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.409 VST3 (single 3-element structure from one lane)
This instruction stores one 3-element structure to memory from corresponding elements of three registers. For
details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case size of
when ‘00’
if index_align<0> != ‘0’ then UNDEFINED;
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); inc = 1;
when ‘01’
if index_align<0> != ‘0’ then UNDEFINED;
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
inc = if index_align<1> == ‘0’ then 1 else 2;
when ‘10’
if index_align<1:0> != ‘00’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
inc = if index_align<2> == ‘0’ then 1 else 2;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VST3<c>.<size> <list>, [<Rn>]{!}
VST3<c>.<size> <list>, [<Rn>], <Rm>
1 1 1 1 0 0 1 1 D 0 0 Rn Vd size 1 0 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 0 0 Rn Vd size 1 0 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1075
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST3 instruction must be
unconditional. ARM strongly recommends that a Thumb VST3 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<list> The registers containing the structure. Encoded with D:Vd = <Dd>. It must be one of:
{<Dd[x]>, <Dd+1[x]>, <Dd+2[x]>}
Single-spaced registers, see Table A8-11.
{<Dd[x]>, <Dd+2[x]>, <Dd+4[x]>}
Double-spaced registers, see Table A8-11. This is not available if <size> == 8.
<Rn> Contains the base address for the access.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Alignment
Standard alignment rules apply, see Unaligned data access on page A3-108.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n];
MemU[address, ebytes] = Elem[D[d], index, esize];
MemU[address+ebytes, ebytes] = Elem[D[d2], index, esize];
MemU[address+2*ebytes, ebytes] = Elem[D[d3], index, esize];
if wback then R[n] = R[n] + (if register_index then R[m] else 3*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VST3{<c>}{<q>}.<size> <list>, [<Rn>] Encoded as Rm = 0b1111
VST3{<c>}{<q>}.<size> <list>, [<Rn>]! Encoded as Rm = 0b1101
VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm> Rm cannot be 0b11x1
Table A8-11 Encoding of index and register spacing
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
Single-spacing index_align[0] = 0 index_align[1:0] = '00' index_align[2:0] = '000'
Double-spacing - index_align[1:0] = '10' index_align[2:0] = '100'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1076 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.410 VST4 (multiple 4-element structures)
This instruction stores multiple 4-element structures to memory from four registers, with interleaving. For more
information, see Element and structure load/store instructions on page A4-181. Every element of each register is
saved. For details of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case type of
when ‘0000’
inc = 1;
when ‘0001’
inc = 2;
otherwise
SEE “Related encodings”;
alignment = if align == ‘00’ then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size); esize = 8 * ebytes; elements = 8 DIV ebytes;
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; d4 = d3 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
VST4<c>.<size> <list>, [<Rn>{:<align>}]{!}
VST4<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
Related encodings See Advanced SIMD element or structure load/store instructions on page A7-275.
1 1 1 1 0 0 1 0 D 0 0 Rn Vd type size align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 0 D 0 0 Rn Vd type size align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1077
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST4 instruction must be
unconditional. ARM strongly recommends that a Thumb VST4 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<list> The list of registers to store. It must be one of:
{<Dd>, <Dd+1>, <Dd+2>, <Dd+3>}
Encoded as D:Vd = <Dd>, type = 0b0000.
{<Dd>, <Dd+2>, <Dd+4>, <Dd+6>}
Encoded as D:Vd = <Dd>, type = 0b0001.
<Rn> Contains the base address for the access.
<align> The alignment. It can be one of:
64 8-byte alignment, encoded as align = 0b01.
128 16-byte alignment, encoded as align = 0b10.
256 32-byte alignment, encoded as align = 0b11.
omitted Standard alignment, see Unaligned data access on page A3-108. Encoded as
align = 0b00.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, TRUE);
for e = 0 to elements-1
MemU[address, ebytes] = Elem[D[d], e, esize];
MemU[address+ebytes, ebytes] = Elem[D[d2], e, esize];
MemU[address+2*ebytes, ebytes] = Elem[D[d3], e, esize];
MemU[address+3*ebytes, ebytes] = Elem[D[d4], e, esize];
address = address + 4*ebytes;
if wback then R[n] = R[n] + (if register_index then R[m] else 32);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1078 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.411 VST4 (single 4-element structure from one lane)
This instruction stores one 4-element structure to memory from corresponding elements of four registers. For details
of the addressing mode see Advanced SIMD addressing mode on page A7-277.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
case size of
when ‘00’
ebytes = 1; esize = 8; index = UInt(index_align<3:1>); inc = 1;
alignment = if index_align<0> == ‘0’ then 1 else 4;
when ‘01’
ebytes = 2; esize = 16; index = UInt(index_align<3:2>);
inc = if index_align<1> == ‘0’ then 1 else 2;
alignment = if index_align<0> == ‘0’ then 1 else 8;
when ‘10’
if index_align<1:0> == ‘11’ then UNDEFINED;
ebytes = 4; esize = 32; index = UInt(index_align<3>);
inc = if index_align<2> == ‘0’ then 1 else 2;
alignment = if index_align<1:0> == ‘00’ then 1 else 4 << UInt(index_align<1:0>);
d = UInt(D:Vd); d2 = d + inc; d3 = d2 + inc; d4 = d3 + inc; n = UInt(Rn); m = UInt(Rm);
wback = (m != 15); register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VST4 instruction must be
unconditional. ARM strongly recommends that a Thumb VST4 instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<list> The registers containing the structure. Encoded with D:Vd = <Dd>. It must be one of:
{<Dd[x]>, <Dd+1[x]>, <Dd+2[x]>, <Dd+3[x]>}
Single-spaced registers, see Table A8-12 on page A8-1079.
{<Dd[x]>, <Dd+2[x]>, <Dd+4[x]>, <Dd+6[x]>}
Double-spaced registers, see Table A8-12 on page A8-1079. This is not available if
<size> == 8.
Encoding T1/A1 Advanced SIMD
VST4<c>.<size> <list>, [<Rn>{:<align>}]{!}
VST4<c>.<size> <list>, [<Rn>{:<align>}], <Rm>
VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}] Encoded as Rm = 0b1111
VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]! Encoded as Rm = 0b1101
VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm> Rm cannot be 0b11x1
1 1 1 1 0 0 1 1 D 0 0 Rn Vd size 1 1 index_align Rm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 0 1 D 0 0 Rn Vd size 1 1 index_align Rm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1079
ID051414 Non-Confidential
<Rn> The base address for the access.
<align> The alignment. It can be:
32 4-byte alignment, available only if <size> is 8.
64 8-byte alignment, available only if <size> is 16 or 32.
128 16-byte alignment, available only if <size> is 32.
omitted Standard alignment, see Unaligned data access on page A3-108.
: is the preferred separator before the <align> value, but the alignment can be specified as @<align>,
see Advanced SIMD addressing mode on page A7-277.
! If present, specifies writeback.
<Rm> Contains an address offset applied after the access.
For more information about <Rn>, !, and <Rm>, see Advanced SIMD addressing mode on page A7-277.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled(); NullCheckIfThumbEE(n);
address = R[n]; if (address MOD alignment) != 0 then AlignmentFault(address, TRUE);
MemU[address, ebytes] = Elem[D[d], index, esize];
MemU[address+ebytes, ebytes] = Elem[D[d2], index, esize];
MemU[address+2*ebytes, ebytes] = Elem[D[d3], index, esize];
MemU[address+3*ebytes, ebytes] = Elem[D[d4], index, esize];
if wback then R[n] = R[n] + (if register_index then R[m] else 4*ebytes);
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
Table A8-12 Encoding of index, alignment, and register spacing
<size> == 8 <size> == 16 <size> == 32
Index index_align[3:1] = x index_align[3:2] = x index_align[3] = x
Single-spacing - index_align[1] = 0 index_align[2] = 0
Double-spacing - index_align[1] = 1 index_align[2] = 1
<align> omitted index_align[0] = 0 index_align[0] = 0 index_align[1:0] = '00'
<align> == 32 index_align[0] = 1 - -
<align> == 64 - index_align[0] = 1 index_align[1:0] = '01'
<align> == 128 - - index_align[1:0] = '10'
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1080 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.412 VSTM
Vector Store Multiple stores multiple extension registers to consecutive memory locations using an address from an
ARM core register.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && U == ‘0’ && W == ‘0’ then SEE “Related encodings”;
if P == ‘1’ && U == ‘0’ && W == ‘1’ && Rn == ‘1101’ then SEE VPUSH;
if P == ‘1’ && W == ‘0’ then SEE VSTR;
if P == U && W == ‘1’ then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = FALSE; add = (U == ‘1’); wback = (W == ‘1’);
d = UInt(D:Vd); n = UInt(Rn); imm32 = ZeroExtend(imm8:’00’, 32);
regs = UInt(imm8) DIV 2; // If UInt(imm8) is odd, see “FSTMX”.
if n == 15 && (wback || CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
if VFPSmallRegisterBank() && (d+regs) > 16 then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if P == ‘0’ && U == ‘0’ && W == ‘0’ then SEE “Related encodings”;
if P == ‘1’ && U == ‘0’ && W == ‘1’ && Rn == ‘1101’ then SEE VPUSH;
if P == ‘1’ && W == ‘0’ then SEE VSTR;
if P == U && W == ‘1’ then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = TRUE; add = (U == ‘1’); wback = (W == ‘1’); d = UInt(Vd:D); n = UInt(Rn);
imm32 = ZeroExtend(imm8:’00’, 32); regs = UInt(imm8);
if n == 15 && (wback || CurrentInstrSet() != InstrSet_ARM) then UNPREDICTABLE;
if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VSTM{mode}<c> <Rn>{!}, <list> <list> is consecutive 64-bit registers
Encoding T2/A2 VFPv2, VFPv3, VFPv4
VSTM{mode}<c> <Rn>{!}, <list> <list> is consecutive 32-bit registers
Related encodings See 64-bit transfers between ARM core and extension registers on page A7-279.
FSTMX Encoding T1/A1 behaves as described by the pseudocode if imm8 is odd. However, there is
no UAL syntax for such encodings and ARM deprecates their use. For more information, see
FLDMX, FSTMX on page A8-388.
1 1 0 1 1 0 P U D W 0 Rn Vd 1 0 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 P U D W 0 Rn Vd 1 0 1 1 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 1 0 P U D W 0 Rn Vd 1 0 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 P U D W 0 Rn Vd 1 0 1 0 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1081
ID051414 Non-Confidential
Assembler syntax
VSTM{<mode>}{<c>}{<q>}{.<size>} <Rn>{!}, <list>
where:
<mode> The addressing mode:
IA Increment After. The consecutive addresses start at the address specified in <Rn>. This
is the default and can be omitted. Encoded as P = 0, U = 1.
DB Decrement Before. The consecutive addresses end just before the address specified in
<Rn>. Encoded as P = 1, U = 0.
<c>, <q> See Standard assembler syntax fields on page A8-287.
<size> An optional data size specifier. If present, it must be equal to the size in bits, 32 or 64, of the registers
in <list>.
<Rn> The base register. The SP can be used. In the ARM instruction set, if ! is not specified the PC can
be used. However, ARM deprecates use of the PC.
! Causes the instruction to write a modified value back to <Rn>. Required if <mode> == DB. Encoded
as W = 1.
If ! is omitted, the instruction does not change <Rn> in this way. Encoded as W = 0.
<list> The extension registers to be stored, as a list of consecutively numbered doubleword (encoding
T1/A1) or singleword (encoding T2/A2) registers, separated by commas and surrounded by
brackets. It is encoded in the instruction by setting D and Vd to specify the first register in the list,
and imm8 to twice the number of registers in the list (encoding T1/A1) or the number of registers
(encoding T2/A2). <list> must contain at least one register. If it contains doubleword registers it
must not contain more than 16 registers.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE); NullCheckIfThumbEE(n);
address = if add then R[n] else R[n]-imm32;
for r = 0 to regs-1
if single_regs then
MemA[address,4] = S[d+r]; address = address+4;
else
// Store as two word-aligned words in the correct order for current endianness.
MemA[address,4] = if BigEndian() then D[d+r]<63:32> else D[d+r]<31:0>;
MemA[address+4,4] = if BigEndian() then D[d+r]<31:0> else D[d+r]<63:32>;
address = address+8;
if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1082 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.413 VSTR
This instruction stores a single extension register to memory, using an address from an ARM core register, with an
optional offset.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_reg = FALSE; add = (U == ‘1’); imm32 = ZeroExtend(imm8:’00’, 32);
d = UInt(D:Vd); n = UInt(Rn);
if n == 15 && CurrentInstrSet() != InstrSet_ARM then UNPREDICTABLE;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
single_reg = TRUE; add = (U == ‘1’); imm32 = ZeroExtend(imm8:’00’, 32);
d = UInt(Vd:D); n = UInt(Rn);
if n == 15 && CurrentInstrSet() != InstrSet_ARM then UNPREDICTABLE;
Encoding T1/A1 VFPv2, VFPv3, VFPv4, Advanced SIMD
VSTR<c> <Dd>, [<Rn>{, #+/-<imm>}]
Encoding T2/A2 VFPv2, VFPv3, VFPv4
VSTR<c> <Sd>, [<Rn>{, #+/-<imm>}]
1 1 0 1 1 0 1 U D 0 0 Rn Vd 1 0 1 1 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 1 U D 0 0 Rn Vd 1 0 1 1 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 1 0 1 U D 0 0 Rn Vd 1 0 1 0 imm8
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 0 1 U D 0 0 Rn Vd 1 0 1 0 imm8
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1083
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
.32, .64 Optional data size specifiers.
<Dd> The source register for a doubleword store.
<Sd> The source register for a singleword store.
<Rn> The base register. The SP can be used. In the ARM instruction set the PC can be used. However,
ARM deprecates use of the PC.
+/- Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if
it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.
<imm> The immediate offset used for forming the address. Values are multiples of 4 in the range 0-1020.
<imm> can be omitted, meaning an offset of +0.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckVFPEnabled(TRUE); NullCheckIfThumbEE(n);
address = if add then (R[n] + imm32) else (R[n] - imm32);
if single_reg then
MemA[address,4] = S[d];
else
// Store as two word-aligned words in the correct order for current endianness.
MemA[address,4] = if BigEndian() then D[d]<63:32> else D[d]<31:0>;
MemA[address+4,4] = if BigEndian() then D[d]<31:0> else D[d]<63:32>;
Exceptions
Undefined Instruction, Hyp Trap, Data Abort.
VSTR{<c>}{<q>}{.64} <Dd>, [<Rn>{, #+/-<imm>}] Encoding T1/A1
VSTR{<c>}{<q>}{.32} <Sd>, [<Rn>{, #+/-<imm>}] Encoding T2/A2
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1084 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.414 VSUB (integer)
Vector Subtract subtracts the elements of one vector from the corresponding elements of another vector, and places
the results in the destination vector.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSUB<c>.<dt> <Qd>, <Qn>, <Qm>
VSUB<c>.<dt> <Dd>, <Dn>, <Dm>
1 1 1 1 1 1 1 0 D size Vn Vd 1 0 0 0 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 1 0 D size Vn Vd 1 0 0 0 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1085
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VSUB
instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VSUB instruction is unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the vectors. It must be one of:
I8 Encoded as size = 0b00.
I16 Encoded as size = 0b01.
I32 Encoded as size = 0b10.
I64 Encoded as size = 0b11.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] - Elem[D[m+r],e,esize];
Exceptions
Undefined Instruction, Hyp Trap.
VSUB{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>
VSUB{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1086 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.415 VSUB (floating-point)
Vector Subtract subtracts the elements of one vector from the corresponding elements of another vector, and places
the results in the destination vector.
Depending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the security state and mode in
which the instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp
mode. Summary of general controls of CP10 and CP11 functionality on page B1-1231 and Summary of access
controls for Advanced SIMD functionality on page B1-1233 summarize these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if sz == ‘1’ then UNDEFINED;
advsimd = TRUE; esize = 32; elements = 2;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
if FPSCR.Len != ‘000’ || FPSCR.Stride != ‘00’ then SEE “VFP vectors”;
advsimd = FALSE; dp_operation = (sz == ‘1’);
d = if dp_operation then UInt(D:Vd) else UInt(Vd:D);
n = if dp_operation then UInt(N:Vn) else UInt(Vn:N);
m = if dp_operation then UInt(M:Vm) else UInt(Vm:M);
Encoding T1/A1 Advanced SIMD (UNDEFINED in integer-only variant)
VSUB<c>.F32 <Qd>, <Qn>, <Qm>
VSUB<c>.F32 <Dd>, <Dn>, <Dm>
Encoding T2/A2 VFPv2, VFPv3, VFPv4 (sz = 1 UNDEFINED in single-precision only variants)
VSUB<c>.F64 <Dd>, <Dn>, <Dm>
VSUB<c>.F32 <Sd>, <Sn>, <Sm>
VFP vectors Encoding T2/A2 can operate on VFP vectors under control of the FPSCR.{Len, Stride} fields.
For details see Appendix D11 VFP Vector Operation Support.
1 1 0 1 1 1 1 0 D 1 sz Vn Vd 1 1 0 1 N Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 0 D 1 sz Vn Vd 1 1 0 1 N Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 1 1 0 0 D 1 1 Vn Vd 1 0 1 sz N 1 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 1 1 1 0 0 D 1 1 Vn Vd 1 0 1 sz N 1 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1087
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM Advanced SIMD VSUB
instruction must be unconditional. ARM strongly recommends that a Thumb Advanced
SIMD VSUB instruction is unconditional, see Conditional execution on page A8-288.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
<Sd>, <Sn>, <Sm> The destination vector and the operand vectors, for a singleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
for r = 0 to regs-1
for e = 0 to elements-1
Elem[D[d+r],e,esize] = FPSub(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], FALSE);
else // VFP instruction
if dp_operation then
D[d] = FPSub(D[n], D[m], TRUE);
else
S[d] = FPSub(S[n], S[m], TRUE);
Exceptions
Undefined Instruction, Hyp Trap.
Floating-point exceptions
Input Denormal, Invalid Operation, Overflow, Underflow, Inexact.
VSUB{<c>}{<q>}.F32 {<Qd>,} <Qn>, <Qm> Encoding T1/A1, encoded as Q = 1, sz = 0
VSUB{<c>}{<q>}.F32 {<Dd>,} <Dn>, <Dm> Encoding T1/A1, encoded as Q = 0, sz = 0
VSUB{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm> Encoding T2/A2, encoded as sz = 1
VSUB{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm> Encoding T2/A2, encoded as sz = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1088 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.416 VSUBHN
Vector Subtract and Narrow, returning High Half subtracts the elements of one quadword vector from the
corresponding elements of another quadword vector, takes the most significant half of each result, and places the
final results in a doubleword vector. The results are truncated. (For rounded results, see VRSUBHN on
page A8-1044.
There is no distinction between signed and unsigned integers.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if Vn<0> == ‘1’ || Vm<0> == ‘1’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 0 1 1 1 1 1 D size Vn Vd 0 1 1 0 N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 1 D size Vn Vd 0 1 1 0 N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1089
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSUBHN instruction must be
unconditional. ARM strongly recommends that a Thumb VSUBHN instruction is
unconditional, see Conditional execution on page A8-288.
<dt> The data type for the elements of the operands. It must be one of:
I16 Encoded as size = 0b00.
I32 Encoded as size = 0b01.
I64 Encoded as size = 0b10.
<Dd>, <Qn>, <Qm> The destination vector, the first operand vector, and the second operand vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize];
Elem[D[d],e,esize] = result<2*esize-1:esize>;
Exceptions
Undefined Instruction, Hyp Trap.
VSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1090 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.417 VSUBL, VSUBW
Vector Subtract Long subtracts the elements of one doubleword vector from the corresponding elements of another
doubleword vector, and places the results in a quadword vector. Before subtracting, it sign-extends or zero-extends
the elements of both operands.
Vector Subtract Wide subtracts the elements of a doubleword vector from the corresponding elements of a quadword
vector, and places the results in another quadword vector. Before subtracting, it sign-extends or zero-extends the
elements of the doubleword operand.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then SEE “Related encodings”;
if Vd<0> == ‘1’ || (op == ‘1’ && Vn<0> == ‘1’) then UNDEFINED;
unsigned = (U == ‘1’);
esize = 8 << UInt(size); elements = 64 DIV esize; is_vsubw = (op == ‘1’);
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
Encoding T1/A1 Advanced SIMD
VSUBL<c>.<dt> <Qd>, <Dn>, <Dm>
VSUBW<c>.<dt> <Qd>, <Qn>, <Dm>
Related encodings See Advanced SIMD data-processing instructions on page A7-261.
1 1 U 1 1 1 1 1 D size Vn Vd 0 0 1 op N 0 M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 U 1 D size Vn Vd 0 0 1 op N 0 M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1091
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSUBL or VSUBW instruction must be
unconditional. ARM strongly recommends that a Thumb VSUBL or VSUBW instruction is unconditional,
see Conditional execution on page A8-288.
<dt> The data type for the elements of the second operand. It must be one of:
S8 Encoded as size = 0b00, U = 0.
S16 Encoded as size = 0b01, U = 0.
S32 Encoded as size = 0b10, U = 0.
U8 Encoded as size = 0b00, U = 1.
U16 Encoded as size = 0b01, U = 1.
U32 Encoded as size = 0b10, U = 1.
<Qd> The destination register.
<Qn>, <Dm> The first and second operand registers for a VSUBW instruction.
<Dn>, <Dm> The first and second operand registers for a VSUBL instruction.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for e = 0 to elements-1
if is_vsubw then
op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
else
op1 = Int(Elem[Din[n],e,esize], unsigned);
result = op1 - Int(Elem[Din[m],e,esize], unsigned);
Elem[Q[d>>1],e,2*esize] = result<2*esize-1:0>;
Exceptions
Undefined Instruction, Hyp Trap.
VSUBL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm> Encoded as op = 0
VSUBW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm> Encoded as op = 1
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1092 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.418 VSWP
VSWP (Vector Swap) exchanges the contents of two vectors. The vectors can be either doubleword or quadword.
There is no distinction between data types.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size != ‘00’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VSWP<c> <Qd>, <Qm>
VSWP<c> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 0 0 0 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 1 1 D 1 1 size 1 0 Vd 0 0 0 0 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1093
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VSWP instruction must be
unconditional. ARM strongly recommends that a Thumb VSWP instruction is unconditional, see
Conditional execution on page A8-288.
<dt> An optional data type. It is ignored by assemblers, and does not affect the encoding.
<Qd>, <Qm> The vectors for a quadword operation.
<Dd>, <Dm> The vectors for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
if d == m then
D[d+r] = bits(64) UNKNOWN;
else
D[d+r] = Din[m+r];
D[m+r] = Din[d+r];
Exceptions
Undefined Instruction, Hyp Trap.
VSWP{<c>}{<q>}{.<dt>} <Qd>, <Qm> Encoded as Q = 1, size = 0b00
VSWP{<c>}{<q>}{.<dt>} <Dd>, <Dm> Encoded as Q = 0, size = 0b00
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1094 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.419 VTBL, VTBX
Vector Table Lookup uses byte indexes in a control vector to look up byte values in a table and generate a new
vector. Indexes out of range return 0.
Vector Table Extension works in the same way, except that indexes out of range leave the destination element
unchanged.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
is_vtbl = (op == ‘0’); length = UInt(len)+1;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
if n+length > 32 then UNPREDICTABLE;
Encoding T1/A1 Advanced SIMD
V<op><c>.8 <Dd>, <list>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 Vn Vd 1 0 len N op M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 1 1 D 1 1 Vn Vd 1 0 len N op M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1095
ID051414 Non-Confidential
Assembler syntax
where:
<op> The operation. It must be one of:
TBL Vector Table Lookup. Encoded as op = 0.
TBX Vector Table Extension. Encoded as op = 1.
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VTBL or VTBX instruction must be
unconditional. ARM strongly recommends that a Thumb VTBL or VTBX instruction is unconditional,
see Conditional execution on page A8-288.
<Dd> The destination vector.
<list> The vectors containing the table. It must be one of:
{<Dn>} encoded as len = 0b00.
{<Dn>, <Dn+1>} encoded as len = 0b01.
{<Dn>, <Dn+1>, <Dn+2>} encoded as len = 0b10.
{<Dn>, <Dn+1>, <Dn+2>, <Dn+3>}
encoded as len = 0b11.
<Dm> The index vector.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
// Create 256-bit = 32-byte table variable, with zeros in entries that will not be used.
table3 = if length == 4 then D[n+3] else Zeros(64);
table2 = if length >= 3 then D[n+2] else Zeros(64);
table1 = if length >= 2 then D[n+1] else Zeros(64);
table = table3 : table2 : table1 : D[n];
for i = 0 to 7
index = UInt(Elem[D[m],i,8]);
if index < 8*length then
Elem[D[d],i,8] = Elem[table,index,8];
else
if is_vtbl then
Elem[D[d],i,8] = Zeros(8);
// else Elem[D[d],i,8] unchanged
Exceptions
Undefined Instruction, Hyp Trap.
V<op>{<c>}{<q>}.8 <Dd>, <list>, <Dm>
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1096 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.420 VTRN
Vector Transpose treats the elements of its operand vectors as elements of 2 × 2 matrices, and transposes the
matrices.
The elements of the vectors can be 8-bit, 16-bit, or 32-bit. There is no distinction between data types.
Figure A8-7 shows the operation of doubleword VTRN. Quadword VTRN performs the same operation as doubleword
VTRN twice, once on the upper halves of the quadword vectors, and once on the lower halves
Figure A8-7 VTRN doubleword operation
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Dd
Dm
VTRN.16
3 2 1 0
Dd
Dm
VTRN.32
1 0
Dd
Dm
VTRN.8
7 6 5 4 3 2 1 0
Encoding T1/A1 Advanced SIMD
VTRN<c>.<size> <Qd>, <Qm>
VTRN<c>.<size> <Dd>, <Dm>
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 0 0 0 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 1 1 D 1 1 size 1 0 Vd 0 0 0 0 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1097
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VTRN instruction must be
unconditional. ARM strongly recommends that a Thumb VTRN instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<Qd>, <Qm> The destination vector, and the operand vector, for a quadword operation.
<Dd>, <Dm> The destination vector, and the operand vector, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
h = elements DIV 2;
for r = 0 to regs-1
if d == m then
D[d+r] = bits(64) UNKNOWN;
else
for e = 0 to h-1
Elem[D[d+r],2*e+1,esize] = Elem[Din[m+r],2*e,esize];
Elem[D[m+r],2*e,esize] = Elem[Din[d+r],2*e+1,esize];
Exceptions
Undefined Instruction, Hyp Trap.
VTRN{<c>}{<q>}.<size> <Qd>, <Qm> Encoded as Q = 1
VTRN{<c>}{<q>}.<size> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1098 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.421 VTST
Vector Test Bits takes each element in a vector, and bitwise ANDs it with the corresponding element of a second
vector. If the result is not zero, the corresponding element in the destination vector is set to all ones. Otherwise, it is
set to all zeros.
The operand vector elements can be any one of:
• 8-bit, 16-bit, or 32-bit fields.
The result vector elements are fields the same size as the operand vector elements.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if Q == ‘1’ && (Vd<0> == ‘1’ || Vn<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
if size == ‘11’ then UNDEFINED;
esize = 8 << UInt(size); elements = 64 DIV esize;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == ‘0’ then 1 else 2;
Encoding T1/A1 Advanced SIMD
VTST<c>.<size> <Qd>, <Qn>, <Qm>
VTST<c>.<size> <Dd>, <Dn>, <Dm>
1 1 0 1 1 1 1 0 D size Vn Vd 1 0 0 0 N Q M 1 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 1 0 0 1 0 0 D size Vn Vd 1 0 0 0 N Q M 1 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1099
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VTST instruction must be
unconditional. ARM strongly recommends that a Thumb VTST instruction is unconditional,
see Conditional execution on page A8-288.
<size> The data size for the elements of the operands. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10.
<Qd>, <Qn>, <Qm> The destination vector and the operand vectors, for a quadword operation.
<Dd>, <Dn>, <Dm> The destination vector and the operand vectors, for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
for r = 0 to regs-1
for e = 0 to elements-1
if !IsZero(Elem[D[n+r],e,esize] AND Elem[D[m+r],e,esize]) then
Elem[D[d+r],e,esize] = Ones(esize);
else
Elem[D[d+r],e,esize] = Zeros(esize);
Exceptions
Undefined Instruction, Hyp Trap.
VTST{<c>}{<q>}.<size> {<Qd>,} <Qn>, <Qm> Encoded as Q = 1
VTST{<c>}{<q>}.<size> {<Dd>,} <Dn>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1100 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.422 VUZP
Vector Unzip de-interleaves the elements of two vectors. See Table A8-13 and Table A8-14 for examples of the
operation.
The elements of the vectors can be 8-bit, 16-bit, or 32-bit. There is no distinction between data types.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (Q == ‘0’ && size == ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
quadword_operation = (Q == ‘1’); esize = 8 << UInt(size);
d = UInt(D:Vd); m = UInt(M:Vm);
Table A8-13 shows the operation of a doubleword VUZP.8 instruction, and Table A8-14 shows the operation of a
quadword VUZP.32 instruction, and
Encoding T1/A1 Advanced SIMD
VUZP<c>.<size> <Qd>, <Qm>
VUZP<c>.<size> <Dd>, <Dm>
Table A8-13 Operation of doubleword VUZP.8
Register state before operation Register state after operation
Dd A7 A6 A5 A4 A3 A2 A1 A0 B6 B4 B2 B0 A6 A4 A2 A0
Dm B7 B6 B5 B4 B3 B2 B1 B0 B7 B5 B3 B1 A7 A5 A3 A1
Table A8-14 Operation of quadword VUZP.32
Register state before operation Register state after operation
Qd A3 A2 A1 A0 B2 B0 A2 A0
Qm B3 B2 B1 B0 B3 B1 A3 A1
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 0 0 1 0 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 1 1 D 1 1 size 1 0 Vd 0 0 0 1 0 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1101
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VUZP instruction must be
unconditional. ARM strongly recommends that a Thumb VUZP instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10 for a quadword operation.
Doubleword operation with <size> = 32 is a pseudo-instruction.
<Qd>, <Qm> The vectors for a quadword operation.
<Dd>, <Dm> The vectors for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
if quadword_operation then
if d == m then
Q[d>>1] = bits(128) UNKNOWN; Q[m>>1] = bits(128) UNKNOWN;
else
zipped_q = Q[m>>1]:Q[d>>1];
for e = 0 to (128 DIV esize) - 1
Elem[Q[d>>1],e,esize] = Elem[zipped_q,2*e,esize];
Elem[Q[m>>1],e,esize] = Elem[zipped_q,2*e+1,esize];
else
if d == m then
D[d] = bits(64) UNKNOWN; D[m] = bits(64) UNKNOWN;
else
zipped_d = D[m]:D[d];
for e = 0 to (64 DIV esize) - 1
Elem[D[d],e,esize] = Elem[zipped_d,2*e,esize];
Elem[D[m],e,esize] = Elem[zipped_d,2*e+1,esize];
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instruction
VUZP.32 <Dd>, <Dm> is a synonym for VTRN.32 <Dd>, <Dm>. For details see VTRN on page A8-1096.
VUZP{<c>}{<q>}.<size> <Qd>, <Qm> Encoded as Q = 1
VUZP{<c>}{<q>}.<size> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1102 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.423 VZIP
Vector Zip interleaves the elements of two vectors. See Table A8-15 and Table A8-16 for examples of the operation.
The elements of the vectors can be 8-bit, 16-bit, or 32-bit. There is no distinction between data types.
Depending on settings in the CPACR, NSACR, and HCPTR registers, and the security state and mode in which the
instruction is executed, an attempt to execute the instruction might be UNDEFINED, or trapped to Hyp mode.
Summary of access controls for Advanced SIMD functionality on page B1-1233 summarizes these controls.
ARM deprecates the conditional execution of any Advanced SIMD instruction encoding that is not also available
as a VFP instruction encoding, see Conditional execution on page A8-288.
if size == ‘11’ || (Q == ‘0’ && size == ‘10’) then UNDEFINED;
if Q == ‘1’ && (Vd<0> == ‘1’ || Vm<0> == ‘1’) then UNDEFINED;
quadword_operation = (Q == ‘1’); esize = 8 << UInt(size);
d = UInt(D:Vd); m = UInt(M:Vm);
Table A8-15 shows the operation of a doubleword VZIP.8 instruction, and Table A8-16 shows the operation of a
quadword VZIP.32 instruction.
Encoding T1/A1 Advanced SIMD
VZIP<c>.<size> <Qd>, <Qm>
VZIP<c>.<size> <Dd>, <Dm>
Table A8-15 Operation of doubleword VZIP.8
Register state before operation Register state after operation
Dd A7 A6 A5 A4 A3 A2 A1 A0 B3 A3 B2 A2 B1 A1 B0 A0
Dm B7 B6 B5 B4 B3 B2 B1 B0 B7 A7 B6 A6 B5 A5 B4 A4
Table A8-16 Operation of quadword VZIP.32
Register state before operation Register state after operation
Qd A3 A2 A1 A0 B1 A1 B0 A0
Qm B3 B2 B1 B0 B3 A3 B2 A2
1 1 1 1 1 1 1 1 D 1 1 size 1 0 Vd 0 0 0 1 1 Q M 0 Vm
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 1 0 1 1 1 D 1 1 size 1 0 Vd 0 0 0 1 1 Q M 0 Vm
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1103
ID051414 Non-Confidential
Assembler syntax
where:
<c>, <q> See Standard assembler syntax fields on page A8-287. An ARM VZIP instruction must be
unconditional. ARM strongly recommends that a Thumb VZIP instruction is unconditional, see
Conditional execution on page A8-288.
<size> The data size for the elements of the vectors. It must be one of:
8 Encoded as size = 0b00.
16 Encoded as size = 0b01.
32 Encoded as size = 0b10 for a quadword operation.
Doubleword operation with <size> = 32 is a pseudo-instruction.
<Qd>, <Qm> The vectors for a quadword operation.
<Dd>, <Dm> The vectors for a doubleword operation.
Operation
if ConditionPassed() then
EncodingSpecificOperations(); CheckAdvSIMDEnabled();
if quadword_operation then
if d == m then
Q[d>>1] = bits(128) UNKNOWN; Q[m>>1] = bits(128) UNKNOWN;
else
bits(256) zipped_q;
for e = 0 to (128 DIV esize) - 1
Elem[zipped_q,2*e,esize] = Elem[Q[d>>1],e,esize];
Elem[zipped_q,2*e+1,esize] = Elem[Q[m>>1],e,esize];
Q[d>>1] = zipped_q<127:0>; Q[m>>1] = zipped_q<255:128>;
else
if d == m then
D[d] = bits(64) UNKNOWN; D[m] = bits(64) UNKNOWN;
else
bits(128) zipped_d;
for e = 0 to (64 DIV esize) - 1
Elem[zipped_d,2*e,esize] = Elem[D[d],e,esize];
Elem[zipped_d,2*e+1,esize] = Elem[D[m],e,esize];
D[d] = zipped_d<63:0>; D[m] = zipped_d<127:64>;
Exceptions
Undefined Instruction, Hyp Trap.
Pseudo-instructions
VZIP.32 <Dd>, <Dm> is a synonym for VTRN.32 <Dd>, <Dm>. For details see VTRN on page A8-1096.
VZIP{<c>}{<q>}.<size> <Qd>, <Qm> Encoded as Q = 1
VZIP{<c>}{<q>}.<size> <Dd>, <Dm> Encoded as Q = 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1104 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.424 WFE
Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of
events occurs, including events signaled by executing the SEV instruction on any processor in the multiprocessor
system. For more information, see Wait For Event and Send Event on page B1-1200.
In an implementation that includes the Virtualization Extensions, if HCR.TWE is set to 1, execution of a WFE
instruction in a Non-secure mode other than Hyp mode generates a Hyp Trap exception if, ignoring the value of the
HCR.TWE bit, conditions permit the processor to suspend execution. For more information see Trapping use of the
WFI and WFE instructions on page B1-1256.
// No additional decoding required
// No additional decoding required
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
// No additional decoding required
Encoding T1 ARMv7 (executes as NOP in ARMv6T2)
WFE<c>
Encoding T2 ARMv7 (executes as NOP in ARMv6T2)
WFE<c>.W
TOKENWFE<c>
1 0 1 1 1 1 1 1 0 0 1 0 0 0 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 1 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 1 0
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1105
ID051414 Non-Confidential
Assembler syntax
WFE{<c>}{<q>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if EventRegistered() then
ClearEventRegister();
else
if HaveVirtExt() && !IsSecure() && !CurrentModeIsHyp() && HCR.TWE == ‘1’ then
HSRString = Zeros(25);
HSRString<0> = ‘1’;
WriteHSR(‘000001’, HSRString);
TakeHypTrapException();
else
WaitForEvent();
Exceptions
Hyp Trap.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1106 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.425 WFI
Wait For Interrupt is a hint instruction that permits the processor to enter a low-power state until one of a number
of asynchronous events occurs. For more information, see Wait For Interrupt on page B1-1203.
In an implementation that includes the Virtualization Extensions, if HCR.TWI is set to 1, execution of a WFI
instruction in a Non-secure mode other than Hyp mode generates a Hyp Trap exception if, ignoring the value of the
HCR.TWI bit, conditions permit the processor to suspend execution. For more information see Trapping use of the
WFI and WFE instructions on page B1-1256.
// No additional decoding required
// No additional decoding required
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
// No additional decoding required
Encoding T1 ARMv7 (executes as NOP in ARMv6T2)
WFI<c>
Encoding T2 ARMv7 (executes as NOP in ARMv6T2)
WFI<c>.W
TOKENWFI<c>
1 0 1 1 1 1 1 1 0 0 1 1 0 0 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 1 1
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 1 1
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1107
ID051414 Non-Confidential
Assembler syntax
WFI{<c>}{<q>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
Operation
if ConditionPassed() then
EncodingSpecificOperations();
if HaveVirtExt() && !IsSecure() && !CurrentModeIsHyp() && HCR.TWI == ‘1’ then
HSRString = Zeros(25);
HSRString<0> = ‘0’;
WriteHSR(‘000001’, HSRString);
TakeHypTrapException();
else
WaitForInterrupt();
Exceptions
Hyp Trap.
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
A8-1108 Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. ARM DDI 0406C.c
Non-Confidential ID051414
A8.8.426 YIELD
YIELD is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the
hardware that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system
performance. Hardware can use this hint to suspend and resume multiple software threads if it supports the
capability.
For more information about the recommended use of this instruction see The Yield instruction on page A4-178.
// No additional decoding required
// No additional decoding required
For the case when cond is 0b1111, see Unconditional instructions on page A5-216.
// No additional decoding required
Encoding T1 ARMv7 (executes as NOP in ARMv6T2)
YIELD<c>
Encoding T2 ARMv7 (executes as NOP in ARMv6T2)
YIELD<c>.W
TOKENYIELD<c>
1 0 1 1 1 1 1 1 0 0 0 1 0 0 0 0
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 0 1
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1
1514131211 10 9 8 7 6 5 4 3 2 1 0
cond 0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 0 1
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
A8 Instruction Descriptions
A8.8 Alphabetical list of instructions
ARM DDI 0406C.c Copyright © 1996-1998, 2000, 2004-2012, 2014 ARM. All rights reserved. A8-1109
ID051414 Non-Confidential
Assembler syntax
YIELD{<c>}{<q>}
where:
<c>, <q> See Standard assembler syntax fields on page A8-287.
Operation
if ConditionPassed